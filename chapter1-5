////1-1
//#include <iostream>
//#include <iomanip>
//using namespace std;
//
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	double aver;
//	aver = (a + b + c) / 3;
//	cout << fixed << setprecision(3) << aver;
//	system("pause");
//}

////1-2
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	double f;
//	cin >> f;
//	double c = 5 * (f - 32) / 9;
//	cout << fixed << setprecision(3) << c;
//	system("pause");
//}

////1-3
//#include <iostream>
//using namespace std;
//int main() {
//	int n, sum = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		sum = sum + i;
//	}
//	cout << sum;
//	system("pause");
//}

////1-4
//#include <iostream>
//#include <math.h>
//using namespace std;
//int main() {
//	int n;
//	double PI = 3.1415926;
//	cin >> n;
//	cout << sin(n * PI / 180)<<endl;
//	cout << cos(n * PI / 180) << endl;
//	system("pause");
//}

////1-5
//#include <iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	if (95 * n <= 300) {
//		cout << 95 * n;
//	}
//	else {
//		cout << 95 * n*0.85;
//	}
//	system("pause");
//}

////1-6
//#include <iostream>
//#include <math.h>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	if (a + b <= c&&a + c <= b&&b + c <= a) {
//		cout << "not a triangle";
//	}
//	else {
//		if ((pow(a, 2) + pow(b, 2) == pow(c, 2)) || (pow(a, 2) + pow(c, 2) == pow(b, 2)) || pow(b, 2) + pow(c, 2) == pow(a, 2)) {
//			cout << "yes";
//		}
//		else cout << "no";
//	}
//	system("pause");
//}

////1-7
//#include <iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int m = floor(n / 4 + 0.5);
//	if(m * 4 == n){
//		int m2 = floor(n / 100 + 0.5);
//		if(m2 * 100 == n){
//			int m3 = floor(n / 400 + 0.5);
//			if (m3 * 400 == n) {
//				cout << "yes";
//			}
//			else cout << "no";
//		}
//		else cout << "yes";
//	}
//	else cout << "no";
//	system("pause");
//}

////例题2-4
//#include <iostream>
//#include <time.h>
//using namespace std;
//int main() {
//	const int MOD = 1000000;
//	int n, m = 1, sum = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= i; j++) {
//			m = m * j % MOD;
//		}
//		sum = (sum + m) % MOD;
//		m = 1;
//	}
//	cout << sum % MOD<<endl; 
//	cout << (double)clock() / CLOCKS_PER_SEC;
//	system("pause");
//}

////例题2-5
//#include <iostream>
//using namespace std;
//int main() {
//	const int INF = 1000000000;
//	int a,min = INF, max = -INF, count=0,sum = 0;
//	while (cin>>a) {
//		if (a < min) {
//			min = a;
//		}
//		if (a >= max) {
//			max = a;
//		}
//		sum = sum + a;
//		count++;
//	}
//	cout << min<<endl<<max<<endl<<sum / count<<endl;
//	system("pause");
//}

////例题2-6
//#include <iostream>
//using namespace std;
//int main() {
//	const int INF = 1000000000;
//	int n, a, group = 0,min = INF,max = -INF,sum = 0;
//	while (cin >> n && n != 0) {
//		for (int i = 1; i <= n;i++) {
//			cin >> a;
//			if (a < min)min = a;
//			if (a >= max)max = a;
//			sum = sum + a;
//		}
//		group++;
//		cout << "Case " << group << ": " << min << " " << max << " " << (double)sum / n << endl;
//		sum = 0;
//	}
//	system("pause");
//}

////2-1
//#include <iostream>
//using namespace std;
//int main() {
//	for (int i = 1; i < 9; i++) {
//		for (int j = 0; j < 9; j++) {
//			for (int k = 0; k < 9; k++) {
//				if ((i * 100 + j * 10 + k) == (pow(i, 3) + pow(j, 3) + pow(k, 3))) {
//					cout << i * 100 + j * 10 + k<<endl;
//				}
//			}
//		}
//	}
//	system("pause");
//}

////2-2
//#include <iostream>
//using namespace std;
//int main() {
//	int n, a, b, c,group = 0;
//	bool flag = false;
//	int total = 0;
//	while (cin >> a>> b>> c) {
//		group++;
//		for (int i = 3; i < 34; i++) {
//			for (int j = 1; j < 21; j++) {
//				for (int k = 1; k < 15; k++) {
//					if ((3 * i + a) == (5 * j + b) && (5 * j + b) == (7 * k + c) && (3 * i + a) <= 100 ){
//						total = 3 * i + a;
//						flag = true;
//					}
//				}
//			}
//		}
//		if (flag) {
//			cout << "Case " << group << ": " << total << endl;
//			flag = false;
//		}
//		else cout << "Case " << group << ": No answer" << endl;
//		system("pause");
//	}
//}

////2-3
//#include <iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	if (n <= 20) {
//		for (int i = n; i >= 1; i--) {
//			for (int j = n - i; j > 0;j--) {
//				cout << " ";
//			}
//			for (int k = 1; k <= 2 * i - 1;k++) {
//				cout << "#";
//			}
//			for (int j = n - i; j > 0; j--) {
//				cout << " ";
//			}
//			cout << endl;
//		}
//	}
//	system("pause");
//}

////2-4
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n, m, group = 1;
//	double sum = 0.0;
//	while (cin>>n>>m && n < m <= pow(10, 6)){
//		if (n == 0 && m == 0) {
//			return 0;
//		}
//		for (int i = n; i <= m; i++) {
//			sum = sum + 1/pow(i,2);
//		}
//		cout << "Case "<<group<<": "<<fixed << setprecision(5) << sum;
//		sum = 0.0;
//		group++;
//	}
//	system("pause");
//}

////2-5
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	int a, b, c;
//	while (cin >> a >> b >> c && a < pow(10, 6) && b < pow(10, 6) && c <= 100) {
//		if (a == 0 && b == 0 && c == 0) {
//			return 0;
//		}
//		else {
//			cout << fixed << setprecision(c) << (double)a / b;
//		}
//	}
//	system("pause");
//	
//}

////2-6 要用到数学方法 加起来等于45 乘起来等于362880
//#include <iostream>
//using namespace std;
//int main() {
//	int a, b, c, d, e, f, g, h, i;
//	int def, ghi;
//	for (int abc = 123; abc <= 329;abc++) {
//		def = abc * 2;
//		ghi = abc * 3;
//		a = abc / 100;
//		b = (abc - a * 100) / 10;
//		c = (abc - a * 100 - b * 10) / 1;
//
//		d = def / 100;
//		e = (def - d * 100) / 10;
//		f = (def - d * 100 - e * 10) / 1;
//
//		g = ghi / 100;
//		h = (ghi - g * 100) / 10;
//		i = (ghi - g * 100 - h * 10) / 1;
//
//		if (a + b + c + d + e + f + g + h + i == 45 && a*b*c*d*e*f*g*h*i == 362880) {
//			cout << abc << " " << def << " " << ghi << endl;
//		}
//	}
//	system("pause");
//}

////例3-2
//#include <iostream>
//using namespace std; 
//const int maxn = 1010;
//int a[maxn];
//int main() {
//	int n, k,first = 1;//first 用于第一个前面没有空格
//	cin >> n >> k;
//	memset(a, 0, sizeof(a);//menset用于把数组置0
//	/*for (int i = 1; i <= n; i++) {
//		a[i] = 0;
//	}*/
//	for (int i = 1; i <= k; i++) {
//		for (int j = 0; j <= n; ) {
//			a[j] = a[j] + 1;
//			j = j + i;
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		if (a[i] % 2 == 1) {
//			if (first) {
//				cout << i;
//				first = 0;
//			}
//			else {
//				cout << " " << i;
//			}
//		}
//	}
//	system("pause");
//}

////例3-3
//#include <iostream>
//using namespace std;
//const int maxn = 8;
//int a[maxn][maxn];
//int main() {
//	int n,count = 1,first = 1;//first用于调整格式
//	int x, y;
//	cin >> n;
//	memset(a, 0, sizeof(a));//先把整个二维矩阵置为0
//	a[x = 0][y = n - 1] = 1;//初始化右上角
//	while (count < n*n) {//只能小于，不能小于等于。比如n=4，等于16的时候继续往下走就超了
//
//		while (x + 1 < n && !a[x + 1][y]) {//先判断再走，走的时候先++，注意：判断时候不能++
//			a[++x][y] = ++count;
//			//cout << a[x][y];
//		}
//		while (y - 1 >= 0 && !a[x][y - 1]) {
//			a[x][--y] = ++count;
//			//cout << a[x][y];
//		}
//		while (x - 1 >= 0 && !a[x - 1][y]) {
//			a[--x][y] = ++count;
//			//cout << a[x][y];
//		}
//		while (y + 1 < n && !a[x][y + 1]) {
//			a[x][++y] = ++count;
//			//cout << a[x][y];
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (first) {
//				cout << a[i][j];
//				first = 0;
//			}else{
//				cout << " " << a[i][j] ;
//			}
//		}
//		cout << endl;
//		first = 1;
//	}
//	system("pause");
//}

////例3-4 竖式问题
//#include <iostream>
//#include <stdio.h>
////#define _CRT_SECURE_NO_WARNINGS
//using namespace std;
//int main() {
//	char s[20], buf[99];
//	int group = 0;
//	cin >> s;
//	for (int abc = 111; abc <= 999; abc++) {
//		for (int de = 11; de < 99; de++) {
//			int x = abc * (de % 10);
//			int y = abc * (de / 10);
//			int z = abc * de;
//			sprintf_s(buf, "%d%d%d%d%d", abc, de, x, y, z);
//			//cout << buf;
//			int ok = 1;
//			for (int i = 0; i < strlen(buf); i++) {
//				if (strchr(s, buf[i]) == NULL) {//该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。
//					ok = 0;
//				}
//			}
//			if (ok) {
//				cout << "<" << group << ">" << endl;
//				group++;
//				cout << "  " << abc << endl;
//				cout << "X  " << de << endl;
//				cout << "-----" << endl;
//				cout << " " << x << endl;
//				cout << y << " " << endl;
//				cout << "-----" << endl;
//				cout << z << endl;
//
//			}
//		}
//	}
//	cout << "The number of solutions = " << group << endl;
//	system("pause");
//}

////例题3-1 TeX中的引号（Tex Quotes, UVa 272）
///*用getchar一个一个读字符返回值为数字，输出再转化成字符*/
//#include <iostream>
//using namespace std;
//int main() {
//	int c;
//	int flag = 1;
//	while ((c = getchar()) != EOF)//EOF是结束符 
//	{
//		if (c == '"') {
//			if (flag) {
//				cout << "``";
//				flag = 0;
//			}
//			else {
//				cout << "''";
//				flag = 1;
//			}
//		}
//		else cout << (char)c;
//	}
//	system("pause");
//}

//例3-2
//#include <iostream>
//using namespace std;
//const char s[] = "`1234567890-=qwertyuiop[]\\asdfghjkl;'zxcvbnm,./";//是否需要加转义字符
//int main() {
//	int i = 1, c;
//	while ((c = getchar()) != EOF) {
//		for (i = 1; s[i] && s[i] != c; i++);
//		if (s[i])//必须判断s[i]是否存在，否则在敲回车时会找不到，直接输出/
//			putchar(s[i - 1]);//等效于cout << (char)s[i - 1];
//		else {
//			putchar(c);
//		}
//	}
//	system("pause");
//}
//
////3-3
//直接统计可得A，为了求B，对于每个数字（1～9），统计二者出现的次数c1和c2，则
//min(c1, c2)就是该数字对B的贡献。最后要减去A的部分。
//#include <iostream>
//using namespace std;
//char s[100];
//char r[] = "A***3**HIL*JM*O***2TUVWXY51SE*Z**8*";
//const char* text[] = { "not a palindrome.", "a regular palindrome", "a mirrored string", "is a mirrored palindrone" };
//char rever(char i) {
//	if (isalpha(i)) return r[i - 'A'];
//	else return r[i - '0' + 25];
//}
//int main() {
//	int flag1 = 1;
//	int flag2 = 1;
//	char c[30];
//	while (cin >> c) {
//		int len = strlen(c);
//		for (int i = 0; i < (len + 1) / 2; i++) {
//			if (c[i] != c[len - i - 1]) flag1 = 0;//不是回文
//			if (rever(i) != c[len - i - 1]) flag2 = 0;//不是镜像串
//		}
//		if (flag1 == 0) cout << text[0];
//		if (flag1 == 1) cout << text[1];
//		if (flag2 == 1) cout << text[2];
//		if (flag2 == 1 && flag1 == 1) cout << text[3];
//	}
//}

////3-5
//#include <iostream>
////#include <iomanip>
//using namespace std;
//const int maxn = 100050;
//int m[maxn];
//int g[6];
//int main() {
//	memset(m, 0, sizeof(m));
//	for (int n = 1; n <= maxn; n++) {
//		//取每一位，记住！
//		int x = n, sum = n;
//		while (x > 0) {
//			sum = sum + x % 10;
//			x = x / 10;
//		}
//
//		if (sum >= 1 && sum <= 100000) {
//			m[n] = sum;
//		}
//	}
//	int n;
//	while (cin >> n) {
//		for (int i = 0; i <= 100000; i++) {
//			//cout << m[i];
//			if (n == m[i]) {
//				cout << i;
//				system("pause");
//				break;
//			}
//		}
//		cout << 0;
//		system("pause");
//	}
//
//}

////3-6
//#include <iostream>
//using namespace std;
//const int maxn = 100;
//int  compare(char *c, int i, int ans) {
//	int l = strlen(c);
//	for (int j = 0; j < l; j++) {
//		if (c[(i + j) % l] < c[(ans + j) % l]) {
//			return 1;
//		}
//		else if (c[(i + j) % l] > c[(ans + j) % l]) {
//			return 0;
//		}
//	}
//	return 0;
//}
//int main() {
//	char c[maxn];
//	int ans = 0;
//	while (cin >> c) {
//		int l = strlen(c);
//		for (int i = 1; i < l; i++) {
//			if (compare(c, i, ans)) {
//				ans = i;
//			}
//		}
//		//cout << ans;
//		for (int i = 0; i < l; i++) {
//			putchar(c[(ans + i) % l]);
//		}
//	}
//	system("pause");
//}

////必要的存储量 什么时候用数组 什么时候不用数组
//#include <iostream>
//using namespace std;
//int main() {
//	//统计个数 win的结束要先回车，再Ctrl+Z
//	int n;
//	int count = 0;
//	while (cin >> n) {
//		count++;
//		cout << count;
//	}
//	cout << count;
//	system("pause");
//
//	//最大 最小 平均
//	int m, Max, Min, sum = 0, flag = 0,count = 0;
//	while (cin >> m) {
//		if (!flag) {
//			Max = m;
//			Min = m;
//			sum = sum + m;
//			flag = 1;
//			count++;
//		}
//		else {
//			if (m > Max) Max = m;
//			if (m < Min) Min = m;
//			sum = sum + m;
//			count++;
//		}
//		
//	}
//	cout << Max << "," << Min << "," << (double)sum / count << endl;
//	system("pause");
//
//	//求两个最接近的数
//	const int maxn = 100;
//	int c[maxn];
//	int min;
//	int n, num = 0;
//	while (cin >> n) {
//		c[num] = n;
//		num++;
//	}
//	int flag = 1;
//	for (int j = 0; j < num; j++) {
//		for (int k = j + 1; k < num; k++) {
//			if (flag) {
//				min = abs(c[k] - c[j]);
//				flag = 0;
//			}
//			else {
//				if (abs(c[k] - c[j]) < min) {
//					min = abs(c[k] - c[j]);
//				}
//			}
//		}
//	}
//	cout << min;
//	system("pause");
//
//
//}


////计算1的个数
//#include <iostream>
//using namespace std;
//#define maxn 10000000 + 10
//int main() {
//	int c, tot = 0;
//	while ((c = getchar()) != EOF) {//可以输入空格
//		//cout << c << endl;
//		if (c == 49) { //1对应int的49
//			tot++;
//		}
//	}
//	cout << tot;
//	system("pause");
//}

////3-1
//#include <iostream>
//using namespace std;
//const int maxn = 85;
//int main() {
//	char n[maxn];
//	char x;
//	int count = 0, sum = 0;
//	while (cin >> x) {
//		n[count] = x;
//		//cout << n[count];
//		count++;
//	}
//	for (int i = 0; i < count; i++) {
//		int tot = 1;
//		if (n[i] == (int)"X") {
//			sum = sum + 0;
//		}
//		else {
//			sum = sum + tot;
//			tot++;
//		}
//	}
//	cout << "sum:"<< sum;
//	system("pause");
//}


////3-2
//#include <iostream>
//using namespace std;
//double weight[4] = { 12.01,1.008,16.00,14.01 };
//const int maxn = 50;
//int tot(char *n, int i) {
//	int lenth = strlen(n);
//	if (i < lenth - 1) {//判断是不是最后一个元素，因为要判断i+1
//		if (isalpha(n[i + 1])) return 1;
//		else {
//			//cout <<"hhh"<< n[i + 1]<<endl;
//			return n[i + 1] - '0';
//		}
//	}
//	else return 1;
//	
//}
//int main() {
//	char n[maxn];
//	int sum = 0;
//	while (cin >> n) {//这里默认是没有空格，回车分割的字符串
//		int l = strlen(n);
//		double sum = 0.0;
//		for (int i = 0; i < l; i++) {
//			cout << n[i]<<"tot(n, i):"<< tot(n, i)<<endl;
//
//			if (isalpha(n[i])) {
//
//				if (n[i] == 'C') {//这里比的是字符，单引号！！
//					//cout << "C "<< weight[0]<<tot(n,i)<<endl;
//					sum = sum + weight[0] * tot(n, i);
//					//cout << sum;
//				}
//
//				if (n[i] == 'H') {
//					cout << "H";
//					sum = sum + weight[1] * tot(n, i);
//				}
//
//				if (n[i] == 'O') {
//					cout << "O";
//					sum = sum + weight[2] * tot(n, i);
//				}
//
//				if (n[i] == 'N') {
//					cout << "N";
//					sum = sum + weight[3] * tot(n, i);
//				}
//			}
//		}
//		cout << "sum" << sum;
//	}
//	system("pause");
//}


////3-3
//#include <iostream>
//using namespace std;
//const int maxn = 10050;
//const char number[10] = { '0','1','2','3','4','5','6','7','8','9' };
//int main() {
//	char c[maxn];
//	int count[10];
//	
//	while (cin >> c) {
//		memset(count, 0, sizeof(count));
//		int len = strlen(c);
//		for (int i = 0; i < len; i++) {
//			for (int j = 0; j < 10; j++) {
//				if (c[i] == number[j]) {
//					count[j] = count[j] + 1;
//				}
//			}
//		}
//		for (int i = 0; i < 10; i++) {
//			cout << count[i]<<" ";
//		}
//	}
//}

////3-4
//#include <iostream>
//using namespace std;
//const int maxn = 85;
//int check(char *c, int i) {
//	int len = strlen(c);
//	if ((len % (i + 1)) == 0) {
//		
//		int count = len / (i + 1);
//		//cout << "整除" << i + 1 <<"count： "<< count<< endl;
//		char m[maxn];
//		memset(m, 0, sizeof(m));
//		for (int k = 0; k <= i; k++) {
//			m[k] = c[k];
//			//cout << m[k];
//		}
//		//cout << endl;
//		//cout << "h"<<endl;
//		for(int k = 0; k < count;k++){
//			for (int j = 0; j <= i; j++) {
//				//cout << k * (i + 1) + j << " " << c[k*(i + 1) + j] << " " << m[j] << endl;
//				if (c[k*(i+1) + j] != m[j]) {
//					return 0;
//				}
//			}
//		}
//		return 1;
//	}
//	else {
//		return 0;
//	}
//}
//int main() {
//	char c[maxn];
//	while (cin >> c) {
//		int len = strlen(c);
//		for (int i = 0; i < len; i++) {
//			if (check(c, i)) {
//				cout << i+1;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//}


////3-5 不会写 只能正确运行一次
//#include <iostream>
//#include <string>
//using namespace std;
//
//const int maxn = 7;
//const int maxc = 10;
//int main() {
//	char m[maxn][maxn];
//	int blank[2] = { 0, 0 };
//	int cnt = 1;
//	while (cin.getline(m[0], 7)) {
//		
//		if ((strlen(m[0]) == 1) && (m[0][0] == 'Z')) {
//			return 0;
//		}
//		else {
//			for (int j = 0; j < 5; j++) {//判断第一行有无空格
//				if (m[0][j] == ' ') {
//					blank[0] = 0;
//					blank[1] = j;
//				}
//			}
//			for (int i = 1; i < 5; i++) {
//				cin.getline(m[i], 7);
//				for (int j = 0; j < 5; j++) {
//					if (m[i][j] == ' ') {
//						blank[0] = i;
//						blank[1] = j;
//					}
//				}
//			}
//			/*for (int i = 0; i < 5; i++) {
//				for (int j = 0; j < 5; j++) {
//					cout << m[i][j];
//				}
//				cout << endl;
//			}*/
//			char c[maxc];
//			while (cin >> c) {
//				int len = strlen(c);
//				cout << "len: " << len << endl;
//				for (int i = 0; i < len; i++) {
//					if (c[i] != '0') {
//						if (c[i] == 'A') {
//							if (blank[0] != 0) {
//								char temp;
//								temp = m[blank[0]][blank[1]];
//								m[blank[0]][blank[1]] = m[blank[0] - 1][blank[1]];
//								m[blank[0] - 1][blank[1]] = temp;
//
//								blank[0] = blank[0] - 1;
//								blank[1] = blank[1];
//							}
//							else {
//								cout << "wrong" << endl;
//							}
//						}
//						if (c[i] == 'B') {
//							if (blank[0] != 4) {
//								char temp;
//								temp = m[blank[0]][blank[1]];
//								m[blank[0]][blank[1]] = m[blank[0] + 1][blank[1]];
//								m[blank[0] + 1][blank[1]] = temp;
//								blank[0] = blank[0] + 1;
//								blank[1] = blank[1];
//							}
//							else {
//								cout << "wrong" << endl;
//							}
//						}
//						if (c[i] == 'L') {
//							if (blank[1] != 0) {
//								char temp;
//								temp = m[blank[0]][blank[1]];
//								m[blank[0]][blank[1]] = m[blank[0]][blank[1] - 1];
//								m[blank[0]][blank[1] - 1] = temp;
//
//								blank[0] = blank[0];
//								blank[1] = blank[1] - 1;
//							}
//							else {
//								cout << "wrong" << endl;
//							}
//						}
//						if (c[i] == 'R') {
//							if (blank[1] != 4) {
//								char temp;
//								temp = m[blank[0]][blank[1]];
//								m[blank[0]][blank[1]] = m[blank[0]][blank[1] + 1];
//								m[blank[0]][blank[1] + 1] = temp;
//
//
//								blank[0] = blank[0];
//								blank[1] = blank[1] + 1;
//							}
//							else {
//								cout << "wrong" << endl;
//							}
//						}
//					}
//					else {
//						break;
//					}
//				}
//				
//				cout << "Puzzle #" << cnt << ": " << endl;
//				cnt++;
//				for (int i = 0; i < 5; i++) {
//					for (int j = 0; j < 5; j++) {
//						cout << m[i][j];
//					}
//					cout << endl;
//				}
//				memset(m, 0, sizeof(m));
//				memset(c, 0, sizeof(c));
//				break;
//			}
//		}
//	}
//}





//网上标答
//#include"stdio.h"
//#include"string.h"
//#include <iostream>
//using namespace std;
//int main()
//{
//	int i, j, s = 0, l = 1, p;
//	char a[7][7], b[1001], c;
//	//while (cin >> a[0][0])
//	while (scanf_s("%c", &a[0][0]))
//	{
//		if (a[0][0] == 'Z') break;
//		j = 0, p = 1;//行列
//		s = 0;//记录空格位置
//		for (i = 1; i<30; i++)//把第一行空出来，从第二行开始 一共5行，一行6个
//		{
//			scanf_s("%c", &a[i / 6][i % 6]);//cin >> a[i / 6][i % 6]
//			if (a[i / 6][i % 6] == ' ')
//				s = i / 6 * 10 + i % 6;
//		}
//		for (i = 0; scanf_s("%c", &b[i]) == 1 && b[i] != '0'; i++);
//		scanf_s("%c", &c);
//		for (j = 0; j<i; j++)
//		{
//			if (b[j] == 'B')
//			{
//				if (s / 10 + 1>4)
//				{
//					p = 0; break;
//				}
//				a[s / 10][s % 10] = a[s / 10 + 1][s % 10];
//				a[s / 10 + 1][s % 10] = ' ';
//				s = (s / 10 + 1) * 10 + s % 10;
//			}
//			if (b[j] == 'A')
//			{
//				if (s / 10 - 1<0)
//				{
//					p = 0; break;
//				}
//				a[s / 10][s % 10] = a[s / 10 - 1][s % 10];
//				a[s / 10 - 1][s % 10] = ' ';
//				s = (s / 10 - 1) * 10 + s % 10;
//			}
//			if (b[j] == 'R')
//			{
//				if (s % 10 + 1>4)
//				{
//					p = 0; break;
//				}
//				a[s / 10][s % 10] = a[s / 10][s % 10 + 1];
//				a[s / 10][s % 10 + 1] = ' ';
//				s = (s / 10) * 10 + s % 10 + 1;
//			}
//			if (b[j] == 'L')
//			{
//				if (s % 10 - 1<0)
//				{
//					p = 0; break;
//				}
//				a[s / 10][s % 10] = a[s / 10][s % 10 - 1];
//				a[s / 10][s % 10 - 1] = ' ';
//				s = (s / 10) * 10 + s % 10 - 1;
//			}
//		}
//		if (l>1)
//			printf("\n");
//		printf("Puzzle #%d:\n", l++);
//		if (p == 0)
//			printf("This puzzle has no final configuration.\n");
//		if (p == 1)
//			for (i = 0; i<5; i++)
//			{
//				printf("%c", a[i][0]);
//				for (j = 1; j<5; j++)
//					printf(" %c", a[i][j]);
//				printf("\n");
//			}
//	}
//}




//读矩阵操作 记住
//#include <iostream>
//using namespace std;
//int main()
//{
//	int n;
//	char Map[10][10];
//	char operation[105];
//	while (cin.getline(Map[0], 10)) {
//
//		if (strlen(Map[0]) == 1 && Map[0][0] == 'Z') {
//			break;
//		}
//		for (int i = 1; i<5; i++) {
//			cin.getline(Map[i], 10);
//			//cout << Map[i] << endl;
//		}
//		for (int i = 0; i < 5; i++) {
//			for (int j = 0; j < 5; j++) {
//				cout << Map[i][j];
//			}
//			cout << endl;
//		}
//		scanf_s("%s", operation);
//		cin.getline(Map[0], 10);
//	}
//	system("pause");
//	return 0;
//}



//#include <iostream>
//using namespace std;
//int main() {
//	cout<<hypot(3, 4);//求两个数的平方和开方
//	system("pause");
//}

////4-2组合数
//#include <iostream>
//using namespace std;
//long long C(int m, int n) {
//	long long ans = 1;
//	if (m < n - m) {//先乘少的
//		m = n - m;
//	}
//	for (int i = m + 1; i <= n; i++) {
//		ans = ans * i;
//	}
//	for (int i = 1; i <= n - m; i++) {
//		ans = ans / i;
//	}
//	return ans;
//}
//int main() {
//	cout<<C(1, 21);
//	system("pause");
//}

////计算左闭右开区间内元素的和 记住指针的用法
//#include <iostream>
//using namespace std;
//int Sum(int* begin, int* end) {
//	int ans = 0;
//	for (int *p = begin; p != end; p++) {
//		ans = ans + *p;
//	}
//	return ans;
//}
//int main() {
//	int a[3] = { 1,2,3 };
//	
//	cout<< Sum(a, a+3);
//	system("pause");
//}

////例4-2 刽子手游戏
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//const int maxn = 50;
//int lef, chance;
////int win, lose;
//char s[maxn], s2[maxn];
//void check(char ch) {
//	bool is_find = false;
//	//cout << lef << endl;
//	for (int i = 0; i < strlen(s); i++) {
//		if (ch == s[i]) {
//			s[i] = ' ';
//			is_find = true;
//			lef--;
//			//cout << ch <<" left: "<< lef<< endl;
//		}
//	}
//	if (!is_find) chance--;
//}
//int main() {
//	int rnd;
//	//cout << "h" << endl;
//	while (true) {//scanf_s("%d%s%s", &rnd, s, s2) == 3 && rnd != -1
//		cin >> rnd;
//		if (rnd == -1) {
//			return 0;
//		}
//		cout << "Round " << rnd << endl;
//		cin >> s >> s2;
//		//cout << rnd <<" s: "<<s<<" s2: "<<s2 <<endl;
//		lef = strlen(s);
//		chance = 7;
//		for (int i = 0; i < strlen(s2); i++) {
//			check(s2[i]);
//		}
//		if (lef == 0) {
//			cout << "You win." << endl;
//		}
//		else if (chance == 0) {
//			cout << "You lose." << endl;
//		}
//		else {
//			cout << "You chickened out." << endl;
//		}
//	}
//	return 0;
//}


////救济金 记住game函数的写法 game函数不会写的
//#include <iostream>
//using namespace std;
//const int maxn = 20;
//int c[maxn];
//int lef;
//int a, b;
//void game(int step, int cnt, int tot) {
//	int i;
//	for (int i = 0; i < 20; i++) {
//		cout << c[i] << " ";
//	}
//	cout << endl;
//	//cout << "a: " << a << " b: " << b << endl;
//	if (step == 1) {
//		i = a;
//	}
//	else {
//		i = b;
//	}
//
//	while (cnt--) {
//		do {
//			i = (i + step + tot - 1) % tot + 1;//记住 ！！！！！
//		} while (c[i] == 0 || c[i] == -10);
//	}
//	if (step == 1) {
//		a = i;
//		c[a] = 0;
//	}
//	else {
//		b = i;
//		c[b] = 0;
//	}
//	//cout << "lef: " << lef << " a: " << a << " b: " << b << endl;
//}
//int main() {
//	memset(c, -1, sizeof(c));
//	int n, k, m;
//	cin >> n >> k >> m;
//	lef = n;
//	a = 0;
//	b = n + 1;
//	for (int i = 1; i <= n; i++) {
//		c[i] = 1;
//	}
//
//	for (;;) {
//		if (lef == 0) break;
//		game(1, k, n);
//		//cout << "hhh" << endl;
//		game(-1, m, n);
//		if (a == b) {
//			lef--;
//			cout << a << ", "<<endl;
//		}
//		else {
//			lef = lef - 2;
//			cout << a << " " << b << ", "<<endl;
//		}
//
//	}
//	system("pause");
//}

////信息解码
//#include <iostream>
//using namespace std;
//const int maxn = 10;
//int value;
//char code[maxn][maxn];
//char readchar() {//因为编码头前面可能有很多空行，正文也有回车
//	char ch = getchar();
//	if (ch != '\n' || ch != '\r') {
//		return ch;
//	}
//}
//void readcodes() {
//	memset(code, 0, sizeof(code));
//	//cout << "1" << endl;
//	code[1][0] = readchar();
//	//cout << code[1][0];
//	for (int i = 2; i <= 7; i++) {
//		for (int j = 0; j < (1 << i) - 1; j++) {
//			char ch = readchar();
//			if (ch == EOF) {
//				break;
//				//cout << "EOF" << endl;
//			}
//			if (ch == '\n' || ch == '\r') {//注意这里的与或判断
//				//cout << "quit" << endl;
//				return;
//			}
//			else {
//				code[i][j] = ch;
//				//cout << code[i][j];
//			}
//		}
//	}
//}
//int getint(int length) {
//	//cout << "length" << length << endl;
//	int v = 0;
//	while (length--) {
//		v = v * 2 + readchar() - '0';//二进制--》十进制
//		//cout << length << " " << v << endl;
//	}
//	if (v == (1 << length) - 1) {//左移位相当于乘以2，记住！
//		return 0;
//	}
//	//system("pause");
//	return v;
//}
////void printcode() {
////	for (int i = 0; i <= 7; i++) {
////		for (int j = 0; j <= (1 << i) - 1; j++) {
////			if (code[i][j] == 0) {
////				return;
////			}
////			else {
////				cout << code[i][j] << " " << endl;
////			}
////		}
////	}
////}
//int main() {
//	readcodes();
//	//cout << "readcodes" << endl;
//	while (true) {
//		int len = getint(3);
//		if (len == 0) {
//			system("pause");
//			return 0;
//		}
//		//cout << "hhh" << endl;
//		while (true) {
//			value = getint(len);
//			if (value == (1 << len) - 1) {
//				break;
//			}
//			else {
//				//putchar(code[len][value]);
//				cout << code[len][value] << " ";
//			}
//		}
//	}
//	system("pause");
//}


////5-1 sort lower_bound的用法 
//#include <iostream>
//#include <algorithm>
//using namespace std;
//const int maxn = 10;
//int main() {
//	int n[maxn], q[maxn];
//	int cntn = 0, cntq = 0;
//	int N, Q, rnd = 1;
//	while (cin >> N >> Q) {
//		memset(n, 5, sizeof(n));
//		memset(q, 5, sizeof(n));
//		cout << "CASE# " << rnd << ":" << endl;
//		rnd++;
//		for (int i = 0; i < N; i++) {
//			cin >> n[i];
//			//cout << n[i] << endl;
//		}
//		for (int i = 0; i < Q; i++) {
//			cin >> q[i];
//			//cout << q[i] << endl;
//		}
//		sort(n, n + N);//这里N是个数 ， n是数组首地址
//		
//		for (int i = 0; i < Q; i++) {
//			//注意！！返回的是地址 要减去首地址
//			int p = lower_bound(n, n + N, q[i]) - n;
//		}
//		//下面注释这一块儿可以用标准库中的函数代替
//		/*for (int i = 0; i < Q; i++) {
//			int flag = 0;
//			for (int j = 0; j < N; j++) {
//				if (q[i] == n[j]) {
//					cout << q[i] << " found at " << j + 1<< endl;
//					flag = 1;
//					break;
//				}
//			}
//			if (!flag) {
//				cout << q[i] << " not found" << endl;
//			}
//		}*/
//	}
//	system("pause");
//}

////木块问题 vector<int> n[maxn] push_back  size resize用法
//#include <iostream>
//#include <vector>
//#include <string>
//using namespace std;
//const int maxn = 30;
//
//int n;//堆数
//vector<int> pile[maxn];
//
//void find_p(int a, int& ap, int& ah) {
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < pile[i].size(); j++) {
//			if (pile[i][j] == a) {
//				ap = i;
//				ah = j;
//			}
//		}
//	}
//}
//void clear_above(int ap, int ah) {
//	for (int i = ah + 1; i < pile[ap].size(); i++) {
//		int temp = pile[ap][i];
//		cout << "temp " << temp << endl;
//		pile[temp].push_back(temp);
//	}
//	pile[ap].resize(ah + 1);
//}
//void pile_on(int ap, int ah, int bp) {	
//	for (int i = ah; i < pile[ap].size(); i++) {
//		pile[bp].push_back(pile[ap][i]);//这里存进去的不是i是原来ap i的元素
//	}
//	pile[ap].resize(ah);
//}
//void print_pile() {
//	for (int i = 0; i < n; i++) {
//		cout << i << ": ";
//		for (int j = 0; j < pile[i].size(); j++) {
//			cout<< pile[i][j] << " ";
//		}
//		cout << endl;
//	}
//}
//int main() {
//	while (true) {
//		cin >> n;
//		for (int i = 0; i < n; i++) {
//			pile[i].push_back(i);
//		}
//		//print_pile();
//		string s1, s2;
//		int a, b;
//		int ap, bp;
//		int  ah, bh;
//		while (true) {
//			cin >> s1;//包含头文件string
//			if (s1 == "quit") {
//				//cout << "quit" << endl;
//				break;
//				system("pause");
//			}
//			cin >> a >> s2 >> b;
//			//cout << s1 << a << s2 << b << endl;
//			
//			find_p(a, ap, ah);
//			find_p(b, bp, bh);
//			cout << "ap: " << ap << " ah: " << ah << "bp: " << bp << " bh: " << bh << endl;
//			if (ap == bp) {
//				cout << "wrong cmd" << endl;
//				continue;
//			}
//			if (s1 == "move") {
//				clear_above(ap, ah);
//			}
//			if (s2 == "onto") {
//				clear_above(bp, bh);
//			}
//			pile_on(ap, ah, bp);
//			//print_pile();
//		}
//		print_pile();
//	}
//	system("pause");
//}

////安迪的字典 set<string> dict   insert 另外函数isalpha tolower
//#include <iostream>
//#include <string>
//#include <sstream>
//#include <set>
//using namespace std;
//set<string> dict;
//int main() {
//	string s, temp;
//	while (cin >> s) {//这里不能存空格 相当于每个单词都循环了一波 这个时候的结束方式 回车 ctrl+z
//		for (int i = 0; i < s.length(); i++) {
//			if (isalpha(s[i])) {
//				s[i] = tolower(s[i]);//不区分大小写
//			}
//			else {
//				s[i] = ' ';//把标点符号换成空格，方便后面用ss分割
//			}
//		}
//		stringstream ss(s);
//		while (ss >> temp) {
//			dict.insert(temp);
//		}
//	}
//	for (set<string>::iterator p = dict.begin(); p != dict.end(); p++) {
//		cout << *p << endl;
//	}
//	system("pause");
//}


////反片语 map中不存在相同元素 map<string, int>  count(str)返回0、1 学会统计字符串出现的次数
//#include <iostream>
//#include <string>
//#include <sstream>
//#include <vector>
//#include <map>
//#include <set>
//#include <algorithm>
//using namespace std;
//
//vector<string> words;
//map<string, int> cnt;
//string repre(const string& s) {//要加const 保留最开始的大小写
//	//原字符串的引用 所以要再开一个字符串 因为要保留最开始的大小写
//	string ans;
//	//cout << "4 " << ans.length()<<endl;
//	for (int i = 0; i < s.length(); i++) {
//		ans[i] = tolower(s[i]);
//		ans.push_back(ans[i]);
//		//cout <<"ans.length(): "<< ans.length() << " i: " << i << endl;
//	}
//	//cout << "5" << endl;
//	sort(ans.begin(), ans.end());
//	//cout << "6" << endl;
//	return ans;
//}
//int main() {
//	string s;
//	while (cin >> s) {
//		//cout << "1" << endl;
//		if (s[0] == '#') {
//			break;
//		}
//		//cout << "2" << endl;
//		words.push_back(s);
//		//cout << "3" << endl;
//		string re = repre(s);
//		//cout << "5" << endl;
//		//cout << " re: " << re << " !cnt.count(re): " << !cnt.count(re) << endl;
//		/*统计每个字符串出现的次数*/
//		if (!cnt.count(re)) {//如果第一次出现 先置0 然后后面+1 就相当于出现第一次 技巧！
//			cnt[re] = 0;
//		}
//		cnt[re]++;
//	}
//
//	vector<string> ans;
//	for (int i = 0; i < words.size(); i++) {
//		if (cnt[repre(words[i])] == 1) {//如果只出现了一次
//			ans.push_back(words[i]);
//		}
//	}
//	sort(ans.begin(), ans.end());
//	//cout << "hhh" << endl;
//	for (int i = 0; i < ans.size(); i++) {
//		cout << ans[i] << endl;
//	}
//	system("pause");
//}

////5-5 宏定义 双射
////本题的集合并不是简单的整数集合或者字符串集合，而是小集合的大集合，
////为了方便起见，为每个不同的集合（大或小）分配一个唯一的ID，
////每个大集合都表示为它所包含小集合对应ID的大集合。
////所以用STL的set<int>表示这个大集合（是不是很迷乱 - -），
////整个栈就是一个stack<int>（每个大集合也有个ID啊）。
////这是标答
//#include<iostream>
//#include<set>
//#include<map>
//#include<vector>
//#include<stack>
//#include<string>
//#include <algorithm>
//#include <iterator>
//using namespace std;
//
//#define ALL(x) x.begin(),x.end()//所有的内容
//#define INS(x) inserter(x,x.begin())//插入迭代器
//
//
//typedef set<int> Set;//大集合 由小集合对应的ID组成 相当于栈的一层
//map<Set, int> IDCache;//栈的一层对应的ID
//vector<Set> setCache;//存的是栈的各层 通过size知道大小 因为在加入setCache之前会查重 所以直接用在vector里面的下标号码作为每层的ID号
////理解 对于任意集合x（就是栈的每层） IDCache[x]就是ID  setChache[IDCache[x]]就是x本身
//int ID(Set x) {//返回集合x对应的ID
//	if (IDCache.count(x)) {
//		return IDCache[x];
//	}
//	setCache.push_back(x); // 
//	return IDCache[x] = setCache.size() - 1;//返回该集合对应的下标作为ID
//}
//
//int main() {
//	stack<int> s;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		string op;
//		cin >> op;
//		if (op[0] == 'P') {
//			s.push(ID(Set()));
//		}
//		else if (op[0] == 'D') {
//			s.push(s.top());
//		}
//		else {
//			//找到栈顶ID对应的两个集合
//			Set x1 = setCache[s.top()];
//			s.pop();
//			Set x2 = setCache[s.top()];
//			s.pop();
//
//			Set temp;
//			if (op[0] == 'U') {
//				// 前四个参数为两个集合的首尾迭代器，最后一个参数为插入到新集合的指定位置
//				set_union(ALL(x1), ALL(x2), INS(temp));//加入头文件 <algorithm> <iterator>
//			}
//			else if (op[0] == 'I') {
//				set_intersection(ALL(x1), ALL(x2), INS(temp));
//			}
//			else if (op[0] == 'A') {
//				temp = x2;
//				temp.insert(ID(x1));
//			}
//			s.push(ID(temp));
//		}
//		cout << setCache[s.top()].size() << endl;
//	}
//	cout << "***" << endl;
//	system("pause");
//}

////5-5 自己写set -- insert  vector -- push_back pop_back stack -- push pop top
//#include <iostream>
//#include <stack>
//#include <set>
//#include <map>
//#include <vector>
//#include <algorithm>
//#include <iterator>
//#include <string>
//using namespace std;
//
//typedef set<int> Set;
//map<Set, int> cache;
//vector<Set> setCache;
//
//int getID(Set x) {
//	int ID;
//	if (cache.count(x) != 0) {
//		ID = cache[x];
//	}
//	else {
//		setCache.push_back(x);
//		cache[x] = setCache.size() - 1;
//		ID = cache[x];//这里还要把x加入到cache中 ！！！！！！
//	}
//	return ID;
//}
//int main() {
//	int n;
//	stack<int> s;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		string op;
//		cin >> op;
//		if (op[0] == 'P') {
//			s.push(getID(Set()));
//		}
//		else if (op[0] == 'D') {
//			s.push(s.top());
//		}
//		else {
//			Set x1 = setCache[s.top()];
//			s.pop();
//			Set x2 = setCache[s.top()];
//			s.pop();
//			Set temp;
//			if (op[0] == 'U') {
//				//这里的结果是存在temp里面的 所以在执行完下面三个if后 统一入栈
//				set_union(x1.begin(), x1.end(), x2.begin(), x2.end(), inserter(temp, temp.begin()));
//			}
//			else if (op[0] == 'I') {
//				set_intersection(x1.begin(), x1.end(), x2.begin(), x2.end(), inserter(temp, temp.begin()));
//			}
//			else if (op[0] == 'A') {
//				temp = x2;
//				temp.insert(getID(x1));
//			}
//			s.push(getID(temp));
//		}
//		cout << setCache[s.top()].size() << endl;
//	}
//	cout << "***" << endl;
//	system("pause");
//}


//0-99加减法
//#include <iostream>
//#include <string>
//using namespace std;
//
//int main() {
//	int sum = 0;
//	string line;
//	getline(cin, line);
//	int len = line.length();
//	if (len == 0) {
//		return 0;
//	}
//	//cout << len << endl;
//	for (int i = 0; i < len; i++) {
//		/*if (line[i] == '=') {
//			cout << sum;
//			return 0;
//		}*/
//		if (line[0] == '+' || line[0] == '-') {
//			return 0;
//		}
//		if (line[i] != '+' &&line[i] != '-') {
//			//cout << "1" << endl;
//			int n;
//			if (i < (len - 1) && line[i + 1]<='9'&&line[i + 1]>='0') {
//				//cout << "2" << endl;
//				n = (line[i] - '0') * 10 + line[i + 1] - '0';
//				cout << "n: " << n << endl;
//				i++;
//			}
//			else {
//				
//				n = line[i] - '0';
//				//cout << "n: " << n << endl;
//			}
//			sum = sum + n;
//		}
//		else if (line[i] == '+') {
//			//string s2;
//			int n;
//			i = i + 1;//
//			//int temp1 = line[i];
//			if (i < (len - 1) && line[i + 1]<='9'&&line[i + 1]>='0') {
//				n = (line[i] - '0') * 10 + line[i + 1] - '0';
//				i++;
//			}
//			else {
//				n = line[i] - '0';
//			}
//			sum = sum + n;
//		}
//		else if (line[i] == '-') {
//			//string s2;
//			int n;
//			i = i + 1;//
//					  //int temp1 = line[i];
//			if (i < (len - 1) && line[i + 1]<='9'&&line[i + 1]>='0') {
//				n = (line[i] - '0') * 10 + line[i + 1] - '0';
//				i++;
//			}
//			else {
//				n = line[i] - '0';
//			}
//			sum = sum - n;
//		}
//	}
//	cout << sum;
//	system("pause");
//}

//寻找蛇形字符串
//#include<iostream>
//#include<string>
//#include<set>
//#include<iterator>
//#include<map>
//using namespace std;
//string s;
//string s2;
//set<char> ans;
//string ans2;
//map<char, int> m;
//int main() {
//	getline(cin, s);
//	int len = s.length();
//	for (int i = 0; i < len; i++) {
//		if (isalpha(s[i])) {
//			s2.push_back(s[i]);
//		}
//	}
//	int len2 = s2.length();
//	for (int i = 0; i < len2; i++) {
//		char temp = s2[i];
//		for (int j = i; j < len2; j++) {
//			if ((s2[j] - temp) == 32 || (temp - s2[j]) == 32) {
//				ans2.push_back(temp);
//				s2[i] = ' ';
//				s2[j] = ' ';
//				ans.insert(tolower(temp));//只用存一个 到时候输出输出一对
//				char temp2;
//				temp2 = temp < s2[j] ? temp : s2[j];
//				if (!m.count(temp2)) {
//					m[temp2] = 0;
//				}
//				m[temp2]++;
//			}
//		}
//	}
//
//	set<char>::iterator it;
//	string s3;
//	for (it = ans.begin(); it != ans.end(); it++) {
//		s3.push_back(*it);
//		//cout << *it;
//	}
//	int len3 = s3.size();
//	int longest = 0;
//	int cnt = 1;
//	//cout << len3 << endl;
//	
//	for (int i = 0; i < len3; i++) {
//		if (i<(len3 -1) && s3[i] - s3[i + 1] == -1) {
//			//cout << toupper(s3[i]) << tolower(s3[i]);
//			cout << s3[i];
//			m[s3[i]]--;
//		}
//		else {
//			cout << s3[i];
//			m[s3[i]]--;
//			cout << endl;
//			
//			break;
//		}
//	}
//	
//	//cout << 'a' - 'A' << endl;//32
//	system("pause");
//}

////团体队列
//#include <iostream>
//#include <queue>
//#include <map>
//#include <string>
//using namespace std;
//const int maxn = 1000;
//int main() {
//	int tn;
//	while (cin >> tn) {
//		if (tn == 0) {
//			break;
//		}
//		map<int, int> team;
//		for (int i = 0; i < tn; i++) {
//			//cout << "i：" << i << endl;
//			int n1;
//			cin >> n1;
//			int num;
//			for (int j = 0; j < n1; j++) {
//				cin >> num;
//				team[num] = i;
//				//cout << "j：" << j << endl;
//			}
//		}
//		queue<int> q, q2[maxn];//队列要放到while前面 注意作用域！
//		while (true) {
//			string op;
//			cin >> op;
//			if (op[0] == 'S') {
//				break;
//			}
//			else if (op[0] == 'E') {
//				int x;
//				cin >> x;
//				int t = team[x];
//				//cout <<"q2.size:"<<q2[t].size()<< "empty: " << q2[t].empty() << endl;
//				if (q2[t].empty()) {
//					q2[t].push(x);
//					q.push(t);
//					//cout << "team: " << t << " " << q2[t].front() <<"q: "<<q.front() << endl;
//				}
//				else {
//					//cout << "hhh" << endl;
//					q2[t].push(x);
//				}
//			}
//			else if (op[0] == 'D') {
//				int temp_t, temp_m;
//				temp_t = q.front();
//				temp_m = q2[temp_t].front();
//				cout << temp_m << endl;
//				q2[temp_t].pop();
//				if (q2[temp_t].empty()) {
//					q.pop();
//				}
//			}
//		}
//
//	}
//
//}


////丑数（优先队列） 
//#include <iostream>
//#include <queue>
//#include <set>
//using namespace std;
//typedef long long LL;
//const int t[3] = { 2,3,5 };
//int main() {
//	priority_queue<LL, vector<LL>, greater<LL>> pq;//priority_queue< int , vector<int> , greater<int> > que;  priority_queue里的数据类型是int，它是用vector<int>作为底层容器实现，并且用系统提供的greater函数作为比较标准
//	set<LL> s;
//	pq.push(1);
//	s.insert(1);
//	//int cnt = 1;
//	//法一 标答方法
//	//for (int i = 1;; i++) {//i用于计数 一开始就等于1  因为1在优先队列里了 
//	//	LL temp = pq.top();//注意所有用到的int包括中间结果 都要用long long
//	//	pq.pop();//取完值就删掉
//	//	if (i == 1500) {//因为每个循环都必须经过取top() 相当于取了多少次top就有几个数
//	//		cout << temp << endl;
//	//		break;
//	//	}
//	//	for (int j = 0; j < 3; j++) {
//	//		LL n = temp * t[j];//注意所有用到的int包括中间结果 都要用long long
//	//		if (!s.count(n)) {
//	//			cout << n << endl;
//	//			pq.push(n);
//	//			s.insert(n);
//	//			//cnt++;
//	//		}
//	//	}
//	//}
//
//	//法二
//	int cnt = 1;
//	while (1) {
//		LL temp = pq.top();
//		pq.pop();
//		if (cnt == 1500) {
//			cout << temp << endl;
//		}
//		cnt++;//放在判断条件后面 因为初始化为1 弹出一个数字加1 直到弹到第1500个数字
//		for (int i = 0; i < 3; i++) {
//			LL x = temp * t[i];
//			if (!s.count(x)) {
//				pq.push(x);
//				s.insert(x);
//			}
//		}
//	}
//	system("pause");
//}

////随机数的生成 assert
//#include <vector>
//#include <algorithm>
//#include <assert.h>
//#include <iostream>
//using namespace std;
//void fill_random_int(vector<int>& v, int cnt) {//参数为引用  避免不必要的值被复制
//	v.clear();
//	for (int i = 0; i < cnt; i++) {
//		v.push_back(rand());
//	}
//}
//void test_sort(vector<int>& v) {
//	sort(v.begin(), v.end());
//	for (int i = 0; i < v.size()- 1; i++) {
//		assert(v[i] <= v[i + 1]);
//	}
//}
//int main() {
//	vector<int> v;
//	fill_random_int(v, 10);
//	test_sort(v);
//	cout << "hhh";
//	system("pause");
//	return 0;
//}

////取一个数的各个位的值 记住
//#include <iostream>
//#include <vector>
//using namespace std;
//static const int BASE = 10;
//int main() {
//	int n;
//	vector<int> v;
//	cin >> n;
//	do {
//		v.push_back(n % BASE);
//		//cout << n % BASE << endl;
//		n = n / BASE;
//	} while (n > 0);
//	//cout << v.size();
//	for (int i = v.size()-1; i >= 0; i--) {
//		//cout << "1";
//		cout << v[i];
//	}
//	system("pause");
//}

//5-8 记住如何计算行和列
//#include <iostream>
//#include <string>
//#include <vector>
//#include <algorithm>
//using namespace std;
//const int len = 60;
//
//
//void stadard_print(string s, int len, char c) {
//	for (int i = 0; i < len; i++) {
//		if (i < s.length()) {
//			cout << s[i];
//		}
//		else {
//			cout << c;
//		}
//	}
//}
//int main() {
//	int n;
//	while (cin >> n) {
//		vector<string> v;
//		int maxv = 0;//这里是局部变量 如果作为全局变量 当之前一轮中有很大的 后面就不变了
//		for (int i = 0; i < n; i++) {
//			//cout << "hhh" << endl;
//			string s;
//			cin >> s;
//			v.push_back(s);
//
//			maxv = max(maxv, (int)v[i].size());//注意要加（int）
//		}
//		cout << "maxv: " << maxv << endl;
//		sort(v.begin(), v.end());
//		int col = (len - maxv) / (maxv + 2) + 1; //(len - maxv)因为最后一列不需要+2  所以要减去 之后再加最后一列
//		int row = n / col + 1;//存疑  答案是 （n - 1） / col + 1
//		for (int i = 0; i < len; i++) {
//			cout << '-';
//		}
//		cout << endl;
//		for (int r = 0; r < row; r++) {
//			for (int c = 0; c < col; c++) {
//				int  index = c * row + r;
//				if (index < v.size()) {//这里要加判断条件 否则数组越界了
//					stadard_print(v[index], c == (col - 1) ? maxv : (maxv + 2), ' ');
//				}
//			}
//			cout << endl;
//		}
//	}
//
//
//	system("pause");
//}

////5-9
////map：
////
////优点：
////
////有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
////红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
////缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红 / 黑性质，使得每一个节点都占用大量的空间
////
////适用处：对于那些有顺序要求的问题，用map会更高效一些
////
////unordered_map：
////
////优点： 因为内部实现了哈希表，因此其查找速度非常的快
////缺点： 哈希表的建立比较耗费时间
////适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
//
//#include<iostream>
//#include<map>
//#include<string>
//#include<unordered_map>
//using namespace std;
//int main() {
//	int n, m;
//	while (cin >> n >> m) {
//		string nonsense;
//		getline(cin, nonsense);//输入n和m的时候敲了回车 相当于第一次执行下面的getline 得到的字符串是回车 所以先用一个符号存无用的回车
//
//		//cout << "n: " << n << " m: " << m << endl;
//		//第1列中1、2行字符串相同，在unordered_map<string,vector<int>>存储形式为{"Michael",{1,2}}。
//		//共有m列，所以可以定义vector<unordered_map<string, vector<int>>>columns(m)来存储每一列的信息。
//		//vector<int> ilist4(7) 默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。
//		vector<unordered_map<string, vector<int>>> columns(m);
//		for (int i = 0; i < n; i++) {
//			string line;
//			string temp = "";
//			//system("pause");
//			getline(cin, line);//这里执行第一次的时候line存的是回车；
//			//cout << line << endl;
//			//cout << "temp.size(): " << temp.size() << endl;
//
//			for (int j = 0, k = 0; j <= line.size(); j++) {//j用于遍历line，k表示列号 j <= line.size()要取等 因为下面判断分割的时候取等了 否则少最后一列
//				if (j == line.size() || line[j] == ',') {
//					columns[k++][temp].push_back(i);//表示第k列的temp字符串对应的行号，行号键值对应的value
//					//cout << "temp: " << temp << endl;
//					temp = "";
//				}
//				else {
//					temp += line[j];
//				}
//				//cout <<"len: "<< line.size() << "j: " << j << endl;
//			}
//			//cout << "i: " << i << endl;
//			//cout << "n: " << i << endl;
//		}
//		/*for (int i = 0; i < columns.size(); i++) {
//			cout << columns[i] << endl;
//		}*/
//		//cout << "hhh" << endl;
//		/*接着定义一个map<pair<int, int>, int>rows，具体使用方法是：
//		遍历整个columns，针对第一组输入数据，遍历到columns[1]时，columns[1]中含有元素{ "Michael",{ 1,2 } }，
//		以columns[1]的值{ 1,2 }作键，以列号1作值，将{ { 1,2 },1（这里的1指的是列号） }放入rows中。
//		接着遍历到columns[2]时，columns[2]含有元素{ "michael@neerc.ifmo.ru",{ 1,2 } }，而rows中已经有{ 1,2 }这个键了，
//		我们便找到了满足要求的r1，r2，c1，c2，即1, 2, 1, 2（这里的行号列号均由0开始，输出时都要加1）
//		*/
//		map<pair<int, int>, int> rows;
//		bool flag = false;
//		for (int i = 0; i < columns.size(); i++) {//遍历每一列
//			/*for循环中的每个迭代初始化一个新的引用
//			 for (auto &c : s)
//			 c = toupper(c);
//			 等价于：
//			 for (auto it = s.begin(); it != s.end(); ++it)
//			 {
//			 auto &c = *it;
//			 c = toupper(c);
//			 }
//			*/
//			//cout << "i： " << i << endl;
//			for (auto &j : columns[i]) {//遍历每列中的各个元素 是unorder_map对象,i指列号
//				//cout << "size: " << j.second.size() << endl;
//				if (j.second.size() > 1) {//一列当中字符串至少出现了两次
//
//					for (int k1 = 0; k1 < j.second.size(); k1++) {
//						for (int k2 = k1 + 1; k2 < j.second.size(); k2++) {
//							//cout << "k1: " << k1 << " k2: " << k2 << endl;
//							pair<int, int> p = make_pair(j.second[k1], j.second[k2]);
//							//用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器
//							if (rows.find(p) != rows.end()) {
//								cout << "NO" << endl;
//								cout << p.first + 1 << " " << p.second + 1 << endl;//一列里面的行坐标
//								cout << rows[p] + 1 << " " << i + 1 << endl;// rows[p] + 1是已经存在的一对行号对应的列号  i+1是和存在的匹配的第二个列号
//								flag = true;
//								break;
//							}
//							else {
//								rows.insert({ p, i });//p指行号，i指列号
//							}
//						}
//					}
//				}
//				
//			}
//		}
//		if (!flag) {
//			cout << "YES" << endl;
//			flag = false;
//		}
//	}
//	system("pause");
//}

//#include<iostream>
//#include<map>
//#include<string>
//#include<unordered_map>
//using namespace std;
//int main() {
//	int n, m;
//	while (cin >> n >> m) {
//		string nonsense;
//		getline(cin, nonsense);
//
//		vector<unordered_map<string, vector<int>>> cols(m);
//		for (int i = 0; i < n; i++) {
//			string line;
//			string temp = "";
//			getline(cin, line);
//			int k = 0;//k放外面 累加功能
//			for (int j = 0; j <= line.size(); j++) {
//				if (j == line.size() || line[j] == ',') {
//					cols[k][temp].push_back(i);
//					k++;
//					//cout << "temp: " << temp << endl;
//					temp = "";
//				}
//				else {
//					temp.push_back(line[j]);
//				}
//			}
//		}
//		bool flag = false;
//
//		map<pair<int, int>, int> rows;
//		//cout << "col" << cols.size() << endl;
//		for (int i = 0; i < cols.size(); i++) {
//			//cout << "i: " << i << endl;
//			for (auto &j : cols[i]) {
//				//cout << "j.second.size(): " << j.second.size() << endl;
//				if (j.second.size() > 1) {
//					//cout << "i: " << i << endl;
//					for (int k1 = 0; k1 < j.second.size(); k1++) {
//						for (int k2 = k1 + 1; k2 < j.second.size(); k2++) {
//							pair<int, int> p;
//							p = make_pair(j.second[k1], j.second[k2]);
//							if (rows.find(p) != rows.end()) {
//								cout << "NO" << endl;
//								cout << p.first + 1 << " " << p.second + 1 << endl;
//								cout << rows[p] + 1 << " " << i + 1 << endl;
//								flag = true;
//								break;
//							}
//							else {
//								//rows.insert({ p,i });
//								rows[p] = i;
//								//cout << "insert i: " << i << endl;
//							}
//						}
//					}
//				}
//			}
//		}
//		if (!flag) {
//			cout << "YES" << endl;
//		}
//	}
//	system("pause");
//}

//6-2
//#include<iostream>
//#include<stack>
//using namespace std;
//const int maxn = 100;
//int main() {
//	int n;
//
//	while (cin >> n) {
//		int tar[maxn];
//		memset(tar, 0, sizeof(tar));
//		int flag = 1;
//		for (int i = 1; i <= n; i++) {
//			int temp;
//			cin >> temp;
//			tar[i] = temp;
//			//cout << temp << endl;
//		}
//
//		/*for (int i = 1; i <= n; i++) {
//			cout << tar[i] << " ";
//		}*/
//
//		stack<int> s;
//		int a = 1, b = 1;
//		while (b <= n) {
//			//cout << "a:" << a << " b: " << b << endl;
//			if (a == tar[b]) {
//				//cout << "a->b" << endl;
//				a++;
//				b++;
//			}
//			else if ((!s.empty()) && (s.top() == tar[b])) {
//				//cout << "c->b" << endl;
//				b++;
//				s.pop();
//			}
//			else if (a <= n) {
//				//cout << "a->c" << endl;
//				s.push(a);//先把a放进去了再自加
//				a++;
//				//cout << "top: " << s.top() << endl;
//			}
//			else {
//				flag = 0;
//				break;
//			}
//			//cout << "hhh" << endl;
//		}
//		if (flag) {
//			cout << "YES";
//		}
//		else {
//			cout << "NO";
//		}
//	}
//	system("pause");
//}

////栈对于表达式求值有着特殊的作用。
////遇到字母时入栈，遇到右括号时出栈并计算，然后结果入栈。
////因为输入保证合法，括号无须入栈。
//#include<iostream>
//#include<stack>
//#include<string>
//using namespace std;
//struct Matrix {
//	int a, b;
//	Matrix(int a = 0, int b = 0) :a(a), b(b) {}
//}m[26];
//stack<Matrix> s;
//int main() {
//	int n;
//	cin >> n;
//
//	for (int i = 0; i < n; i++) {
//		char c;
//		cin >> c;
//		int k = 'A' - c;
//		cin >> m[k].a >> m[k].b;
//	}
//
//	string op;
//
//	while (cin >> op) {
//		int tot = 0;
//		int len = op.length();
//		bool flag = true;
//		for (int i = 0; i < len; i++) {
//
//			if (isalpha(op[i])) {
//				int k = 'A' - op[i];
//				s.push(m[k]);
//			}
//			if (op[i] == ')') {
//				int a, b, c, d;
//				a = s.top().a;
//				b = s.top().b;
//				s.pop();
//				c = s.top().a;
//				d = s.top().b;
//				if (a != d) {
//					cout << "error" << endl;
//					flag = false;
//					break;
//				}
//				else {
//					int temp = (a * b)*c;
//					tot = tot + temp;
//					s.pop();
//					s.push(Matrix(c, b));
//				}
//			}
//		}
//		if (flag) {
//			cout << tot << endl;
//		}
//	}
//	system("pause");
//}

//#include <iostream>
//using namespace std;
//
//const int maxn = 1000;
//int last, current;//其中next[i]是s[i]连的下一个字符的编号
//int nxt[maxn];
//int main() {
//	char c[maxn];
//	char ch;
//	int len = 0;
//	while (cin >> ch) {
//		len++;
//		c[len] = ch;
//
//		nxt[0] = 0;
//		last = 0;
//		current = 0;
//		//cout << "len: " << len << endl;
//		for (int i = 1; i <= len; i++) {
//			cout << "c[i]: " << c[i] << endl;
//			if (c[i] == '[') {
//				current = 0;
//			}
//			else if (c[i] == ']') {
//				current = last;
//			}
//			else {
//				nxt[i] = nxt[current];
//				nxt[current] = i;
//				if (last == current) {
//					last = i;
//				}
//				current = i;
//			}
//		}
//
//		//for (int i = nxt[0]; nxt[i] != 0; i = nxt[i]) {
//		//	cout << "next[i]: " << nxt[i] << endl;
//
//		//	//cout << c[nxt[i]];
//		//}
//		//如果next[i]=0，说明不知道这个节点连哪个下一个节点，如果全部插入完节点，遇到next[i]=0，就意味着这个链表已经结束 
//		for (int i = nxt[0]; i != 0; i = nxt[i]) {
//			//cout << "next[i]: " << nxt[i] << endl;
//
//			cout << c[i];
//		}
//		cout << endl;
//	}
//	system("pause");
//
//}

////二叉树，不难发现，对于一个结点k，其左子结点、右子结点的编号分别是2k和2k + 1。
////给定一棵包含2d个结点（其中d为树的高度）的完全二叉树，如果把结点从上到下从左到右编号为1, 2, 3……，则结点k的左右子结点编号分别为2k和2k + 1。
////当I是奇数时，它是往左走的第(I+1)/2个小球；当I是偶数时，她是往右走的第I/2个小球。这样，可以直接模拟最后一个小球的路线：
//#include<iostream>
//using namespace std;
//int main() {
//	int D, I;
//	while (cin >> D >> I) {
//		int k = 1;
//		for (int i = 1; i < D;i++) {//只用走d-1次
//			if (I % 2 == 0) {//偶数往右走
//				I = I / 2;
//				k = 2 * k + 1;
//			}
//			else {
//				I = I / 2 + 1;
//				k = k * 2;
//			}
//		}
//		cout << k << endl;
//	}
//	system("pause");
//}
//
////递归定义：二叉树是n(n>=0)个有限结点构成的集合。N=0称为空二叉树；n>0的二叉树由一个根结点和两互不相交的，分别称为左子树和右子树的二叉树构成。
////二叉树中任何结点的第1个子树称为其左子树，左子树的根称为该结点的左孩子；二叉树中任何结点的第2个子树称为其右子树，
//#include <iostream>
//#include <string>
//#include <sstream>
//#include <vector>
//#include <queue>
//using namespace std;
//struct Node
//{
//	int value;
//	int have_v;
//	Node *lch;
//	Node *rch;
//	Node() :have_v(0), lch(NULL), rch(NULL) {};
//};
//
//Node* root = new Node();
////Node* root;
//Node* newnode() {
//	return new Node();
//}
//void freenode(Node *u) {
//	if (u == NULL) {
//		return;
//	}
//	free(u->lch);
//	free(u->rch);
//	delete u;
//}
//bool addnode(int v, string op) {
//	int len = op.length();
//	//cout << "len: " << len << endl;
//
//	//root = new Node();
//	Node* u = root;
//	for (int i = 0; i < len; i++) {
//		//cout << "i: " << i << endl;
//		if (op[i] == 'L') {
//			//cout << "u->lch: " << u->lch << endl;
//			if (u->lch == NULL) {
//				//cout << "L" << endl;
//				u->lch = newnode();
//			}
//			u = u->lch;
//		}
//		if (op[i] == 'R') {
//			if (u->rch == NULL) {
//				u->rch = newnode();
//			}
//			u = u->rch;
//		}
//	}
//	if (!u->have_v) {
//		u->have_v = 1;
//		u->value = v;
//		//cout << "u->value: " << u->value << "u->have_v: " << u->have_v<<endl;
//	}
//	else {
//		return false;
//	}
//	//system("pause");
//	return true;
//}
//void readtree() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	//cout << "1" << endl;
//	string op;
//	while (ss >> op) {
//		//cout << op << endl;
//		//system("pause");
//		if (op == "()") {
//			break;
//		}
//		else {
//
//			int k = 1;
//			int v = 0;
//			while (isalnum(op[k])) {
//				//cout << "op[k]: " << op[k] << endl;
//				v = v * 10 + op[k] - '0';
//				k++;
//				/*cout << "v: " << v << endl;
//				system("pause");*/
//			}
//			//cout << "k: " << op[k] << endl;
//
//			//k = 1;
//			/*while (op[k] != ',') {
//				cout << "k: " << op[k] << endl;
//				k++;
//				system("pause");
//			}*/
//			/*cout << "k +1 : " << k+1 << " op.length() - k - 1: " << op.length() - k - 1 << endl;
//			system("pause");*/
//			string op2 = op.substr(k + 1, op.length() - k - 1);
//			//cout << "op2: " << op2 << endl;
//			//system("pause");
//			addnode(v, op2);
//		}
//	}
//	//system("pause");
//}
//
//bool bfs(vector<int> &ans) {
//	//cout << "root->value: " << root->value <<" root->have_v: "<< root->have_v << endl;
//	queue<Node *> q;
//	q.push(root);
//	while (!q.empty()) {
//		//cout << "1" << endl;
//		Node *u = q.front();
//		q.pop();
//		if (!u->have_v) {
//			//cout << "false" << endl;
//			return false;
//		}
//		ans.push_back(u->value);
//
//		if (u->lch) {
//			//cout << "q.push(u->lch)" << endl;
//			q.push(u->lch);
//		}
//		if (u->rch) {
//			//cout << "q.push(u->rch)" << endl;
//			q.push(u->rch);
//		}
//
//	}
//	return true;
//	system("pause");
//}
//int main() {
//	while (true) {
//		//freenode(root);//加了会报错
//		cout << "hhh" << endl;
//
//		readtree();
//		vector<int> ans;
//		ans.clear();
//		if (bfs(ans)) {
//			for (int i = 0; i < ans.size(); i++) {
//				cout << ans[i] << " ";
//			}
//		}
//		else {
//			cout << "-1" << endl;
//		}
//	}
//
//	system("pause");
//	return 0;
//}

////abbortt的复仇
//#include<cstdio>
//#include<cstring>
//#include<vector>
//#include<queue>
//#include<iostream>
//#include <string>
//using namespace std;
//
//struct Node {
//	int r, c, dir; // 位于(r,c)朝向dir(0~3表示四个方向N, E, S, W)
//	Node(int r = 0, int c = 0, int dir = 0) :r(r), c(c), dir(dir) {}
//};
//
//const int maxn = 10;
//const char* dirs = "NESW"; // 顺时针旋转。 
//const char* turns = "FLR";//“三种转弯方式”。 
//
//int has_edge[maxn][maxn][4][3];// 表示当前状态（r，c，dir），是否可以沿着转弯方向[trun]行走。 
//int d[maxn][maxn][4];          //表示初始状态到（r，c，dir）的最短路长度。 
//Node p[maxn][maxn][4];          //同时用p[r][c][dir]保存了状态(r, c, dir)在BFS树中的父结点。 
//int r0, c0, dir, r1, c1, r2, c2;
//
////把四个方向和3种“转弯方式”编号0~3和0~2. 
//int dir_id(char c) { return strchr(dirs, c) - dirs; }
//int turn_id(char c) { return strchr(turns, c) - turns; }
////用于转弯。 
//const int dr[] = { -1, 0, 1, 0 };//顺序是N E S W
//const int dc[] = { 0, 1, 0, -1 };
//
//Node walk(const Node& u, int turn) {
//	int dir = u.dir;                    //直行， 方向不变 
//	if (turn == 1) dir = (dir + 3) % 4; // 逆时针 ，转向 因为原来的dirs数组是按照顺时针排列的
//	if (turn == 2) dir = (dir + 1) % 4; // 顺时针 ，转向 
//	return Node(u.r + dr[dir], u.c + dc[dir], dir);//下一步可能的状态 
//}
//
////判断是否出界 
//bool inside(int r, int c) {
//	return r >= 1 && r <= 9 && c >= 1 && c <= 9;
//}
//
////读取r0，c0，dir，并计算出r1，c1， 然后读入has_edge数组。 
//bool read_case() {
//	char s[99], s2[99];
//	//if (scanf_s("%s%d%d%s%d%d", s, &r0, &c0, s2, &r2, &c2) != 6) return false;
//	cin >> s >> r0 >> c0 >> s2 >> r2 >> c2;//s表示这个案例的名字
//	printf("%s\n", s);
//
//	//system("pause");
//	dir = dir_id(s2[0]);//得到s2在dirs中的下标
//	r1 = r0 + dr[dir];//按照下标的方向走一步
//	c1 = c0 + dc[dir];
//
//	memset(has_edge, 0, sizeof(has_edge));
//	for (;;) {
//		int r, c;
//		//scanf_s("%d", &r);
//		cin >> r;
//		if (r == 0) break;
//		//scanf_s("%d", &c);
//		cin >> c;
//		//cout << "r: " << r << " c: " << c << endl;
//		//system("pause");
//		string str;
//		while (cin >> str) {
//			if (str[0] == '*') {
//				//cout << "read *" << endl;
//				break;
//			}
//			for (int i = 1; i < str.size(); i++) {
//				//cout <<"  dir_id(str[0]): " << dir_id(str[0]) << "  turn_id(str[i]): " << turn_id(str[i]) << endl;
//				has_edge[r][c][dir_id(str[0])][turn_id(str[i])] = 1;//取字符串的第一个字符为方向  后面遍历得转向
//				//cout << "hhh" << endl;
//			}
//		}
//		//cout << "str: " << str << endl;
//		//system("pause");
//	}
//	return true;
//}
//
//void print_ans(Node u) {
//	// 从目标结点逆序追溯到初始结点。 
//	vector<Node> nodes;
//	for (;;) {
//		nodes.push_back(u);
//		if (d[u.r][u.c][u.dir] == 0) break;
//		u = p[u.r][u.c][u.dir];//往回追溯
//	}
//	nodes.push_back(Node(r0, c0, dir));
//
//	//打印解， 每行 10 个。 
//	int cnt = 0;
//	for (int i = nodes.size() - 1; i >= 0; i--) {
//		if (cnt % 10 == 0) printf(" ");
//		printf(" (%d,%d)", nodes[i].r, nodes[i].c);
//		if (++cnt % 10 == 0) printf("\n");
//	}
//	if (nodes.size() % 10 != 0) printf("\n");
//}
//
////BFS主过程。 
//void solve() {
//	queue<Node> q;
//	memset(d, -1, sizeof(d)); //d表示初始状态到（r，c，dir）的最短路长度。
//	Node u(r1, c1, dir);//r1,c1,dir是r0,c0朝着dir方向走一步的坐标  新建一个NODE并初始化
//	d[u.r][u.c][u.dir] = 0;
//	q.push(u);
//	while (!q.empty()) {
//		Node u = q.front(); q.pop();
//		if (u.r == r2 && u.c == c2) { print_ans(u); return; }//到达目的地 
//		for (int i = 0; i < 3; i++) {//所有可能的转向，（直行，逆时针转， 顺时针转） 
//			Node v = walk(u, i);      //下一步的状态 
//			//从这一步是否可以达到下一步，下一步是否出界， 下一步是否被走过（同方向）。 
//			if (has_edge[u.r][u.c][u.dir][i] && inside(v.r, v.c) && d[v.r][v.c][v.dir] < 0) {
//				d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + 1;//最短长度加 1. 
//				p[v.r][v.c][v.dir] = u;//记录父结点。 
//				q.push(v);
//			}
//		}
//	}
//	printf("  No Solution Possible\n");//走了所有可以走的可能， 无法到达终点。 
//}
//
//int main() {
//	while (read_case()) {
//		solve();
//	}
//	return 0;
//}

//#include<stdio.h> 
//#include<stdlib.h> 
//#include<string> 
//#include<math.h> 
//#include<iostream>
//
//using namespace std;
//#define max 100+5 
//int c[max], topo[max], t, n, G[max][max];
////如G[1,2] 从1指向2的有向线段 
//int dfs(int u)
//{
//	int v;
//	c[u] = -1; //访问标志，-1为正在访问，0是未访问，1是已经访问
//	for (v = 1; v <= n; v++) //看的是与你比较的v 有无再次访问到 
//		if (G[u][v])
//		{
//			if (c[v] < 0) return 0; // 如果再次访问到一个在c中被标记为-1的结点就说明存在一个有向环
//			else if (!c[v] && !dfs(v)) return 0; //v没被访问过 用dfs递归 如果返回0表示失败 
//
//
//		}
//	c[u] = 1;
//	/*每次DFS在访问完一个结点后把它加到当前拓扑序首部，因为只能保证向后已经访问完，我们不知道开始DFS的
//	结点是否有父结点，所以如果前面还有结点肯定都比现在访问到的这些结点要小必须放在它们前面。*/
//	topo[t--] = u;
//	cout <<"t: "<<t+1 << " u: " << u << endl;
//	
//	return 1;
//}
//int toposort()
//{
//	int i;
//	t = n;//t表示节点个数
//	memset(c, 0, sizeof(c));
//	//-1的结点就说明存在一个有向环，0表示这个结点还未被访问，它的子孙有没有被访问不知道，因为有可能从它的子孙开始DFS，1表示这个结点以及它的子孙已经被访问过
//	for (i = 1; i <= n; i++)//遍历所有节点
//		if (!c[i]) {//如果该节点没有被访问
//			if (!dfs(i))//如果不存在拓扑结构
//			{
//				return 0;
//			}
//		}
//	return 1;
//}
//int main()
//{
//	int m, i;
//	while (cin >> n >> m, n || m)//n个数 m组操作
//	{
//		int u, v;
//		memset(G, 0, sizeof(G));
//		for (i = 0; i < m; i++)
//		{
//			cin >> u >> v;
//			G[u][v] = 1;
//		}
//		if (toposort())
//		{
//			for (i = 0; i < n - 1; i++)
//				printf("%d ", topo[i]);
//			printf("%d\n", topo[i]);
//		}
//	}
//	return 0;
//}

//#include<iostream>
//using namespace std;
//const int maxn = 100;
//int G[maxn][maxn];
//int c[maxn];//记录节点是否被走过
//int n, m;
//int ans[maxn];
//int cnt;
//bool dfs(int u) {
//	c[u] = -1;
//	for (int v = 1; v <= n; v++) {//节点编号是1-n
//		if (G[u][v] == 1) {
//			if (c[v] == -1) {
//				return 0;
//			}
//			else if (c[v] == 0) {
//				if (!dfs(v)) {
//					return 0;
//				}
//			}
//		}
//
//	}
//	c[u] = 1;
//	ans[--cnt] = u;
//	cout << "cnt: " << cnt << " u: " << u << endl;
//	return 1;
//}
//bool topo() {
//	memset(c, 0, sizeof(c));
//	cout << "hhh" << endl;
//	for (int i = 1; i <= n; i++) {
//		cout << "c[i]: " << c[i] << endl;
//		if (!c[i]) {
//			if (!dfs(i)) {
//				return 0;
//			}
//		}
//	}
//	return 1;
//}
//int main() {
//
//	while (cin >> n >> m) {
//		if (n == 0 && m == 0) {
//			break;
//		}
//		cnt = n;
//		int u, v;
//		memset(G, 0, sizeof(G));
//		for (int i = 0; i < m; i++) {
//			cin >> u >> v;
//			G[u][v] = 1;
//		}
//
//		if (topo()) {
//			for (int i = 0; i < n ; i++) {
//				cout << ans[i] << " ";
//				//system("pause");
//			}
//		}
//	}
//}


////G is the graph; vis tells us whether a path has been visited; n is the number of nodes
//void eulerPath(int u) {
//	for (int v = 0; v < n; v++) {
//		if (G[u][v] && vis[u][v] == 0) {
//			vis[u][v] = 1;
//			//Since this is a undirected graph, severe the connection at both directions
//			vis[u][v] = vis[v][u];
//			eulerPath(v);
//			System.out.println(u + " " + v + "\n");
//		}
//	}
//}

//#include <iostream>
//#include <string.h>
//#include <stdio.h>
//#define MM(x) memset(x,0,sizeof(x))
//using namespace std;
//const int maxn = 26;
//int cotIn[maxn], cotOut[maxn], visit[maxn], G[maxn][maxn];
//void init() {//初始化
//	MM(cotIn); MM(cotOut); MM(visit); MM(G);
//}
//void dfs(int u) {//深搜
//	visit[u] = 1;
//	for (int v = 0; v < maxn; v++) {
//		if (G[u][v] && !visit[v]) dfs(v);
//	}
//}
////思路：判断有向图是否为欧拉回路：
////
////前提条件：
////
////（1）最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。
////
////（2）在忽略边的方向后，图必须是连通的。（dfs判断即可）
//bool judge() {//判断是否为欧拉回路
//	int recIn = 0, recOut = 0, flag = 1;
//	//条件1
//	for (int i = 0; i < maxn; i++) {//遍历26个字母
//		if (cotIn[i] == cotOut[i]) continue;//出度与入度相等不用管
//		if (cotIn[i] - cotOut[i] == 1) recIn++;//出度比入度大1记录个数
//		else if (cotIn[i] - cotOut[i] == -1) recOut++;//出度比入度小1记录个数
//		else { flag = 0; break; }//其他情况直接不符合跳出
//	}
//	//条件2
//	if (recIn <= 1 && recOut <= 1 && flag) {//满足有向图的欧拉前提条件
//		for (int i = 0; i < maxn; i++)if (cotIn[i]) { dfs(i); break; }//找一个起始点开始深搜判断通路
//		for (int i = 0; i < maxn; i++) if ((cotIn[i] || cotOut[i]) && !visit[i]) return false;//判断如果此点存在但没有访问即不构成欧拉回路
//		return true;//上面所有情况都通过即为欧拉回路
//	}
//	return false;
//}
//int main()
//{
//	int n, t;
//	char str[1005];
//	cin >> t;
//	while (t--) {
//		init();
//		cin >> n;
//		while (n--) {
//			cin>>str;
//			int len = strlen(str);
//			G[str[0] - 'a'][str[len - 1] - 'a'] = 1;//二维数组表示图
//			cotIn[str[0] - 'a']++;//记录此字母的入度数
//			cotOut[str[len - 1] - 'a']++;//记录此字母的出度数
//			cout << "cotIn[str[0] - 'a']: " << cotIn[str[0] - 'a'] << " cotOut[str[len - 1] - 'a']: " << cotOut[str[len - 1] - 'a'] << endl;
//		}
//		if (judge()) printf("Ordering is possible.\n");
//		else printf("The door cannot be opened.\n");
//		system("pause");
//	}
//	
//	return 0;               
//}
//
//


////7-1
//#include <iostream>
//using namespace std;
//const int maxn = 15;
//int v[maxn];
//int main() {
//	int n;
//	cin >> n;
//	memset(v, 0, sizeof(v));
//
//	//cout << "n: " << n << endl;
//	for (int i = 1234; i < 98765; i++) {
//		//cout << "i: " << i << endl;
//		int temp_i = i;
//		int temp_m = n * i;
//		long long m = n * i;
//		for (int k = 0; k < 5; k++) {
//			v[k] = temp_i % 10;
//			temp_i = temp_i / 10;
//			//cout << "v["<<k<<"]: " << v[k] << endl;
//		}
//		int flag = 1;
//		for (int k = 5; k < 11; k++) {
//			if (k == 10 && temp_m != 0) {
//				flag = 0;
//			}
//			else {
//				v[k] = temp_m % 10;
//				temp_m = temp_m / 10;
//			}
//			//cout << "v[" << k << "]: " << v[k] << endl;
//		}
//		int sum = 0;
//		int cj = 1;
//		int cnt0 = 0;
//		for (int j = 0; j < 10; j++) {
//			sum += v[j];
//			if (v[j] == 0) {
//				cj = cj;
//				cnt0++;
//			}
//			else {
//				cj *= v[j];
//			}
//
//		}
//		if (flag == 1 && cnt0 == 1 && sum == 45 && cj == 362880) {
//			cout << m << " / " << "0" << i << " = " << n << endl;
//		}
//		//system("pause");
//	}
//
//	system("pause");
//}


////生成0-1的全排列
//#include<iostream>
//using namespace std;
//const int maxn = 100;
//int A[maxn];
//int P[maxn];
//void permutation1_n(int n, int* A, int cur) {
//	if (cur == n) {//结束标志 这个时候A数组里面存的就是一组完整的排列值
//		for (int i = 0; i < n; i++) {
//			cout << A[i] << " ";
//		}
//		cout << endl;
//	}
//	//cout << "hhh" << endl;
//
//	for (int i = 1; i <= n; i++) {
//		int flag = 1;//每次找前cur元素有没有等于i的都要讲flag重新赋值
//		for (int j = 0; j < cur; j++) {
//			if (i == A[j]) {
//				flag = 0;
//			}
//		}
//		if (flag) {
//			A[cur] = i;
//			permutation1_n(n, A, cur + 1);
//		}
//	}
//}
//
//int main() {
//	memset(A, 0, sizeof(A));
//	int n;
//	cin >> n;
//	permutation1_n(n, A, 0);//生成1～n的排列
//	permutation(n, A, P, 0);
//	
//	system("pause");
//}


////生成可重集的排列
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int maxn = 100;
//void permutation(int n, int* A, int* P, int cur) {
//	//cout << "hhh" << endl;
//	if (cur == n) {
//		for (int i = 0; i < n; i++) {
//			cout << A[i];
//		}
//		cout << endl;
//	}
//
//	for (int i = 0; i < n; i++) {
//		int c1 = 0, c2 = 0;
//		for (int k = 0; k < cur; k++) {
//			if (A[k] == P[i]) {
//				c1++;
//			}
//		}
//		for (int k = 0; k < n; k++) {
//			if (P[k] == P[i]) {
//				c2++;
//			}
//		}
//		//cout << "i: " << i << " c1: " << c1 << " c2: " << c2 << endl;
//		//因为P是有序的 所以只需要判断前后两个值是否相同 例如：1 1就不用在递归了
//		if (c1 < c2 && P[i] != P[i-1]) {//这里只需要判断P[i]在之前出现的次数和总的次数的大小
//			A[cur] = P[i];
//			//cout << "A[" << cur << "] = " << P[i] << endl;
//			permutation(n, A, P, cur + 1);
//		}
//
//	}
//}
//int main() {
//	int A[maxn];//ans
//	int P[maxn];//输入数组P
//	memset(A, 0, sizeof(A));
//	int cnt = 0;
//	while (cin >> P[cnt]) {
//		cnt++;
//	}
//	cout << "cnt: " << cnt << endl;
//	sort(P, P + cnt);
//	permutation(cnt, A, P, 0);
//
//	system("pause");
//}

////枚举排列的常见方法有两种：一是递归枚举，二是用STL中的next_permutation。
////next_permutation（）在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。
//#include<cstdio>
//#include<iostream>
//#include<algorithm> //包含next_permutation
//using namespace std;
//int main() {
//	int n, p[10];
//	cin >> n;
//	for (int i = 0; i < n; i++) cin >> p[i];
//	sort(p, p + n); //排序，得到p的最小排列
//	do {
//		for (int i = 0; i < n; i++) printf("%d ", p[i]); //输出排列p
//		printf("\n");
//	} while (next_permutation(p, p + n)); //求下一个排列
//	system("pause");
//	return 0;
//}


////增量法 
//#include <iostream>
//using namespace std;
//int a[20];
///*递归输出n以内所有的子集,其中cur为当前下标,初始值0*/
//void print_subset(int n, int* a, int cur) {
//	for (int i = 0; i < cur; i++)//每次递归输出当前子集,靠它来最后输出上一层指定的子集
//		cout << a[i] << ' ';
//	cout << endl;//以行分隔
//
//	//找到当前子集首个值，因为按字典顺序输出，所以每次找到最小的元素，cur > 0，则minElem=a[cur-1]+1,否则为0
//	int minElem = cur ? a[cur - 1] + 1 : 0;//相当于下一层的第一个值
//	cout << "cur: " << cur << " a[cur - 1] + 1: " << minElem << " minElem: " << minElem << endl;
//	//从子集第一个值开始遍历,先不看下面的print_subset(n,a,cur+1)，单看这for循环，
//	//可知是将子集第一个值从头往后依次赋值为 minElem-n-1。
//	//每次第一个值变化后递归设置下一个值(相当于下一层的第一个值)
//	for (int i = minElem; i < n; i++) {
//		a[cur] = i;
//		cout << "cur: " << cur << " i: " << i << endl;
//		//当前层子集第一个值
//		//cur+1表示当前层值设置完毕，开始递归下一层，和前面步骤一样。
//		//到达最后一层结束后return 到上一层，然后i++,a[cur]的值(首元素)改变，又反复递归下一层...
//		print_subset(n, a, cur + 1);
//	}
//}
//
//int main() {
//	int n;
//	while (cin >> n, n) {
//		print_subset(n, a, 0);
//	}
//}
//


//#include<iostream>
//using namespace std;
//void print_subset(int n, int s) {
//	for (int i = 0; i < n; i++) {//对于传进来的s 遍历每一位取或不取
//		//cout << "1 << i: " << (1 << i) << endl;
//		if (s & (1 << i)) {//与运算“&”比较两个二进制数的每一位，如果都为1则在结果的同一位置返回1，否则返回0 
//			/*假设i的二进制是1011
//				1. j = 0 那么 1011 & 0001 = 0001>0 第0位被选择了 = >输出A[0]
//				2. j = 1 那么 1011 & 0010 = 0010>0 第1位被选择了 = >输出A[1]
//				3. j = 2 那么 1011 & 0100 = 0000 == 0 第2位没有选 = >不输出A[2]
//				4. j = 3 那么 1011 & 1000 = 1000>0 第3位被选择了 = >输出A[3]*/
//			cout << i << " ";
//		}
//	}
//	cout << endl;
//}
//int main() {
//	int n;
//	cin >> n;
//	cout << (1 << n) << endl;
//	for (int i = 0; i < (1 << n); i++) {
//		cout << "i: " << i << endl;
//		print_subset(n, i);
//	}
//	system("pause");
//}

////n皇后问题
//#include<iostream>
//using namespace std;
//const int maxn = 100;
//int tot = 0;
//int n;
//int ans[maxn];
//bool check(int pos) {
//	for (int i = 1; i < pos; i++) {
//		if (ans[pos] == ans[i] || abs(ans[pos] - ans[i]) == abs(pos - i)) {
//			//cout << pos << " is false." << endl;
//			//system("pause");
//			return false;
//		}
//	}
//	//cout << pos << " is true." << endl;
//	//system("pause");
//	return true;
//}
//void queen(int cur) {
//	if (cur > n) tot++;
//	else {
//		//cout << "n: " << n << endl;
//		//system("pause");
//		for (int i = 1; i <= n; i++) {
//			ans[cur] = i;
//			//cout << "cur: "<<cur<<" i: " << i << endl;
//			if (check(cur)) {
//				queen(cur + 1);
//			}
//		}
//	}
//}
//int main() {
//
//	cin >> n;
//	queen(1);
//	cout << "tot: " << tot << endl;
//	system("pause");
//}

//#include<iostream>
//#include<string>
//using namespace std;
//
//const int maxn = 20;
//int vis[maxn];
//int ans[maxn];
//int n;
////判断是不是素数
//bool is_prime(int m) {
//	for (int i = 2; i < sqrt(m) + 1; i++) {
//		if (m % i == 0) {
//			//cout << m << " is not."<<endl;
//			return false;
//		}
//	}
//	//cout << m << " is."<<endl;
//	return true;
//}
//void prime_ring(int cur) {
//	if (cur == n+1) {
//		
//		int temp = ans[cur] + ans[1];
//		if (is_prime(temp)) {
//			for (int i = 1; i <= n; i++) {
//				cout << ans[i] << " ";
//			}
//			cout << endl;
//		}
//	}
//	else {
//		for (int i = 2; i <= n; i++) {
//			ans[cur] = i;
//			
//			if (is_prime(i + ans[cur - 1]) && !vis[i]) {//要判断是否访问 再标记vis
//				vis[i] = 1;//这里标记的是i不是cur 因为具体的数字是i
//				prime_ring(cur + 1);
//				vis[i] = 0;
//			}
//			
//			
//		}
//	}
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	memset(ans, 0, sizeof(ans));
//	cin >> n;
//	ans[1] = 1;
//	prime_ring(2);
//	system("pause");
//}
//

////困难的串
//#include <iostream>
//using namespace std;
//const int maxn = 100;
//int ans[maxn];//从下标1 开始
//int n, L, cnt = 0;
//bool check(int pos) {
//	int flag = true;
//	//cout << " pos / 2: " << pos / 2 << endl;
//	for (int i = 1; i <= pos / 2; i++) {//如果pos-1是困难的串，现在判断pos是不是困难的串 只用判断加入pos后 从后面向前面遍历，是不是困难的串 满足多米诺性质
//		int equal = 1;
//		for (int j = 0; j < i; j++) {//注意是j++ 不是i++！！！！！
//			//cout << "pos: " << pos << " i: " << i << " j: " << j << " ans[pos - j]: " << ans[pos - j] << " ans[pos - j - i] : " << ans[pos - j - i] << endl;
//			if (ans[pos - j] != ans[pos - j - i]) {//只要前一半和后一半不一样 就标记为0
//				//cout << " not equal" << endl;
//				equal = 0;
//				break;
//			}
//		}
//		if (equal) {//如果没有标记为0 说明对于i来说事容易的串
//			flag = false;
//			break;
//		}
//	}
//	if (flag) {//如果flag为真 说明之前对于任意长度的i  都不是容易得串
//		//cout << pos << " is true." << endl;
//		return true;//困难的串
//	}
//	else {
//		//cout << pos << " is false." << endl;
//		return false;
//	}
//}
//void dfs(int cur) {
//	cnt++;
//	//cout << "cnt: " << cnt << " n: " << n << endl;
//	//system("pause");
//	if (cnt > n) {//为了保证遍历到n 所以cur要大于n时才退出  但此时cur=n+1 所以输出是要<cur
//		//而不是小于等于cur
//		for (int i = 1; i < cur; i++) {//结束条件是cur  cur相当于字符串的长度
//			cout << char('A' + ans[i] - 1) << " ";//ans下标是从1开始存的 所以要减一
//		}
//		cout << endl;
//		system("pause");
//		return;
//	}
//	else {
//		for (int i = 1; i <= L; i++) {
//			//cout << "i: " << i << endl;
//			ans[cur] = i;
//			if (check(cur)) {//是困难的串
//				//cout << "cur: " << cur << " i: " << i << endl;
//				dfs(cur + 1);
//			}
//			//cout << i << " not pass the check" << endl;
//		}
//	}
//}
//int main() {
//	cin >> n >> L;
//	//cout << "n: " << n << " L: " << L << endl;
//	dfs(1);
//}

////八数码问题  bfs+stl 效率低
////采用BFS比较合理，因为DFS深度搜索下限不好设定，BFS按层搜索，只要不到目标状态就一直进行
//#include <iostream>
//#include <set>
////#include <string>
//using namespace std;
//typedef int State[9];
//const int maxn = 1000000;
//State st[maxn];
//State goal;
//int dis[maxn] = { 0,0 };//因为front是从1开始算的，所以初始化两个0，才能初始化front = 1
//set<int> vis;
////定义方向 上下左右
//int dirx[4] = { 0,0,-1,1 };
//int diry[4] = { 1,-1,0,0 };
//void init_lookup_tabel() {
//	vis.clear();
//}
//bool try_to_insert(int pos) {//用stl跑效率极低 跑不出来
//	int value = 0;
//	for (int i = 0; i < 9; i++) {
//		value = value * 10 + st[pos][i];
//	}
//	if (vis.count(value)) {
//		return false;
//	}
//	else {
//		vis.insert(value);
//		return true;
//	}
//}
//int bfs() {
//	init_lookup_tabel();
//	int front = 1, rear = 2;
//	while (front < rear) {
//		State &s = st[front];
//		if (memcmp(goal, s, sizeof(s)) == 0) {// strcmp比较的字符串，而memcmp比较的是内存块，strcmp需要时刻检查是否遇到了字符串结束的 /0 字符，而memcmp则完全不用担心这个问题，所以memcmp的效率要高于strcmp
//			return front;
//		}
//		else {
//			int bl;//记录空白的位置 一维的位置
//			for (bl = 0; bl < 9;bl++) {
//				if (s[bl] == 0) {
//					break;
//				}
//			}
//			int x = bl / 3;//将一维坐标转化成二维
//			int y = bl % 3;
//			for (int i = 0; i < 4; i++) {
//				int newx = x + dirx[i];
//				int newy = y + diry[i];
//				int newz = newx * 3 + newy;
//				if (newx >= 0 && newx <= 2 && newy >= 0 && newy <= 2) {
//					State& temp = st[rear];//指向rear所在的新的表格
//					memcpy(&temp, &s, sizeof(s));//将front的内容 copy给rear
//					temp[newz] = s[bl];//交换位置
//					temp[bl] = s[newz];
//					dis[rear] = dis[front] + 1;
//					
//					if (try_to_insert(rear)) {//如果队尾指针指向不同的表 相当于在同一层扩展节点
//						cout <<rear<< " is insert sus!" << endl;
//						rear++;
//					}
//					/*for (int j = 0; j < 9; j++) {
//						if (j % 3 == 0) cout << endl;
//						cout << temp[j] << " ";
//					}
//					cout << endl;
//					system("pause");*/
//				}
//			}
//			front++;//朝着四个方向扩展节点完毕 修改队首指针
//		}
//	}
//	return -1;
//}
//int main() {
//	//memset(dis, 0, sizeof(dis));
//	for (int i = 0; i < 9; i++) {
//		cin >> st[1][i];
//	}
//	for (int i = 0; i < 9; i++) {
//		cin >> goal[i];
//	}
//	int ans = bfs();
//	cout << "hhh" << endl;
//	if (ans != -1) {
//		cout << dis[ans] << endl;
//	}
//	else cout << "-1" << endl;
//	system("pause");
//}


////八数码问题 bfs+hash 速度快 注意哈希函数不能任意选 这里巧妙运用了将9个数弄成9位数
//#include<iostream>
//using namespace std;
//typedef int State[9];
//const int maxn = 1000000;
//const int hashsize = 1000000;
//State st[maxn], goal;
//int dis[maxn] = { 0,0 };
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int head[hashsize], Next[maxn];
//void init_table() {
//	memset(head, 0, sizeof(head));
//}
//int Hash(State& s) {
//	int v = 0;
//	for (int i = 0; i < 9; i++) {
//		v = v * 10 + s[i];
//	}
//	return v % hashsize;
//}
//bool try_insert(int rear) {
//	int h = Hash(st[rear]);//得到和rear层的9位数 所在的链表 
//	int u = head[h];//取链表的头 若u=0说明没有该链表 直接插入
//	while (u) {
//		if (memcmp(st[u], st[rear], sizeof(st[rear])) == 0) {
//			return false;
//		}
//		u = Next[u];
//	}
//	Next[rear] = head[h];
//	head[h] = rear;
//	return true;
//
//}
//int bfs() {
//	init_table();
//	int front = 1;
//	int rear = 2;
//	while (front < rear)
//	{
//		State& s = st[front];//这里要使用引用
//		if (memcmp(s, goal, sizeof(s)) == 0) {
//			return front;
//		}
//		else {
//			int z;
//			for (z = 0; z < 9; z++) {
//				if (st[front][z] == 0) {
//					break;
//				}
//			}
//			int x = z / 3;
//			int y = z % 3;
//			for (int i = 0; i < 4; i++) {
//				int newx = x + dirx[i];
//				int newy = y + diry[i];
//				int newz = newx * 3 + newy;
//				if (newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {
//					State& temp = st[rear];//尝试更新移动后的状态
//					memcpy(temp, s, sizeof(s));
//					temp[newz] = s[z];
//					temp[z] = s[newz];
//					dis[rear] = dis[front] + 1;
//					if (try_insert(rear)) {
//						rear++;
//					}
//				}
//			}
//			front++;
//		}
//	}
//	return 0;
//}
//int main() {
//	for (int i = 0; i < 9; i++) {
//		cin >> st[1][i];
//	}
//	for (int i = 0; i < 9; i++) {
//		cin >> goal[i];
//	}
//	int ans = bfs();
//	if (ans > 0) {
//		cout << dis[ans];
//	}
//	system("pause");
//}

//#include<iostream>
//#include<cstdio>
//#include<cstring>
//#include<queue>
//using namespace std;
//struct Node {
//	int v[3], dist;////v[]是各个杯子里的水，dist是总取水量！
//	bool operator < (const Node& rhs) const {
//		return dist > rhs.dist;////最小值优先级大！
//	}
//};

////倒水问题
////用ans[]来记录答案，不断取最小值来更新！
////
////用vis[][]来表示是否访问过，之所以是二维数组，是因为总水量是固定的，两个杯子确定，第三个杯子自然也就确定，两个状态足矣！
////
////用结构体表示每一个状态！其中包括每个杯子的水量！u.v[]，还有dist 为到目前这个状态总的取水量！
//const int maxn = 200 + 5;
//int vis[maxn][maxn], cap[3], ans[maxn];
//
//void update_ans(const Node& u) {
//	for (int i = 0; i < 3; i++) {//三个杯子的状态都需要更新
//		int d = u.v[i];
//		////在优先队列中每提出一个队首元素，就对应一个新的状态，就需要在ans[]更新状态！更新取水量最小的状态
//		cout << "update: " << "u.v[" << i << "]: " << d << endl;
//		if (ans[d] < 0 || u.dist < ans[d]) {//如果这个水量没有出现过 或者出现过 但是现在能给出更小的值 则更新
//			ans[d] = u.dist;
//		}
//	}
//	
//}
//void solve(int a, int b, int c, int d) {
//	cap[0] = a; cap[1] = b; cap[2] = c;//表示三个杯子的状态
//	memset(vis, 0, sizeof(vis));
//	memset(ans, -1, sizeof(ans));
//	priority_queue<Node> q;
//	Node start;
//	start.dist = 0;
//	start.v[0] = 0; start.v[1] = 0; start.v[2] = c;
//	q.push(start);
//	vis[0][0] = 1;
//	while (!q.empty()) {
//		Node u = q.top(); q.pop();
//		update_ans(u);
//		if (ans[d] >= 0) break;
//		for (int i = 0; i < 3; i++)///i倒入j
//			for (int j = 0; j < 3; j++) if (i != j) {
//				if (u.v[i] == 0 || u.v[j] == cap[j]) continue;//i中没水或者j已经满了 跳过
//				int amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];////mount 为需要倒水的量，这样写 不会出现负值！
//				Node u2;
//				memcpy(&u2, &u, sizeof(u));
//				u2.dist = u.dist + amount;
//				u2.v[i] -= amount;
//				u2.v[j] += amount;
//				if (!vis[u2.v[0]][u2.v[1]]) {//判断是否需要加入节点
//					vis[u2.v[0]][u2.v[1]] = 1;
//					q.push(u2);
//				}
//			}
//	}
//	while (d >= 0) {
//		if (ans[d] >= 0) {//如果d对应的ans存在 则直接输出 否则递减（因为求最接近的）
//			printf("%d %d\n", ans[d], d);
//			return;
//		}
//		d--;
//	}
//}
//int main() {
//	int T, a, b, c, d;
//	cin >> T;//T表示测试用例数
//	while (T--) {
//		cin >> a >> b >> c >> d;
//		solve(a, b, c, d);
//	}
//	system("pause");
//	return 0;
//}

////最大字段和 暴力求解
//#include<iostream>
//using namespace std;
//const int maxn = 10000;
//int sum = 0;
//int main() {
//	int n;
//	int A[maxn];
//	int len = 0;
//	int ans = -1000000;
//	while (cin >> n) {
//		A[len++] = n;
//		//cout << len << "n: "<<n<<endl;
//
//	}
//	for (int i = 0; i < len; i++) {
//		sum = 0;
//		for (int j = i; j < len; j++) {
//			sum = sum + A[j];
//			
//			if (sum > ans) { 
//				ans = sum;
//			}
//
//		}
//	}
//	cout << ans;
//	system("pause");
//}


