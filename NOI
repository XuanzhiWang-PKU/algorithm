//1.1编程基础之输入输出
//	Hello, World!
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "Hello, World!";
//}

//	输出第二个整数
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b>>c;
//	cout << b;
//}

//	对齐输出
//#include <iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	printf("%8d %8d %8d", a, b, c);
//	system("pause");
//	return 0;
//}

//输出保留3位小数的浮点数
//#include<iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	float a;//单精度浮点数
//	cin >> a;
//	cout << fixed << setprecision(3) << a;
//	system("pause");
//}

//输出保留12位小数的浮点数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double a;
//	cin >> a;
//	cout << fixed << setprecision(12) << a;
//	system("pause");
//}

//空格分隔输出
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	char a;
//	int b;
//	float c;
//	double d;
//	cin >> a >> b >> c >> d;
//	cout << a << " " << b << " " << fixed << setprecision(6) << c << " " << fixed << setprecision(6) << d;
//	system("pause");
//}

//输出浮点数
//#include <iostream>
//using namespace std;
//double a;
//int main() {
//	cin >> a;
//	printf("%f\n", a);
//	printf("%.5f\n", a);//.后面表示精度
//	printf("%e\n", a);
//	printf("%g", a);
//	system("pause");
//	return 0;
//}

//字符三角形
//#include <iostream>
//using namespace std;
//char a;
//int main() {
//	cin >> a;
//	cout << "  " << a << "  "<<endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << a << a << a << a << a;
//	system("pause");
//	return 0;
//}

//字符菱形
//#include <iostream>
//using namespace std;
//char a;
//int main() {
//	cin >> a;
//	cout << "  " << a << "  " << endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << a << a << a << a << a<<endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << "  " << a << "  ";
//	system("pause");
//	return 0;
//}

//超级玛丽游戏 ?
//#include <iostream>
//using namespace std;
//int main() {
//	printf("                ********\n\
//               ************\n\
//               ####....#.\n\
//             #..###.....##....\n\
//             ###.......######              ###                 ###           ###           ###\n\
//                ...........               #...#               #...#         #...#         #...#\n\
//               ##*#######                 #.#.#               #.#.#         #.#.#         #.#.#\n\
//            ####*******######             #.#.#               #.#.#         #.#.#         #.#.#\n\
//           ...#***.****.*###....          #...#               #...#         #...#         #...#\n\
//           ....**********##.....           ###                 ###           ###           ###\n\
//           ....****    *****....\n\
//             ####        ####\n\
//           ######        ######\n\
//##############################################################              ##################################\n\
//#...#......#.##...#......#.##...#......#.##------------------#              #...#......#.##------------------#\n\
//###########################################------------------#              ###############------------------#\n\
//#..#....#....##..#....#....##..#....#....#####################              #..#....#....#####################\n\
//##########################################    #----------#                  ##############    #----------#\n\
//#.....#......##.....#......##.....#......#    #----------#                  #.....#......#    #----------#\n\
//##########################################    #----------#                  ##############    #----------#\n\
//#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#                  #.#..#....#..#    #----------#\n\
//##########################################    ############                  ##############    ############");
//	system("pause");
//}

//1.2编程基础之变量定义、赋值及转换
//整型数据类型 存储空间大小存储空间大小（单位：字节） 4 2
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	short b;
//	a = 1;
//	b = 1;
//	cout << sizeof(a) <<" "<< sizeof(b);
//	system("pause");
//	return 0;
//}

//浮点型数据类型存储空间大小  4 8 
//#include <iostream>
//using namespace std;
//int main() {
//	float a;
//	double b;
//	a = 1.0;
//	b = 1.0;
//	cout << sizeof(a) << " " << sizeof(b);
//	system("pause");
//	return 0;
//}

//其他基本数据类型存储空间大小 1 1 
//#include <iostream>
//using namespace std;
//int main() {
//	bool a;
//	char b;
//	a = true;
//	b = a;
//	cout << sizeof(a) << " " << sizeof(b);
//	system("pause");
//	return 0;
//}

//填空：类型转换1
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "D C";
//	system("pause");
//}

//填空：类型转换1
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "F E";
//	system("pause");
//}

//浮点数向零舍入
//#include <iostream>
//using namespace std;
//int main() {
//	float a;
//	cin >> a;
//	cout << (int)a;
//	system("pause");
//}

//打印ASCII码 NULL的ascii是0
//#include <iostream>
//using namespace std;
//int main() {
//	char a;
//	cin >> a;
//	//cout << a - NULL;
//	cout << (int)a;
//	system("pause");
//}

//打印字符
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	cin >> a;
//	cout << (char)a;
//	system("pause");
//}

//整型与布尔型的转换
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	cin >> a;
//	bool b = a;
//	a = b;
//	cout << a;
//	system("pause");
//}

//Hello, World!的大小
//#include <iostream>
//using namespace std;
//int main() {
//	char c[] = "Hello, World!";
//	cout << sizeof(c);
//	system("pause");
//}

//1.3编程基础之算术表达式与顺序执行
////A+B问题
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	cout << a + b;
//	system("pause");
//}

//计算(a+b)*c的值
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	cout << (a + b)*c;
//	system("pause");
//}

//计算(a+b)/c的值
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	cout << (a + b)/c;
//	system("pause");
//}

//带余除法
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b ;
//	cout <<a/b<<" "<<a%b;
//	system("pause");
//}

//计算分数的浮点数值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	double c = (double)a / b;
//	cout << fixed<<setprecision(9)<<c;
//	system("pause");
//}

//甲流疫情死亡率
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	double c = (double)b / a;
//	c = c * 100;
//	cout << fixed << setprecision(3) << c << "%";
//	system("pause");
//}


//计算多项式的值 ？
//#include<iostream>
//#include<iomanip>
//#include<math.h>//因为用了pow 要加头文件
//using namespace std;
//int main() {
//	double x, a, b, c, d;
//	cin >> x >> a >> b >> c >> d;
//	double ans = a * pow(x, 3) + b * pow(x, 2) + c * pow(x, 1) + d;
//	cout << fixed << setprecision(7) << ans;
//	system("pause");
//}

//温度表达转化
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double f;
//	cin >>f;
//	double ans = 5*(f -32)/9;
//	cout << fixed << setprecision(5) << ans;
//	system("pause");
//}


// 与圆相关的计算
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double pi = 3.14159;
//double r;
//int main() {
//	cin >> r;
//	cout << fixed << setprecision(4) << 2*r<<" " << fixed << setprecision(4) << 2 * r * pi << " " << fixed << setprecision(4) << pi * pow(r,2) << " ";
//	system("pause");
//}

//计算并联电阻的阻值  ？
//#include<iostream>
//#include<iomanip>
//using namespace std;
//float a, b;//题目要求用浮点型
//int main() {
//	cin >> a >> b;
//	float ans = 1 / (1 / a + 1 / b);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//}

//计算浮点数相除的余数 ?
//#include<iostream>
//#include<iomanip>
//using namespace std;
//double a, b;
//int main() {
//	cin >> a >> b;
//	int k = a / b;
//	double ans = a - b * k;
//	/*注意：输出时小数尾部没有多余的0，可以用下面这种格式：
//		double x;
//	x = 1.33;
//	printf("%g", x);*/
//	printf("%g", ans);
//	system("pause");
//}

//计算球的体积
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double pi = 3.14;
//double r;
//int main() {
//	cin >> r;
//	double ans =( 4.0 / 3.0) * pi*pow(r, 3);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//}

//反向输出一个三位数
//#include<iostream>
//using namespace std;
//int a;
//int main() {
//	cin >> a;
//	cout << a % 10;
//	a = a / 10;
//
//	cout << a % 10;
//	a = a / 10;
//
//	cout << a % 10;
//	a = a / 10;
//
//	system("pause");
//}

//大象喝水
//1升 = 1000毫升
//1毫升 = 1 立方厘米
//#include<iostream>
//#include<math.h>//floor向下取整要包含头文件
//using namespace std;
//int h, r;
//double pi = 3.14159;
//int main() {
//	cin >> h >> r;
//	double v = pi * pow(r, 2)*h;
//	int  ans = floor((20.0 * 1000.0)/ v + 1);//相当于向上取整
//	cout << ans;
//	system("pause");
//}

//苹果和虫子 ?
//#include<iostream>
//#include<math.h>//ceil向上取整要包含头文件
//using namespace std;
//int n, x, y;
//int main() {
//	cin >> n >> x >> y;
//	int bad = ceil(double(y) / double(x));
//	int ans = n - bad;
//	cout << ans;
//
//	system("pause");
//}

//计算线段长度 ?头文件问题
//#include<iostream>
//#include<cmath>//包含cmath就不报错 math.h报错
//#include <iomanip>
//using namespace std;
//double xa, ya, xb, yb;
//int main() {
//	cin >> xa >> ya >> xb >> yb;
//	double  ans = sqrt(pow(abs(xa - xb), 2) + pow(abs(ya - yb), 2));
//	cout << fixed << setprecision(3) << ans;
//	system("pause");
//}

//计算三角形面积
//用海伦公式
//#include <iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//float x1, Y1, x2, y2, x3, y3;
//int main() {
//	cin >> x1 >> Y1 >> x2 >> y2 >> x3 >> y3;
//	float a = sqrt(pow(abs(x1 - x2), 2) + pow(abs(Y1 - y2), 2));
//	float b = sqrt(pow(abs(x3 - x2), 2) + pow(abs(y3 - y2), 2));
//	float c = sqrt(pow(abs(x1 - x3), 2) + pow(abs(Y1 - y3), 2));
//	float p = (a + b + c) / 2;//半周长
//	float s = sqrt(p*(p - a)*(p - b)*(p - c));
//	//cout << a << " " << b << " " << c << " " << p << endl;
//	cout << fixed << setprecision(2) << s;
//	system("pause");
//	return 0;
//}

//等差数列末项计算
//#include <iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int a, b, n;
//int main() {
//	cin >> a >> b >> n;
//	int delta = b - a;
//	int ans = a + delta * (n - 1);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//	return 0;
//}

//A*B问题
//#include <iostream>
//using namespace std;
//long long a, b;
//int main() {
//	cin >> a >> b ;
//	
//	long long ans = a *b;
//	cout  << ans;
//	system("pause");
//	return 0;
//}

//计算2的幂
//#include <iostream>
//#include<cmath>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//
//	long long ans = pow(2, n);
//	cout << ans;
//	system("pause");
//	return 0;
//}

//1.4编程基础之逻辑表达式与条件分支
//#include <iostream>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//	if (n > 0) {
//		cout << "positive";
//	}
//	else if (n == 0) {
//		cout << "zero";
//	}
//	else{
//		cout << "negative";
//	}
//	system("pause");
//}

//输出绝对值
//#include <iostream>
//#include <iomanip>
//#include<cmath>
//using namespace std;
//float n;
//int main() {
//	cin >> n;
//	cout << fixed << setprecision(2) << abs(n);
//	system("pause");
//}

//奇偶数判断
//#include <iostream>
//#include <iomanip>
//#include<cmath>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//	if (n % 2 == 1) {
//		cout << "odd";
//	}
//	else {
//		cout << "even";
//	}
//	system("pause");
//}

//奇偶ASCII值判断 ？
//#include <iostream>
//#include <iomanip>
//using namespace std;
//char ch;
//int main() {
//	ch = getchar();//cin>>ch报错
//	if ((int)ch % 2 == 1) {
//		cout << "YES";
//	}
//	else {
//		cout << "NO";
//	}
//	system("pause");
//	return 0;
//}

// 整数大小比较
//#include <iostream>
//#include <iomanip>
//using namespace std;
//long long x, y;
//int main() {
//	cin >> x >> y;
//	if (x > y) {
//		cout << ">";
//	}
//	else if (x < y) {
//		cout << "<";
//	}
//	else {
//		cout << "=";
//	}
//	system("pause");
//	return 0;
//}

//判断是否为两位数
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x ;
//	if (x>=10&&x<=99) {
//		cout << "1";
//	}
//	else {
//		cout << "0";
//	}
//	system("pause");
//	return 0;
//}


//收集瓶盖赢大奖
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x,y;
//int main() {
//	cin >> x>>y;
//	if (x >= 10||y>=20) {
//		cout << "1";
//	}
//	else {
//		cout << "0";
//	}
//	system("pause");
//	return 0;
//}

//判断一个数能否同时被3和5整除
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x ;
//	if (x %3 == 0 && x%5 == 0) {
//		cout << "YES";
//	}
//	else {
//		cout << "NO";
//	}
//	system("pause");
//	return 0;
//}


//判断能否被3，5，7整除
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//
//int main() {
//	cin >> x;
//	bool flag = false;
//	if (x % 3 == 0) {
//		cout << "3";
//		flag = true;
//		if (x % 5 == 0) {
//			cout << " 5";
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//		else {
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//	}
//	else {
//		if (x % 5 == 0) {
//			flag = true;
//			cout << "5";
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//		else {
//			if (x % 7 == 0) {
//				flag = true;
//				cout << "7";
//			}
//		}
//	}
//	if (!flag) {
//		cout << 'n';
//	}
//
//
//	system("pause");
//	return 0;
//}

//有一门课不及格的学生
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x,y;
//int main() {
//	cin >> x>>y;
//	bool flag = false;
//	if ((x < 60 && y>=60)|| y < 60 && x >= 60) {
//		cout << 1;
//	}
//	else {
//		cout << 0;
//	}
//	
//	system("pause");
//	return 0;
//}

//晶晶赴约会
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x;
//	if (x == 1 || x == 3 || x == 5) {
//		cout << "NO";
//	}
//	else {
//		cout << "YES";
//	}
//
//	system("pause");
//	return 0;
//}

//骑车与走路
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x;
//	double walk = x / 1.2;
//	double bike = x / 3.0 + 27 + 23;
//	if (walk > bike) {
//		cout << "Bike";
//	}
//	else if(walk<bike){
//		cout << "Walk";
//	}
//	else {
//		cout << "All";
//	}
//	system("pause");
//	return 0;
//}

//	分段函数
//#include <iostream>
//#include <iomanip>
//using namespace std;
//double x;
//double y = 0.0;
//int main() {
//	cin >> x;
//	
//	if (x>=0&& x<5) {
//		y = -x + 2.5;
//	}
//	else if (x>=5&&x<10) {
//		y = 2 - 1.5*(x - 3)*(x - 3);
//	}
//	else {
//		y = x / 2 - 1.5;
//	}
//	cout <<fixed<<setprecision(3)<< y;
//	system("pause");
//	return 0;
//}


//计算邮资
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x;
//char ch;
//int tot = 0;
//int main() {
//	cin >> x>>ch;
//
//	if (x <=1000) {
//		tot = tot + 8;
//	}
//	else  {
//		int k = ceil((double(x) - 1000.0) / 500.0);
//		//cout << (double(x) - 1000.0) / 500.0;
//		tot = tot + 8 + k * 4;
//	}
//	if (ch == 'y') {
//		tot = tot + 5;
//	}
//	cout << tot;
//	system("pause");
//	return 0;
//}

//最大数输出
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x, y, z;
//int m;
//int main() {
//	cin >> x >> y >> z;
//	m = x;
//	if (y > m) {
//		m = y;
//	}
//	if (z > m) {
//		m = z;
//	}
//	cout << m;
//	system("pause");
//	return 0;
//}

//三角形判断
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x, y, z;
//int main() {
//	cin >> x >> y >> z;
//	if (x +y >z&& x+z>y&&y+z>x) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	system("pause");
//	return 0;
//}

//判断闰年
//#include <iostream>
//using namespace std;
//int a;
//int main() {
//	cin >> a;
//	if (a % 100 == 0) {
//		if (a % 400 == 0) {
//			cout << "Y";
//		}
//		else cout << "N";
//	}
//	else if (a % 4 == 0) {
//		cout << "Y";
//	}
//	else {
//		cout << "N";
//	}
//	system("pause");
//}


//点和正方形的关系
//#include <iostream>
//using namespace std;
//int x, y;
//int main() {
//	cin >> x >> y;
//	if (x <= 1 && x >= -1 && y <= 1 && y >= -1) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	system("pause");
//}

//简单计算器
//#include <iostream>
//using namespace std;
//int x, y;
//char ch;
//int main() {
//	cin >> x >> y >> ch;
//	if (ch == '+') {
//		cout << x + y;
//	}
//	else if (ch == '-') {
//		cout << x - y;
//	}
//	else if (ch == '*') {
//		cout << x * y;
//	}
//	else if (ch == '/') {
//		if (y == 0) {
//			cout << "Divided by zero!";
//		}
//		else {
//			cout << x / y;
//		}
//	}
//	else {
//		cout << "Invalid operator!";
//	}
//	system("pause");
//	return 0;
//}

//求一元二次方程的根
//#include <iostream>
//#include <cmath>
//#include<iomanip>
//using namespace std;
//double a, b, c;
//int main() {
//	cin >> a >> b >> c;
//	if (b *b == 4 * a * c) {
//
//		cout << "x1=x2=" << fixed << setprecision(5) << (-b + sqrt(b*b - 4 * a*c)) / (2 * a);
//	}
//	else if (b*b > 4 * a * c) {
//
//		cout << "x1=" << fixed << setprecision(5) << (-b + sqrt(b*b - 4 * a*c)) / (2 * a) << ";";
//		cout << "x2=" << fixed << setprecision(5) << (-b - sqrt(b*b - 4 * a*c)) / (2 * a);
//	}
//	else if (b*b < 4 * a * c) {
//		if (b != 0) {
//			cout << "x1=" << fixed << setprecision(5) << -b / (2 * a) << '+' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i' << ";";
//			cout << "x2=" << fixed << setprecision(5) << -b / (2 * a) << '-' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i';
//		}
//		else {
//			cout << "x1=" << fixed << setprecision(5) << 0.0 << '+' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i' << ";";
//			cout << "x2=" << fixed << setprecision(5) << 0.0 << '-' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i';
//
//		}
//	}
//	system("pause");
//	return 0;
//}

//苹果和虫子2
//#include<iostream>
//#include<math.h>//ceil向上取整要包含头文件
//using namespace std;
//int n, x, y;
//int main() {
//	cin >> n >> x >> y;
//	int bad = ceil(double(y) / double(x));
//	int ans = n - bad;
//	if (ans < 0) {
//		cout << 0;
//	}
//	else {
//		cout << ans;
//	}
//	system("pause");
//}

// 1.5编程基础之循环控制
//	求平均年龄
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int n;
//int sum = 0;
//int main() {
//	cin >> n;
//	int tot = n;
//	int temp;
//	while (n--) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / double(tot);
//	cout <<fixed <<setprecision(2)<< ave;
//	system("pause");
//}

//财务管理
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double temp;
//	double sum = 0;
//	for(int i = 0; i < 12; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / 12.0;
//	cout << "$"<<fixed << setprecision(2) << ave;
//	system("pause");
//}


//均值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double temp;
//	double sum = 0;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) /double(n);
//	cout <<  fixed << setprecision(4) << ave;
//	system("pause");
//}

//求整数的和与均值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	long long temp;
//	long long sum = 0;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / double(n);
//	cout <<sum<<" "<< fixed << setprecision(5) << ave;
//	system("pause");
//}


//最高的分数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int m,f,temp;
//	int n;
//	cin >> n;
//	cin >> f;
//	m = f;
//	for (int i = 1; i < n; i++) {
//
//		cin >> temp;
//		if (temp > m) {
//			m = temp;
//		}
//	}
//	
//	cout << m;
//	system("pause");
//}

//整数序列的元素最大跨度值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int m,s, f, temp;
//	int n;
//	cin >> n;
//	cin >> f;
//	m = f;
//	s = f;
//	for (int i = 1; i < n; i++) {
//
//		cin >> temp;
//		if (temp > m) {
//			m = temp;
//		}
//		if (temp < s) {
//			s = temp;
//		}
//	}
//
//	cout << m - s;
//	system("pause");
//}

//奥运奖牌计数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n;
//	int tj, ty, tt;
//	int j = 0;
//	int y = 0;
//	int t = 0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> tj >> ty >> tt;
//		j += tj;
//		y += ty;
//		t += tt;
//	}
//	cout << j<<" "<<y<<" "<<t<<" "<<j+y+t;
//	system("pause");
//}

//多边形内角和
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n,temp;
//	cin >> n;
//	int sum = 0;
//	for (int i = 0; i < n-1; i++) {
//		cin >> temp;
//		sum += temp;
//	}
//	cout << (n-2)*180 - sum;
//	system("pause");
//}

//奇数求和
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m;
//	int sum = 0;
//	cin >> n >> m;
//	if (n % 2 == 1) {
//		for (int i = n; i <= m; i = i + 2) {
//			
//				sum += i;
//			
//		}
//	}
//	else {
//		for (int i = n+1; i <= m; i = i + 2) {
//
//			sum += i;
//
//		}
//	}
//	
//	cout << sum;
//	system("pause");
//}

//满足条件的数累加
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m;
//	int sum = 0;
//	cin >> n >> m;
//	
//		for (int i = n; i <= m; i++) {
//			if (i % 17 == 0) {
//				sum += i;
//			}
//		}
//	
//	cout << sum;
//	system("pause");
//}

//整数的个数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m, temp;
//	int sum = 0;
//	cin >> n >> m;
//
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		if (temp == m) {
//			sum++;
//		}
//	}
//	cout << sum;
//	system("pause");
//}

//乘方计算
//#include<iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n, m;
//	long long ans;
//	cin >> n >> m;
//
//	ans = pow(n, m);
//	cout << ans;
//	system("pause");
//}

//人口增长问题
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int x,n;
//	double  ans;
//	cin >> x >> n;
//	ans = double(x);
//	for (int i = 0; i < n; i++) {
//		ans = ans *(1+ 0.1 / 100);
//	}
//	cout <<fixed<<setprecision(4)<< ans;
//	system("pause");
//}

//银行利息 ????
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int r, m, y;
//	cin >> r >> m >> y;
//	double ans = m;
//	for (int i = 0; i < y; i++) {
//		ans = ans * (100 + r) / 100;
//		//cout << ans << endl;
//	}
//	int q = floor(ans);
//	cout << q;
//	system("pause");
//	return 0;
//}


//买房子
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int n, k;
//	cin >> n >> k;
//	double price = 200.0;
//	double salary = double(n);
//	int flag = 0;
//	for (int i = 1;i<=20; i++) {
//		
//		if (salary >= price) {
//			cout << i;
//			flag = 1;
//			break;
//		}
//		price = price * (100 + k) / 100;
//		salary += n;
//	}
//	if (!flag) {
//		cout << "Impossible";
//	}
//	system("pause");
//	return 0;
//}


//菲波那契数列 ?
//#include <iostream>
//#include<string.h>//memset函数要头文件string.h
//using namespace std;
//const int maxn = 50;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	m[1] = 1;
//	m[2] = 1;
//	int k;
//	cin >> k;
//	if (k <= 2) {
//		cout << 1;
//	}
//	else {
//		for (int i = 3; i <= k; i++) {
//			m[i] = m[i - 1] + m[i - 2];
//		}
//		cout << m[k];
//	}
//	system("pause");
//	return 0;
//}

//鸡尾酒疗法
//#include <iostream>
//using namespace std;
//int main() {
//	int n, stanx, stany;
//	cin >> n;
//	cin >> stanx >> stany;
//	double stan = double(stany) / double(stanx);
//	int tempx, tempy;
//	double temp;
//	for (int i = 1; i < n; i++) {
//		cin >> tempx >> tempy;
//		temp = double(tempy) / double(tempx);
//	
//		if (temp - stan > 0.05) {
//			cout << "better" ;
//		}
//		else if (stan  - temp> 0.05) {
//			cout << "worse" ;
//		}
//		else {
//			cout << "same" ;
//		}
//		if (i < n - 1) {
//			cout << endl;
//		}
//	}
//	system("pause");
//}

//救援 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	double x, y;//读清题目条件 输入为实数
//	int z;
//	double t = 0.0;
//	for (int i = 0; i < n; i++) {
//		cin >> x >> y >> z;
//		double dist = sqrt(pow(x, 2) + pow(y, 2));
//		//cout << dist << " " << 2 * dist / 50 << endl;
//		t = t + 2 * dist / 50 + z * 1.5;
//	}
//	cout << ceil(t);
//	system("pause");
//}

//球弹跳高度的计算
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n = 10;
//	int h;
//	cin >> h;
//	double tot = 0.0;
//	double len = double(h);
//	tot = tot + len;
//	len = len / 2;
//	for (int i = 2; i <= n; i++) {
//		tot = tot + 2 * len;
//		len = len / 2;
//	}
//	printf("%g\n%g", tot, len);
//	system("pause");
//}


//角谷猜想 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	long int n, temp;//用long int 不然会报错
//	cin >> n;
//	if (n == 1) {
//		cout << "End";
//	}
//	else {
//		while (n != 1) {
//			if (n % 2 == 1) {
//				temp = n * 3 + 1;
//				cout << n << "*3+1=" << temp << endl;
//				n = temp;
//			}
//			else {
//				temp = n / 2;
//				cout << n << "/2=" << temp << endl;
//				n = temp;
//			}
//		}
//		cout << "End";
//	}
//	system("pause");
//	return 0;
//}

//津津的储蓄计划 ??
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n = 12;
//	int temp, rest = 0;
//	int win = 0;
//	bool flag = true;
//	for (int i = 1; i <= n; i++) {
//		rest = rest + 300;
//		cin >> temp;
//		if (temp > rest) {
//			cout << "-" << i;
//			flag = false;
//			break;
//		}
//		else {
//			rest = rest - temp;
//			win = win + 100 * (rest / 100);
//			rest = rest - 100 * (rest / 100);
//		}
//		//cout << rest << " " << win << endl;
//	}
//	if (flag) {
//		cout << win * 1.2 + rest;//最后一个月可能还剩下钱
//	}
//	system("pause");
//	return 0;
//}


//药房管理
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int tot, n, temp, cnt = 0;
//	cin >> tot >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		if (temp <= tot) {//可以取等
//			tot = tot - temp;
//		}
//		else {
//			cnt++;
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//正常血压 
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n,h,l;
//	int cnt = 0,max = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> h>>l;
//		if (h>=90 &&h<=140&&l>=60&&l<=90) {
//			cnt++;
//			if (cnt >= max) {
//				max = cnt;
//			}
//		}
//		else {
//			cnt = 0;
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//求特殊自然数 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  s, n;
//	int m[3];
//	bool flag = true;
//	for (int i = 101; i <= 666; i++) {//因为7进制数不能出现大于7的数字
//		int temp = i;
//		for (int j = 0; j < 3; j++) {
//			m[j] = temp % 10;
//			temp = temp / 10;
//			//cout << m[j] << endl;
//		}
//		s = m[0] + m[1] * 7 + m[2] * 49;
//		n = m[0] * 81 + m[1] * 9 + m[2];
//		if (m[0] < 7 && m[1] < 7 && s == n) {//因为7进制数不能出现大于7的数字
//			if (flag) {
//				cout << s << endl << m[2] << m[1] << m[0] << endl << m[0] << m[1] << m[2];
//				flag = false;
//			}
//			else {
//				cout << endl << s << endl << m[2] << m[1] << m[0] << endl << m[0] << m[1] << m[2];
//			}
//		}
//
//	}
//
//	system("pause");
//	return 0;
//}

//统计满足条件的4位数个数
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  n;
//	int cnt = 0;
//	int temp;
//	int m[4];
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		for (int j = 0; j < 4; j++) {
//			m[j] = temp % 10;
//			temp = temp / 10;
//		}
//		int ans = m[0] - m[1] - m[2] - m[3];
//		if (m[0] - m[1] - m[2] - m[3] > 0) {
//			cnt++;
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//级数求和
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  n;
//	cin >> n;
//	double s = 0.0;
//	int i;
//	for ( i = 1; s <= n; i++) {
//		if (s > n) {
//			cout << i;
//		}
//		else {
//			
//			s = s + 1.0 / i;
//			//cout << s << endl;
//		}
//	}
//	cout << i-1;
//	system("pause");
//	return 0;
//}

//分离整数的各个数位
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int main() {
//	long int  n;
//	cin >> n;
//	int i;
//	for (i = 0;; i++) {
//		if (n == 0) {
//			break;
//		}
//		else {
//			m[i] = n % 10;
//			n = n / 10;
//		}
//	}
//	bool flag = true;
//	for (int j = 0; j < i; j++) {
//		if (flag) {
//			cout << m[j];
//			flag = false;
//		}
//		else {
//			cout << " " << m[j];
//		}
//	}
//	system("pause");
//	return 0;
//}

//数字反转
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int main() {
//	long int  n;
//	cin >> n;
//	int i;
//	bool nag = false;
//	if (n < 0) {
//		n = -n;
//		nag = true;
//	}
//	for (i = 0;; i++) {
//		if (n == 0) {
//			break;
//		}
//		else {
//			m[i] = n % 10;
//			n = n / 10;
//		}
//	}
//	bool flag = true;
//	if (nag) {
//		cout << "-";
//	}
//	for (int j = 0; j < i; j++) {
//		
//		if (flag) {
//			if (m[j] != 0) {
//				cout << m[j];
//				flag = false;
//			}
//		}
//		else {
//			cout << m[j];
//		}
//		
//	}
//	system("pause");
//	return 0;
//}


//含k个3的数
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int matrix[maxn];
//int main() {
//	int  m,k,cnt = 0;
//	cin >> m>>k;
//	int i;
//	if (m % 19 == 0) {
//		for (i = 0;; i++) {
//			if (m == 0) {
//				break;
//			}
//			else {
//				matrix[i] = m % 10;
//				m = m / 10;
//			}
//		}
//		for (int j = 0; j < i; j++) {
//				if (matrix[j] == 3) {
//					cnt++;
//				}
//		}
//		if (cnt == k) {
//			cout << "YES";
//			system("pause");
//			return 0;
//		}
//	}
//	cout << "NO";
//	system("pause");
//	return 0;
//}

//开关灯
//#include <iostream>
//#include<cmath>
//#include <string.h>
//using namespace std;
//const int maxn = 5001;
//int matrix[maxn];
//int main() {
//	memset(matrix, 0, sizeof(matrix));
//	
//	int  n, m;
//	cin >> n >> m;
//	for (int i = 1; i <= m; i++) {
//		for (int j = i; j <= n; j = j + i) {//这里的步长是i，不是m
//			matrix[j] = matrix[j] + 1;
//			/*for (int k = 1; k <= 5; k++) {
//				cout << matrix[k] << " ";
//			}
//			cout << endl;*/
//		}
//		//cout << "i:" << i << endl;
//	}
//	bool flag = true;
//	for (int i = 1; i <= n; i++) {
//		if (matrix[i] % 2 == 1) {
//			if (flag) {
//				cout << i;
//				flag = false;
//			}
//			else {
//				cout << "," << i;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//求分数序列和
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 35;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	m[1] = 1;
//	m[2] = 2;
//	int  n;
//	cin >> n;
//	for (int i = 3; i <= n + 1; i++) {
//		m[i] = m[i - 1] + m[i - 2];
//		//cout << m[i] << endl;
//	}
//	double sum = 0.0;
//	for (int i = 1; i <= n; i++) {
//		sum = sum + double(m[i + 1]) / double(m[i]);
//		//cout << "sum: " << sum << endl;
//	}
//	cout << fixed << setprecision(4) << sum;
//	system("pause");
//	return 0;
//}

//计算分数加减表达式的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//
//int main() {
//	double sum = 0.0;
//	int  n;
//	cin >> n;
//	for (int i = 1; i <= n ; i++) {
//		sum = sum - pow(-1, i)*1.0/double(i);
//	}
//	
//	cout << fixed << setprecision(4) << sum;
//	system("pause");
//	return 0;
//}

//求阶乘的和
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	long int sum = 1;
//	long int part = 1;
//	int  n;
//	cin >> n;
//	for (int i = 2; i <= n; i++) {
//		part = part * i;
//		sum = sum + part;
//		//cout <<" "<< sum << endl;
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//求出e的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	double sum = 2.0;
//	long int part = 1;
//	int  n;
//	cin >> n;
//	for (int i = 2; i <= n; i++) {
//		part = part * i;
//		sum = sum + 1/double(part);
//		
//	}
//	cout <<fixed<<setprecision(10)<< sum;
//	system("pause");
//	return 0;
//}

//计算多项式的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	double sum = 1.0;
//	float part = 1;
//	int n;
//	float x;
//	cin >> x >> n;
//	for (int i = 1; i <= n; i++) {
//		part = part * x;
//		sum = sum + part;
//
//	}
//	cout << fixed << setprecision(2) << sum;
//	system("pause");
//	return 0;
//}

//雇佣兵 注意理解题意
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int m, n, x;
//	cin >> m >> n >> x;
//	while (1) {
//		if (n > m) {
//			cout << n;
//			break;
//		}
//		else if (x*n < m) {
//			cout << n;
//			break;
//		}
//		else {
//			x = x - ceil(double(m) / double(n));
//			int add = m / n;
//			n = n + add;
//		}
//	}
//	
//	//cout << fixed << setprecision(2) << sum;
//	system("pause");
//	return 0;
//}

//计算多项式的导函数 样例输入第一行的3删掉 从第二行开始看
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n,temp;
//	bool flag = true;
//	cin >> n;
//	if (n == 0) {
//		cout << 0;
//	}
//	else {
//		for (int i = n; i > 0; i--) {
//			
//			cin >> temp;
//			if (flag) {
//				cout << i * temp;
//				flag = false;
//			}
//			else {
//				cout << " " << i * temp;
//			}
//			
//		}
//	}
//	system("pause");
//	return 0;
//}

//与7无关的数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 5;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	bool flag = false;
//	long long n, sum = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		if (i % 7 == 0) {
//			flag = true;
//		}
//		else {
//			long long temp = i;
//			for (int j = 1; temp > 0; j++) {
//				m[j] = temp % 10;
//				temp = temp / 10;
//			}
//			for (int k = 1; k <= 3; k++) {
//				if (m[k] == 7) {
//					flag = true;
//				}
//			}
//		}
//		if (!flag) {
//			sum = sum + pow(i, 2);
//			
//		}
//		flag = false;
//		//cout <<i<< " "<< sum << endl;
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//数1的个数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 6;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n, cnt = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		int temp = i;
//		while (temp != 0) {
//			if (temp % 10 == 1) {
//				cnt++;
//			}
//			temp = temp / 10;
//			//cout << temp << endl;
//		}
//		//cout << i << " " << cnt << endl;
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//数字统计
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n, m, cnt = 0;
//	cin >> n >> m;
//	for (int i = n; i <= m; i++) {
//		int temp = i;
//		while (temp != 0) {
//			if (temp % 10 == 2) {
//				cnt++;
//			}
//			temp = temp / 10;
//			//cout << temp << endl;
//		}
//		//cout << i << " " << cnt << endl;
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//画矩形
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int row, col, flag;
//	char ch;
//	cin >> row >> col >> ch >> flag;
//	for (int i = 1; i <= col; i++) {
//		cout << ch;
//	}
//	cout << endl;
//	for (int j = 2; j < row; j++) {
//		if (flag) {
//			for (int i = 1; i <= col; i++) {
//				cout << ch;
//			}
//			cout << endl;
//		}
//		else {
//			cout << ch;
//			for (int i = 2; i < col; i++) {
//				cout << " ";
//			}
//			cout << ch;
//			cout << endl;
//		}
//	}
//	for (int i = 1; i <= col; i++) {
//		cout << ch;
//	}
//	system("pause");
//	return 0;
//}

//质因数分解 ??
//分析：题目要我们求的，是某个数的最大质因数，首先，要求的数要先满足两个条件
//（1） 它要是个质数 （2）它要能被题目所给数整除
//好了 一般思路，从小到大循环求这个数（从小到大查找可以极大减小运行次数），看看能不能把题目所给的数整除，而且还要是个质数，是就输出，解决；
//但问题真的那么简单吗，仔细思考，我们会发现，题目已经保障了数据一定是两个质数想乘而得到的，这意味着除了1和它本身，它只能被其他两个质数整除，
//所以，还判断什么质数啊，找到可以整除的最大数，直接输出吧，骚年。
//（注意从小到大进行查找）
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 2; i*i <= n; i++) {
//		if (n%i == 0) {
//			cout << n / i;
//		}
//	}
//	system("pause");
//	return 0;
//}

//第n小的质数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	int cnt = 0;
//	bool flag = true;
//	cin >> n;
//	int i;
//	for (i = 2; cnt < n; i++) {
//		for (int j = 2; j*j <= i; j++) {//要取等号
//			if (i%j == 0) {
//				flag = false;
//				break;
//			}
//		}
//		if (flag) {
//			cnt++;
//		}
//		flag = true;
//	}
//	cout << i-1;
//	system("pause");
//	return 0;
//}

////金币
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int d = 0;
//	int sum = 0;
//	for (int i = 1;; i++) {
//		for (int j = 1; j <= i; j++) {
//			sum = sum + i;
//			d++;
//			if (d == n) {
//				cout << sum;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	return 0;
//}

//1.6编程基础之一维数组
//与指定数字相同的数的个数
//#include <iostream>
//#include<string.h>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n, tar, temp,cnt =0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		m[i] = temp;
//		
//	}
//	cin >> tar;
//	for (int i = 0; i < n; i++) {
//		if (m[i] == tar) {
//			cnt++;
//			
//		}
//	}
//	cout << cnt;
//	system("pause");
//}

//陶陶摘苹果
//#include <iostream>
//#include<string.h>
//using namespace std;
//const int maxn = 11;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int can, temp, cnt = 0;
//	
//	for (int i = 0; i < 10; i++) {
//		cin >> temp;
//		m[i] = temp;
//
//	}
//	cin >> can;
//	for (int i = 0; i < 10; i++) {
//		if (m[i] <= can+30) {
//			cnt++;
//
//		}
//	}
//	cout << cnt;
//	system("pause");
//}

//计算书费
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//float book[maxn] = { 28.9,32.7 ,45.6,78.0,35.0, 86.2 ,27.8 ,43.0 ,56.0,65.0 };
//int main() {
//	float tot = 0.0;
//	int temp;
//	for (int i = 0; i < 10; i++) {
//		cin >> temp;
//		tot = tot + book[i] * temp;
//	}
//	cout << fixed << setprecision(1) << tot;
//	system("pause");
//}

//数组逆序重放
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//int m[maxn];
//int main() {
//	int n, temp;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		m[i] = temp;
//	}
//	bool flag = true;
//	for (int i = n-1; i >= 0; i--) {
//		if (flag) {
//			cout << m[i];
//			flag = false;
//		}
//		else {
//			cout << " " << m[i];
//		}
//	}
//	system("pause");
//}

//年龄与疾病
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//int m[maxn];
//int cnt[4];
//int main() {
//	int n, temp;
//	memset(cnt, 0, sizeof(cnt));
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		if (temp <= 18 && temp >= 0) {
//			cnt[0] = cnt[0] + 1;
//		}
//		if (temp <= 35 && temp >= 19) {
//			cnt[1] = cnt[1] + 1;
//		}
//		if (temp <= 60 && temp >= 36) {
//			cnt[2] = cnt[2] + 1;
//		}
//		if (temp >= 61) {
//			cnt[3] = cnt[3] + 1;
//		}
//	}
//	bool flag = true;
//	for (int i = 0; i < 4; i++) {
//		if (flag) {
//			cout << fixed << setprecision(2) << double(cnt[i]) / double(n)*100.0 << "%";
//			flag = false;
//		}
//		else {
//			cout << endl << fixed << setprecision(2) << double(cnt[i]) / double(n)*100.0 << "%";
//		}
//	}
//	system("pause");
//}

//校门外的树 ？
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	int len, amount, templ, tempr,cnt=0;
//	memset(m, 0, sizeof(m));
//
//	cin >> len >> amount;
//	for (int i = 0; i < amount; i++) {
//		cin >> templ >> tempr;
//		for (int j = templ; j <= tempr; j++) {
//			m[j] = 1;
//		}
//	}
//	for (int i = 0; i <= len; i++) {//这里要取0，因为0处也要种树
//		if(m[i]==1){
//			cnt++;
//		}
//	}
//	cout << len + 1 - cnt;
//	system("pause");
//}

//有趣的跳跃 ??只有6分
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 3010;
//long long m[maxn];
//long long ans[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(ans, 0, sizeof(ans));
//	int  n, cnt = 0;
//	long long temp;
//	cin >> n;
//	if (n == 1) {
//		cout << "Jolly";
//	}
//	else {
//		cin >> m[0];
//		for (int i = 1; i < n; i++) {
//			cin >> m[i];
//		}
//		for (int i = 0; i < n - 1; i++) {
//			ans[i] = abs(m[i] - m[i + 1]);//注意这里的范围，是m+1而不是m-1
//		}
//		sort(ans, ans + n - 1);
//		for (int i = 0; i < n - 2; i++) {
//			//cout << ans[i] << " ";
//			if (ans[i] - ans[i + 1] != -1) {
//				cout << "Not jolly";
//				system("pause");
//				return 0;
//			}
//		}
//		cout << "Jolly";
//	}
//	system("pause");
//	return 0;
//}

//石头剪刀布
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 110;
//int a[maxn], b[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	int n, na, nb,cnta= 0,cntb = 0;
//	cin >> n >> na >> nb;
//	for (int i = 0; i < na; i++) {
//		cin >> a[i];
//	}
//	for (int i = 0; i < nb; i++) {
//		cin >> b[i];
//	}
//	for (int i = 0; i < n; i++) {
//		a[i] = a[i%na];
//		b[i] = b[i%nb];
//	}
//	for (int i = 0; i < n; i++) {
//		if (a[i] == 0) {
//			if (b[i] == 2) {
//				cnta++;
//			}
//			else if (b[i] == 5) {
//				cntb++;
//			}
//		}
//		if (a[i] == 2) {
//			if (b[i] == 5) {
//				cnta++;
//			}
//			else if (b[i] == 0) {
//				cntb++;
//			}
//		}
//		if (a[i] == 5) {
//			if (b[i] == 0) {
//				cnta++;
//			}
//			else if (b[i] == 2) {
//				cntb++;
//			}
//		}
//	}
//	if (cnta > cntb) {
//		cout << "A";
//	}
//	else if (cnta < cntb) {
//		cout << "B";
//	}
//	else {
//		cout << "draw";
//	}
//	system("pause");
//	return 0;
//}

//向量点积计算
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 1100;
//int a[maxn], b[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	int n;
//	long long sum = 0;//不然会溢出
//	cin >> n ;
//	for (int i = 0; i < n; i++) {
//		cin >> a[i];
//	}
//	for (int i = 0; i < n; i++) {
//		cin >> b[i];
//	}
//	
//	for (int i = 0; i < n; i++) {
//		sum = sum + a[i] * b[i];
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//大整数加法
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 210;
//char a[maxn], b[maxn], ra[maxn], rb[maxn]; //用于存储输入和反转后的数组
//int aa[maxn], bb[maxn];//数字化数组
//int result[maxn];
//int carry[maxn];
//int main() {
//	//一定要初始化 因为可能会进位，要确保每一位进位时原来就是0
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(result, 0, sizeof(result));
//	memset(carry, 0, sizeof(carry));
//	memset(aa, 0, sizeof(aa));//重新开一个数组，确保后面每一位都是0
//	memset(bb, 0, sizeof(bb));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0, cntb = 0;
//	//统计开头的0的个数 方便后面翻转时不要把高位0也算进去了
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != '0') {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != '0') {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//	//这里是考虑边界情况，如果0+0，即字符串的长度等于高位0的个数，此时直接输出0
//	if (lena - cnta == 0 && lenb - cntb == 0) {
//		cout << 0;
//	}
//	//翻转数组 方便处理，不用翻转高位0，此时先不处理len 因为从最小位开始往前去 需要定位到len
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//	//翻转完之后再跟新len  并求最长len
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lenb * (lena < lenb) + lena * (lena >= lenb);
//	//_strrev(a);//编译器不让用
//	//_strrev(b);
//
//	//将字符转化为数字 要重新开一个int数组 因为后面计算是基于数字的  不是基于char的（ascii码）
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//	//先不考虑进位 直接相加
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = aa[i] + bb[i];
//		result[i + 1] = 0;//防止最后一位有进位
//		//cout << "i: " << i << " " << result[i] << endl;
//	}
//	//考虑进位 注意 这里应该先将当前位的数 加上进位位后 在计算下一个下一个进位位和当前的数
//	for (int i = 0; i < lenmax + 1; i++) {//最后一位可能有进位
//		result[i] = result[i] + carry[i];
//		carry[i + 1] = (result[i]) / 10;
//		result[i] = result[i] % 10;
//	}
//
//	//可能最高位进位了 则lenmax+1
//	if (result[lenmax] != 0) {
//		lenmax++;
//	}
//	//倒着输出
//	for (int i = lenmax - 1; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}


//大整数加法 法二
//#include <iostream>
//#include <string.h>
//using namespace std;
//const int maxn = 210;
//char a[maxn];
//char b[maxn];
//char ra[maxn];
//char rb[maxn];
//int aa[maxn];
//int bb[maxn];
//int result[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(aa, 0, sizeof(aa));
//	memset(bb, 0, sizeof(bb));
//	memset(result, 0, sizeof(result));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0;
//	int cntb = 0;
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != 0) {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != 0) {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lena * (lena >= lenb) + lenb * (lenb > lena);
//
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//	int temp, carry = 0;
//	for (int i = 0; i < lenmax + 1; i++) {
//		temp = aa[i] + bb[i] + carry;
//		result[i] = temp % 10;
//		carry = temp / 10;
//	}
//	if (result[lenmax] != 0) {
//		lenmax++;
//	}
//	for (int i = lenmax - 1; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}


//大整数减法
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 210;
//char a[maxn], b[maxn], ra[maxn], rb[maxn]; //用于存储输入和反转后的数组
//int aa[maxn], bb[maxn];//数字化数组
//int result[maxn];
//int carry[maxn];
//int main() {
//	//一定要初始化 因为可能会进位，要确保每一位进位时原来就是0
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(result, 0, sizeof(result));
//	memset(carry, 0, sizeof(carry));
//	memset(aa, 0, sizeof(aa));//重新开一个数组，确保后面每一位都是0
//	memset(bb, 0, sizeof(bb));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0, cntb = 0;
//	//统计开头的0的个数 方便后面翻转时不要把高位0也算进去了
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != '0') {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != '0') {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//	//这里是考虑边界情况，如果0+0，即字符串的长度等于高位0的个数，此时直接输出0
//	if (lena - cnta == 0 && lenb - cntb == 0) {
//		cout << 0;
//	}
//	//翻转数组 方便处理，不用翻转高位0，此时先不处理len 因为从最小位开始往前去 需要定位到len
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//	//翻转完之后再跟新len  并求最长len
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lenb * (lena < lenb) + lena * (lena >= lenb);
//	//_strrev(a);//编译器不让用
//	//_strrev(b);
//
//	//将字符转化为数字 要重新开一个int数组 因为后面计算是基于数字的  不是基于char的（ascii码）
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//
//	//先不考虑进位 直接相减
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = aa[i] - bb[i];
//		//result[i + 1] = 0;//防止最后一位有进位
//		//cout << i << " " << result[i] << endl;
//	}
//
//	//考虑进位 注意 只要小于零 借位自动为1
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = result[i] - carry[i];
//		if (result[i] < 0) {
//			carry[i + 1] = 1;
//		}
//		result[i] = (result[i] + 10) % 10;
//	}
//	int cnt = 0;
//	//最高位的0不输出
//	for (int i = lenmax - 1; i >= 0; i--) {
//		if (result[i] != 0) {
//			break;
//		}
//		else {
//			cnt++;
//		}
//	}
//	
//	//倒着输出
//	for (int i = lenmax - 1 - cnt; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}

//计算2的N次方
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 50;
//int a[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	int n;
//	cin >> n;
//	int carry = 0;
//	int temp;
//	a[0] = 1;
//	while (n--) {
//		for (int i = 0; i < 50; i++) {
//			temp = a[i] * 2 + carry;
//			carry = temp / 10;
//			a[i] = temp % 10;
//		}
//	}
//	int j;
//	for (j = 49; j >= 0; j--) {
//		if (a[j] != 0) {
//			break;
//		}
//	}
//	for (; j >= 0; j--) {
//		cout << a[j];
//	}
//	system("pause");
//	return 0;
//}

//大整数的因子
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 35;
//char ch[maxn];
//int m[maxn];
//int main() {
//	memset(ch, '0', sizeof(ch));
//	memset(m, 0, sizeof(m));
//	int left, temp, cnt = 0, flag = 1;
//	cin >> ch;
//	int len = strlen(ch);
//	for (int i = 0; i < len; i++) {
//		m[i] = ch[i] - '0';
//	}
//	for (int i = 2; i < 10; i++) {
//		left = 0;
//		for (int j = 0; j < len; j++) {
//			temp = m[j] + 10 * left;
//			left = temp % i;
//		}
//		if (left == 0) {
//			if (flag) {
//				cout << i;
//				flag = 0;
//			}
//			else {
//				cout << " " << i;
//			}
//			cnt++;
//		}
//	}
//	if (!cnt) {
//		cout << "none";
//	}
//	system("pause");
//	return 0;
//}

//求10000以内n的阶乘
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 35670;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	long long left, temp;//防止溢出
//	cin >> n;
//	m[0] = 1;
//	for (int i = 1; i <= n; i++) {
//		left = 0;
//		for (int j = 0; j < maxn; j++) {
//			temp = m[j] * i + left;
//			m[j] = temp % 10;
//			left = temp / 10;
//		}
//	}
//	int k;
//	for (k = maxn; k >= 0; k--) {
//		if (m[k] != 0) {
//			break;
//		}
//	}
//	for (; k >= 0; k--) {
//		cout << m[k];
//	}
//
//
//	system("pause");
//	return 0;
//}

//阶乘和
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 200;
//int m[maxn],sum[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(sum, 0, sizeof(sum));
//	int n, alt,carry;
//	long long left, temp;//防止溢出
//	cin >> n;
//	m[0] = 1;
//	for (int i = 1; i <= n; i++) {
//		left = 0;
//		for (int j = 0; j < maxn; j++) {
//			temp = m[j] * i + left;
//			m[j] = temp % 10;
//			left = temp / 10;
//		}
//		carry = 0;
//		for (int a = 0; a < maxn; a++) {
//			alt = sum[a] + m[a] + carry;
//			sum[a] = alt % 10;
//			carry = alt / 10;
//		}
//	}
//	int k;
//	for (k = maxn; k >= 0; k--) {
//		if (sum[k] != 0) {
//			break;
//		}
//	}
//	for (; k >= 0; k--) {
//		cout << sum[k];
//	}
//
//	system("pause");
//	return 0;
//}

//1.7编程基础之字符串
//统计数字字符个数 isdigit()
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//int main() {
//	int cnt = 0;
//	char x;
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	while (ss >> x) {
//		if (isdigit(x)) {
//			cnt++;
//		}
//		//cout << x;
//	}
//	cout << cnt;
//	system("pause");
//}

//找第一个只出现一次的字符
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 100000;
//char ch[maxn];
//int res[maxn];
//int main() {
//	memset(ch, '0', sizeof(ch));
//	memset(res, 0, sizeof(res));
//	bool flag = false;
//	cin >> ch;
//	int len = strlen(ch);
//	for (int i = 0; i < len; i++) {
//		res[ch[i] - '0'] = res[ch[i] - '0'] + 1;
//		//cout << ch[i] << " " << res[ch[i] - '0'] << endl;
//	}
//	for (int i = 0; i < len; i++) {
//		if (res[ch[i] - '0'] == 1) {
//			cout <<ch[i];
//			flag = true;
//			break;
//		}
//	}
//	if (!flag) {
//		cout << "no";
//	}
//	system("pause");
//}

//基因相关性
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 100000;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	double h;
//	int cnt = 0;
//	cin >> h;
//	cin >> a>>b;
//	int len = strlen(a);
//	for (int i = 0; i < len; i++) {
//		if (a[i] == b[i]) {
//			cnt++;
//		}
//	}
//	double real = double(cnt) / double(len);
//	if (real >= h) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	
//	system("pause");
//}

//石头剪子布 ???
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 1000;
//char a[maxn];
//char b[maxn];
//int main() {
//	int n;
//	cin >> n;
//	//bool flag = true;
//	for (int i = 0; i < n; i++) {
//		cin >> a;
//		cin >> b;
//		/*if (flag) {
//		flag = false;
//		}
//		else {
//		cout << endl;
//		}*/
//		if (a[0] == 'R'&&b[0] == 'S' || a[0] == 'S'&&b[0] == 'P' || a[0] == 'P'&&b[0] == 'R')
//			cout << "Player1" << endl;
//		if (b[0] == 'R'&&a[0] == 'S' || b[0] == 'S'&&a[0] == 'P' || b[0] == 'P'&&a[0] == 'R')
//			cout << "Player2" << endl;
//		if (a[0] == b[0])
//			cout << "Tie" << endl;
//
//
//	}
//	system("pause");
//	return 0;
//}

//输出亲朋字符串 ? cin读不了空格
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);//gets_s 和 gets
//	int len = strlen(a);
//	for (int i = 0; i < len -1; i++) {
//		//b[i] = int(a[i] - NULL) + int(a[i + 1] -NULL);//审题第一个字符的ASCII值加第二个字符的ASCII值
//		//cout << a[i] - NULL;
//		cout << char(a[i] + a[i + 1]);
//	}
//	cout << char(a[len - 1] + a[0]);
//	/*b[len - 1] = a[0] + a[len - 1];
//	for (int i = 0; i < len; i++) {
//		cout << char(b[i]);
//	}*/
//	system("pause");
//	return 0;
//}

//合法 C 标识符
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 25;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//	if (a[0] >= '0'&&a[0] <= '9') {
//		cout << "no";
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < len; i++) {
//		if ((a[i] >= '0'&&a[i] <= '9') || (a[i] <= 'Z'&&a[i] >= 'A') || (a[i] >= 'a'&&a[i] <= 'z')||a[i] == '_') {
//
//		}
//		else {
//			cout << "no";
//			system("pause");
//			return 0;
//		}
//	}
//	cout << "yes";
//	system("pause");
//	return 0;
//}

//配对碱基链
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 260;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (a[i] == 'A') {
//			cout << 'T';
//		}
//		if (a[i] == 'T') {
//			cout << 'A';
//		}
//		if (a[i] == 'G') {
//			cout << 'C';
//		}
//		if (a[i] == 'C') {
//			cout << 'G';
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//字符替换
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	char tar, nw;
//	cin >> a >> tar >> nw;
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (a[i] == tar) {
//			cout << nw;
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//密码翻译
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 90;
//char stan_l[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
//char stan_u[26] = { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z' };
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (isalpha(a[i])) {
//			if (a[i] >= 'a'&&a[i] <= 'z') {
//				if (a[i] == 'z') {
//					cout<<"a";
//				}
//				else {
//					for (int j = 0; j < 26; j++) {
//						if (stan_l[j] == a[i]) {
//							cout << stan_l[j + 1];
//							break;
//						}
//					}
//				}
//				
//			}
//			if (a[i] >= 'A'&&a[i] <= 'Z') {
//				if (a[i] == 'Z') {
//					cout << "A";
//				}
//				else {
//					for (int j = 0; j < 26; j++) {
//						if (stan_u[j] == a[i]) {
//							cout << stan_u[j + 1];
//							break;
//						}
//					}
//				}
//				
//			}
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//简单密码
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 210;
//char secret[26] = { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z' };
//char white[26] = { 'V','W','X', 'Y', 'Z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U' };
//
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (isalpha(a[i])) {
//			for (int j = 0; j < 26; j++) {
//				if (secret[j] == a[i]) {
//					cout << white[j];
//					break;
//				}
//			}
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//潜伏者 ??最开始只考虑了stan[secret]不能对应不同的原文 没有stan[0] = stan[1]这种情况
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char stan[26];
//char real[maxn];
//char secret[maxn];
//char now[maxn];
//int main() {
//	memset(stan, '0', sizeof(stan));
//	memset(secret, '0', sizeof(secret));
//	memset(real, '0', sizeof(real));
//	memset(now, '0', sizeof(now));
//	cin >> secret;
//	cin >> real;
//	cin >> now;
//	int len = strlen(secret);
//	int lenr = strlen(real);
//	if (len != lenr) {
//		cout << "Failed";
//		system("pause");
//		return 0;
//	}
//	int lenn = strlen(now);
//
//	for (int i = 0; i < len; i++) {
//		if (stan[secret[i] - 'A'] != '0') {
//			if (stan[secret[i] - 'A'] != real[i]) {
//				cout << "Failed";
//				system("pause");
//				return 0;
//			}
//		}
//		else {
//			stan[secret[i] - 'A'] = real[i];
//		}
//	}
//	for (int i = 0; i < 26; i++) {
//		for (int j = i + 1; j < 26; j++) {
//			if (stan[i] == stan[j]) {
//				cout << "Failed";
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	for (int i = 0; i < 26; i++) {
//		//cout << i << " " << stan[i] << endl;
//		if (stan[i] == '0') {
//			cout << "Failed";
//			system("pause");
//			return 0;
//		}
//	}
//	for (int i = 0; i < lenn; i++) {
//
//		cout << stan[now[i] - 'A'];
//	}
//
//	system("pause");
//	return 0;
//}

//加密的病历单
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 55;
//char stan[26];
//char real[maxn];
//char pr1[maxn];
//char pr2[maxn];
//char ans[maxn];
//int main() {
//	memset(stan, '0', sizeof(stan));
//	memset(pr1, '0', sizeof(pr1));
//	memset(pr2, '0', sizeof(pr2));
//	memset(ans, '0', sizeof(ans));
//	cin >> real;
//	int len = strlen(real);
//	
//	for (int i = 0; i < len; i++) {
//		if (real[i] == 'z') {
//			pr1[i] = 'c';
//		}
//		else if (real[i] == 'y') {
//			pr1[i] = 'b';
//			
//		}
//		else if (real[i] == 'x') {
//			pr1[i] = 'a';
//		}
//		else if (real[i] == 'Z') {
//			pr1[i] = 'C';
//		}
//		else if (real[i] == 'Y') {
//			pr1[i] = 'B';
//
//		}
//		else if (real[i] == 'X') {
//			pr1[i] = 'A';
//		}
//		else {
//			pr1[i] = real[i] + 3;//97-122
//			
//		}
//		//cout << pr1[i];
//	}
//	//cout << endl;
//	for (int i = 0; i < len; i++) {
//		pr2[i] = pr1[len - 1 - i];
//		//cout << pr2[i];
//	}
//	//cout << endl;
//	for (int i = 0; i < len; i++) {
//		if (pr2[i] <= 'z'&&pr2[i] >= 'a') {
//			ans[i] = pr2[i] - 32;
//		}
//		if (pr2[i] <= 'Z'&&pr2[i] >= 'A') {
//			ans[i] = pr2[i] + 32;
//		}
//		cout << ans[i];
//	}
//	system("pause");
//	return 0;
//}

//将字符串中的小写字母转换成大写字母
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char m[maxn];
//int main() {
//	memset(m, '0', sizeof(m));
//	gets_s(m);
//	int len = strlen(m);
//	
//	for (int i = 0; i < len; i++) {
//		if (m[i] >= 'a'&&m[i] <= 'z') {
//			cout <<char( m[i] - 32);
//		}
//		else {
//			cout << m[i];
//		}
//	}
//	
//	system("pause");
//	return 0;
//}


//大小写字母互换
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char m[maxn];
//int main() {
//	memset(m, '0', sizeof(m));
//	gets_s(m);
//	int len = strlen(m);
//	
//	for (int i = 0; i < len; i++) {
//		if (m[i] >= 'a'&&m[i] <= 'z') {
//			cout <<char( m[i] - 32);
//		}
//		else if (m[i] >= 'A'&&m[i] <= 'Z') {
//			cout << char(m[i] + 32);
//		}
//		else {
//			cout << m[i];
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//整理药名
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 25;
//char m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		memset(m, '0', sizeof(m));
//		cin>> m;
//		int len = strlen(m);
//		if (m[0] >= 'a'&&m[0] <= 'z') {
//			cout << char(m[0] - 32);
//		}
//		else {
//			cout << m[0];
//		}
//		for (int j = 1; j < len; j++) {
//			if (m[j] >= 'A'&&m[j] <= 'Z') {
//				cout << char(m[j] + 32);
//			}
//			else {
//				cout << m[j];
//			}
//		}
//		cout << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//忽略大小写的字符串比较
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 85;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	gets_s(a);
//	gets_s(b);
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int lenmax = lena * (lena >= lenb) + lenb * (lenb > lena);
//	int flag = -1;
//	
//	for (int i = 0; i < lenmax; i++) {
//		if (a[i] >= 'A'&&a[i] <= 'Z') {
//			a[i] = char(a[i] + 32);
//		}
//		if (b[i] >= 'A'&&b[i] <= 'Z') {
//			b[i] = char(b[i] + 32);
//		}
//		if (a[i] < b[i]) {
//			cout << "<";
//			system("pause");
//			return 0;
//		}
//		else if (a[i] > b[i]) {
//			cout << ">";
//			system("pause");
//			return 0;
//		}
//
//
//	}
//
//	cout << "=";
//
//	system("pause");
//	return 0;
//}

//字符串判等
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 85;
//
//int main() {
//	string linea;
//	string lineb;
//	getline(cin, linea);
//	getline(cin, lineb);
//	string a;
//	string b;
//	stringstream ssa(linea);
//	stringstream ssb(lineb);
//	char temp;
//	while (ssa >> temp) {
//		if (temp >= 'A'&&temp <= 'Z') {
//			temp = char(temp + 32);
//		}
//		a.push_back(temp);
//	}
//	while (ssb >> temp) {
//		if (temp >= 'A'&&temp <= 'Z') {
//			temp = char(temp + 32);
//		}
//		b.push_back(temp);
//	}
//	int lena = a.length();
//	int lenb = b.length();
//	if (lena != lenb) {
//		cout << "NO";
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < lena; i++) {
//		
//		if (a[i] != b[i]) {
//			cout << "NO";
//			system("pause");
//			return 0;
//		}
//		
//	}
//	cout << "YES";
//	system("pause");
//	return 0;
//}

//验证子串  数组做法
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 200;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnt = 0,temp;
//	if (lena < lenb) {
//		for (int i = 0; i < lenb; i++) {
//			cnt = 0;
//			temp = i;
//			for (int j = 0; j < lena; j++) {
//				if (b[temp] == a[j]) {
//					cnt++;
//					//cout << temp << " " << j << " " << cnt << endl;
//					temp++;
//				}
//				else {
//					break;
//				}
//			}
//			if (cnt == lena) {
//				cout << a << " is substring of " << b;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	else {
//		for (int i = 0; i < lena; i++) {
//			cnt = 0;
//			temp = i;//防止后面第二重循环时的++对第一重循环造成影响
//			for (int j = 0; j < lenb; j++) {
//				if (b[j] == a[temp]) {
//					//cout << temp << " " << j << " " << cnt << endl;
//					temp++;
//					cnt++;
//				}
//				else {
//					break;
//				}
//			}
//			if (cnt == lenb) {
//				cout << b << " is substring of " << a;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	
//	cout << "No substring";
//	system("pause");
//	return 0;
//}

//验证子串 调用函数
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 200;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//
//	if (strstr(a, b) != NULL) {
//		cout << b << " is substring of " << a;
//		system("pause");
//		return 0;
//	}
//	if (strstr(b, a) != NULL) {
//		cout << a << " is substring of " << b;
//		system("pause");
//		return 0;
//	}
//	
//
//	cout << "No substring";
//	system("pause");
//	return 0;
//}

//字符串移位包含问题 ? 审题 a,b不确定哪个长 哪个短
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	if (lenb > lena) {
//		swap(a, b);
//		swap(lena, lenb);
//	}
//	int cnt = 0;
//	int temp;
//	//cout << "lena: " << lena << endl;
//	for (int i = 0; i < lena; i++) {
//		cnt = 0;
//		temp = i;
//		//cout << "i: " << a[i] << endl;
//		for (int j = 0; j < lenb; j++) {
//			//cout << temp << ": " << a[temp] << " " << j << ": " << b[j] <<endl;
//
//			//cout << "temp: " << temp << endl;
//			if (temp == lena) {//若temp超出了lena 则置0 从第一个开始找
//				temp = 0;
//				j--;//因为这一步循环没有比较两个字符串但是又加了1 所以要先减去
//				//cout << "hhh" << endl;
//			}
//			else {
//				if (a[temp] == b[j]) {
//					cnt++;
//					//cout << i << " " << temp << " " << cnt << endl;
//					temp++;
//				}
//				else {
//					break;
//				}
//			}
//			//cout << " " << cnt << endl;
//		}
//		if (cnt == lenb) {
//			cout << "true";
//			system("pause");
//			return 0;
//		}
//	}
//
//	cout << "false";
//	system("pause");
//	return 0;
//}

////删除单词后缀
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//	//cout << len << endl;
//	if (a[len - 1] == 'r' &&a[len - 2] == 'e') {
//		//cout << "h";
//		for (int i = 0; i < len - 2; i++) {
//			//cout << i << endl;
//			cout << a[i];
//			
//		}
//	}
//	else if (a[len - 1] == 'y' &&a[len - 2] == 'l') {
//		for (int i = 0; i < len - 2; i++) {
//			cout << a[i];
//			
//		}
//	}
//	else if (a[len - 1] == 'g' &&a[len - 2] == 'n'&&a[len - 3] == 'i') {
//		for (int i = 0; i < len - 3; i++) {
//			cout << a[i];
//			
//		}
//	}
//	else {
//		for (int i = 0; i < len ; i++) {
//			cout << a[i];
//			
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//单词替换
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	string tar;
//	string nw;
//	
//	getline(cin, line);
//	cin >> tar >> nw;
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		if (temp == tar) {
//			cout << nw;
//		}
//		else {
//			cout << temp;
//		}
//		cout << " ";
//	}
//	system("pause");
//	return 0;
//}

//紧急措施
//#include <iostream>
//#include <string>
//using namespace std;
//string tar;
//string adr;
//string user;
//string pw;
//int main() {
//	cin >> tar;
//	int n;
//	int len;
//	bool flag = false;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> user >> pw >> adr;
//		if (adr == tar) {
//			cout << user << " ";
//			len = pw.length();
//			for (int j = 0; j < len; j++) {
//				if (pw[j] <= 'z' && pw[j] >= 'a') {
//					cout << char(pw[j] - 32);
//				}
//				else if (pw[j] <= 'Z' && pw[j] >= 'A') {
//					cout << char(pw[j] + 32);
//				}
//				else {
//					cout << pw[j];
//				}
//			}
//			cout << endl;//每输出一行要空行
//			flag = true;
//		}
//	}
//	if (!flag) {
//		cout << "empty";
//	}
//	system("pause");
//	return 0;
//}

//过滤多余的空格
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		cout << temp << " ";
//	}
//	system("pause");
//	return 0;
//
//}

//单词的长度
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	int len;
//	bool flag = true;
//	while (ss >> temp) {
//		len = temp.length();
//		if (flag) {
//			cout << len;
//			flag = !flag;
//		}
//		else {
//			cout << "," << len;
//		}
//	}
//	system("pause");
//	return 0;
//}

//最长最短单词
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	int len,min,max;
//	string mins;
//	string maxs;
//
//	ss >> temp;
//	len = temp.length();
//	if (temp[len - 1] == ',') {
//		len = len - 1;
//		temp.pop_back();
//	}
//	min = max = len;
//	mins = temp;
//	maxs = temp;
//	//cout << mins << endl;
//	while (ss >> temp) {
//		len = temp.length();
//		if (temp[len - 1] == ',') {
//			len = len - 1;
//			temp.pop_back();
//		}
//		if (len < min) {
//			min = len;
//			mins = temp;
//		}
//		if (len>max) {
//			max = len;
//			maxs = temp;
//		}
//	}
//	cout << maxs << endl << mins;
//	system("pause");
//	return 0;
//}

////字符串最大跨距
//#include <iostream>
//#include <string>
//using namespace std;
//string origin;
//string s;
//string s1, s2;
//int main() {
//
//
//	//我自己想的比较笨的方法
//	//cin >> origin;
//	//for (int i = 0; i < origin.length(); i++) {
//	//	if (origin[i] != ',') {
//	//		s.push_back(origin[i]);
//	//		//cout << s << endl;
//	//	}
//	//	else {
//	//		for (int j = i + 1; j < origin.length(); j++) {
//	//			if (origin[j] != ',') {
//	//				s1.push_back(origin[j]);
//	//			}
//	//			else {
//	//				for (int k = j + 1; k < origin.length(); k++) {
//	//					s2.push_back(origin[k]);
//	//				}
//	//				break;
//	//			}
//	//		}
//	//		break;
//	//	}
//
//	//}
//
//	getline(cin, s, ',');
//	getline(cin, s1, ',');
//	getline(cin, s2);
//	//cout << s << endl << s1 << endl << s2;
//	int len1 = s1.length();
//
//	int p1 = s.find(s1);//这里p1不能加len1 因为后面要判断是否为空
//	int p2 = s.rfind(s2);
//
//	if (p1 == -1 || p2 == -1 || p1 + len1 > p2) {//这里是>而不是>=
//		cout << -1;
//	}
//	else {
//		cout << p2 - p1 - len1;
//	}
//	system("pause");
//	return 0;
//}

////单词翻转 
//#include <iostream>
//#include <string>
//#include <vector>
//using namespace std;
//const int maxn = 500;
//vector<string> v(maxn);
//vector<string> space(maxn);
//string s;
//int main() {
//	getline(cin, s);
//	int start, end;
//	int flag = 1;
//	int num = 0;
//	//cout << s << endl;
//	for (int i = 0; i < s.length(); i++) {
//		if (s[i] == ' ') {
//			
//			//cout << s[i];
//			if (flag) {
//				num++;
//				flag = 0;
//			}
//			space[num].push_back(s[i]);
//		}
//		else {
//			//cout << "HH" << endl;
//			v[num].push_back(s[i]);
//			flag = 1;
//		}
//	}
//	for (int i = 0; i <= num; i++) {
//		for (int j = v[i].length() -1 ; j >=0; j--) {
//			cout << v[i][j];
//		}
//		cout<<space[i+1];
//	}
//	system("pause");
//	return 0;
//}


//单词倒排
//#include <iostream>
//#include <string>
//#include <vector>
//using namespace std;
//const int maxn = 500;
//vector<string> v(maxn);
//vector<string> space(maxn);
//string s;
//int main() {
//	getline(cin, s);
//	int start, end;
//	int flag = 1;
//	int num = 0;
//	//cout << s << endl;
//	for (int i = 0; i < s.length(); i++) {
//		if (s[i] == ' ') {
//			
//			//cout << s[i];
//			if (flag) {
//				num++;
//				flag = 0;
//			}
//			space[num].push_back(s[i]);
//		}
//		else {
//			//cout << "HH" << endl;
//			v[num].push_back(s[i]);
//			flag = 1;
//		}
//	}
//	for (int i = num; i>=0; i--) {
//		cout << v[i];
//		cout<<space[i];
//	}
//	system("pause");
//	return 0;
//}

//ISBN号码
//#include <iostream>
//#include <string>
//using namespace std;
//int main() {
//	string s1, s2, s3, tar;
//	getline(cin, s1, '-');
//	getline(cin, s2, '-');
//	getline(cin, s3, '-');
//	getline(cin, tar);
//	int sum = 0;
//	bool flag = true;
//	string str = s1 + s2 + s3;
//	for (int i = 0; i < 9; i++) {
//		sum = sum + (i + 1)*(str[i] - '0');
//	}
//	int res = sum % 11;
//	//cout << res << endl;
//	if (res != 10) {
//		if (res != tar[0] - '0') {
//			//cout << "hhh" << endl;
//			flag = false;
//		}
//	}
//	else {
//		if (tar[0] != 'X') {
//			//cout << "111" << endl;
//			flag = false;
//		}
//	}
//
//	if (flag) {
//		cout << "Right";
//	}
//	else {
//		if (res == 10) {
//			cout << s1 << "-" << s2 << '-' << s3 << "-X";
//		}
//		else {
//			cout << s1 << "-" << s2 << '-' << s3 << "-" << res;
//
//		}
//	}
//	system("pause");
//	return 0;
//}

//字符环
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s1, s2;
//	cin >> s1 >> s2;
//	int len1 = s1.length();
//	int len2 = s2.length();
//	int cnt = 0, max = 0;
//	for (int i = 0; i < len1; i++) {
//		
//		//cout << "HHH" << endl;
//		for (int j = 0; j < len2; j++) {
//			int tempi = i;
//			int tempj = j;
//			cnt = 0;
//			//cout<<"hhh " << (tempi) << ": " << s1[tempi] << " " << tempj << ": " << s2[tempj] << " " << cnt << endl;
//			while (s1[tempi] == s2[tempj] && cnt<min(len1,len2)) {
//				cnt++;
//				//cout << (tempi) << ": " << s1[tempi] << " " << tempj << ": " << s2[tempj] << " " << cnt << endl;
//				tempi = (tempi + 1) % len1;
//				tempj = (tempj + 1) % len2;
//			}
//			if (cnt > max) {
//				max = cnt;
//			}
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//字符串p型编码
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int cnt = 0;
//	char ch;
//	int temp;
//	for (int i = 0; i < s.length(); i++) {
//		ch = s[i];
//		while (ch == s[i]) {
//			i++;
//			cnt++;
//		}
//		i--;
//		cout << cnt << s[i];
//		cnt = 0;
//	}
//	system("pause");
//	return 0;
//}

//行程长度编码
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int cnt = 0;
//	char ch;
//	int temp;
//	for (int i = 0; i < s.length(); i++) {
//		s[i] = toupper(s[i]);
//	}
//	for (int i = 0; i < s.length(); i++) {
//		
//		ch = s[i];
//		while (ch == s[i]) {
//			i++;
//			cnt++;
//		}
//		i--;
//		cout <<"("<<s[i]<<","<<cnt<<")";
//		cnt = 0;
//	}
//	system("pause");
//	return 0;
//}

//判断字符串是否为回文
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int len = s.length();
//	for (int i = 0; i < len/ 2; i++) {
//		if (s[i] != s[len - i - 1]) {
//			cout << "no";
//			system("pause");
//			return 0;
//		}
//		
//	}
//	cout << "yes";
//	system("pause");
//	return 0;
//}

//回文子串
//#include <iostream>
//#include <algorithm>
//#include <string>
//#include <map>
//
//using namespace std;
//
//const int maxn = 250;
//multimap<int, string> m;
//int main() {
//	string s;
//	cin >> s;
//	bool flag;
//	int len = s.length();
//	int i, j, period;
//	for (period = 2; period <= len; period++) {//表示子串的长度
//		for (i = 0; i <= len - period; i++) {//带入特殊值验证是否取等号  起始位置
//			flag = true;
//			//cout << "hhh" << endl;
//			for (j = i; j < i + period; j++) { //判断是否是回文
//				//cout << i << " " << j << " " << period << endl;
//				//cout << j << " " << s[j] << " " << i + period - (j - i) - 1 << " " << s[i + period - (j - i) - 1] << endl;
//				if (s[j] != s[i+period-(j-i) - 1]) {
//					flag = false;
//					//cout << "h" << endl;
//					break;
//				}
//			}
//			//cout << flag << endl;
//			if (flag) {
//				cout << s.substr(i, period) << endl;
//			}
//		}
//		//cout << period << endl;
//	}
//	system("pause");
//	return 0;
//}

//回文子串 只有3分
//#include <iostream>
//#include <algorithm>
//#include <string>
//#include <map>
//
//using namespace std;
//
//const int maxn = 250;
//multimap<int, string> m;
//int main() {
//	string s;
//	cin >> s;
//	bool flag = false;
//	int len = s.length();
//	int cnt = -1;
//	int maxl = 0, minl = len;
//	for (int i = 0; i < len - 1; i++) {
//		for (int j = i + 1; j < len; j++) {
//
//			//cout << "hhh" << endl;
//			int tempi = i, tempj = j;
//			//cout << "hhh " << tempi << " " << s[tempi] << " " << tempj << " " << s[tempj] << endl;
//
//			flag = false;
//			while ((s[tempi] == s[tempj]) && (tempi <= tempj)) {
//				//cout <<tempi<<" "<<s[tempi]<<" "<<tempj<<" "<<s[tempj] << endl;
//				if (tempi + 1 == tempj) {
//					flag = true;
//					cnt++;
//				}
//				tempi++;
//				tempj--;
//				//cout << "hhh" << endl;
//
//			}
//
//			if (flag) {
//				//cout << i << " " << j << endl;
//				m.insert(pair<int, string >(j - i + 1, s.substr(i, j - i + 1)));
//				flag = false;
//				maxl = max(j - i + 1, maxl);
//				minl = min(j - i + 1, minl);
//			}
//		}
//	}
//
//
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		for (int i = minl; i <= maxl; i++) {
//			if (itr->first == i) {
//				cout << itr->second << endl;
//			}
//		}
//	}
//
//
//	system("pause");
//	return 0;
//}

//字符串的展开 自己做的 有很多bug  只能得4-6分 
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	int p1, p2, p3;
//	cin >> p1 >> p2 >> p3;
//	string s;
//	cin >> s;
//	int len = s.length();
//	bool flag[120] = { false };
//	//cout << len << endl;
//	for (int i = 0; i < len; i++) {
//
//		//先判断越界，否则会报错越界了
//		if (i >= 0 && i + 2 < len) {
//			if ((isalpha(s[i]) && isalpha(s[i + 2]) && s[i + 1] == '-') || (isdigit(s[i]) && isdigit(s[i + 2]) && s[i + 1] == '-')) {
//				if (s[i + 2] - s[i] == 1) {//相邻的可以省略-
//										   //cout << 1 << endl;
//					cout << s[i] << s[i + 2];
//					i = i + 2;
//				}
//				else if (int(s[i + 2] - s[i]) <= 0) {//后面比前面小 保留等号
//					if (!flag) {
//						cout << s[i];
//					}
//					cout << "-" << s[i + 2];
//					i = i + 2;
//				}
//				else {
//					//cout << i << ": " << s[i] << endl;
//					int period = s[i + 2] - s[i] - 1;//两者之间的间隔
//					if (!flag[i]) {
//						cout << s[i];
//						flag[i + 2] = true;
//					}
//					//cout << s[i];
//					//cout << s[i];//直接输出当前字符
//					if (p1 == 1) {
//						if (p3 == 1) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {//重复次数
//									if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i] + j + 32);
//									}
//									else if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i] + j);
//									}
//									else {
//										cout << s[i] + j - '0';
//										//cout << "i: "<<i<<" j: "<<j<< s[i] + j - '0' << endl;
//									}
//								}
//							}
//						}
//						else if (p3 == 2) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {
//									if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i + 2] - j);
//
//									}
//									else if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i + 2] - j + 32);
//									}
//									else {
//										cout << s[i + 2] - j - '0';
//									}
//								}
//							}
//						}
//
//					}
//					else if (p1 == 2) {
//						if (p3 == 1) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {//重复次数
//									if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i] + j);
//									}
//									else if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i] + j - 32);
//									}
//									else {
//										cout << s[i] + j - '0';
//									}
//								}
//							}
//						}
//						else if (p3 == 2) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {
//									if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i + 2] - j - 32);
//
//									}
//									else if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i + 2] - j);
//									}
//									else {
//										cout << s[i + 2] - j - '0';
//									}
//								}
//							}
//						}
//
//					}
//					else if (p1 == 3) {
//
//						for (int j = 1; j <= period; j++) {
//							for (int k = 0; k < p2; k++) {
//								cout << '*';
//							}
//						}
//
//					}
//					//cout << "i+2: "<<i+2 << endl;
//					cout << s[i + 2];
//					//cout << "2222" << endl;
//					flag[i + 2] = true;
//					//cout << "2222" << endl;
//					i = i + 1;
//				}
//
//
//
//			}
//			else {
//				//cout << "hhh" << endl;
//				if (!flag[i]) {
//					cout << s[i];
//				}
//
//			}
//		}
//
//		else {
//			if (!flag[i]) {
//				cout << s[i];
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//字符串的展开 网上的答案
//#include<iostream>
//#include<cstring>
//#include<algorithm> 
//using namespace std;
//int p1, p2, p3, len, sum;
//char a[30000], b[30000];
//int main()
//{
//	cin >> p1 >> p2 >> p3 >> a;
//	len = strlen(a);
//	for (int i = 0; i < len; i++)
//		if (a[i] == '-'&&i > 0 && i < strlen(a) - 1)//开头或结尾的-直接else输出 
//		{
//			if (a[i - 1] == '-' || a[i + 1] == '-') cout << '-';//几个-连在一起，直接输出- 
//			else if (a[i + 1] == a[i - 1] + 1) continue;//-两边ascll码是连续的，跳过- 
//			else if (a[i - 1] >= a[i + 1] || (a[i - 1] <= '9'&&a[i + 1] >= 'A')) cout << '-';//-两边是字符和数字或者没有按升序排列，输出-；因为字母的acsll码本来就大于数字的，所以只需要另判断左边是数字右边是字母即可 
//			else
//			{
//				int l = 0;
//				if (p1 == 1)
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)//枚举过程中字符型自动转化为整形 
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = tolower((char)j);//整形强制转换成字符型 
//					}
//				}
//				else if (p1 == 2)
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = toupper((char)j);
//					}
//				}
//				else
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = '*';
//					}
//				}
//				if (p3 == 2)
//					reverse(b, b + l);//数组翻转 
//				for (int j = 0; j < l; j++)
//					cout << b[j];
//			}
//		}
//		else cout << a[i];
//		system("pause");
//}

//字符串的展开 自己写的一次
//#include <iostream>
//#include <string>
//#include<algorithm> 
//using namespace std;
//const int maxn = 50000;
//char ch[maxn];
//int main() {
//	int p1, p2, p3;
//	string s;
//	cin >> p1 >> p2 >> p3 >> s;
//	int len = s.length();
//	for (int i = 0; i < len; i++) {
//		if (i > 0 && i < len - 1 &&s[i] =='-') {
//			if (s[i - 1] == '-'||s[i + 1] == '-') {//几个-连在一起，直接输出-   逻辑符号是|| 而不是&&
//				cout << '-';
//			}
//			else if (s[i+1] - s[i-1] == 1) {
//				continue;
//			}
//			else if (s[i + 1] <= s[i - 1] || (isalpha(s[i-1])&&isdigit(s[i+1]))|| (isalpha(s[i + 1]) && isdigit(s[i - 1]))) {
//				cout << '-';
//			}
//			else {
//				int cnt = 0;
//				if (p1 == 1) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = tolower(char(j));
//						}
//						
//					}
//				}
//				else if (p1 == 2) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = toupper(char(j));
//						}
//					}
//				}
//				else if (p1 == 3) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = '*';
//						}
//					}
//				}
//				if (p3 == 2) {
//					reverse(ch, ch + cnt);
//				}
//				for (int j = 0; j < cnt; j++) {
//					cout << ch[j];
//				}
//			}
//		}
//		else {
//			cout << s[i];
//		}
//	}
//	system("pause");
//	return 0;
//}

//1.8编程基础之多维数组
//矩阵交换行
//#include<iostream>
//using namespace std;
//int m[5][5];
//int main() {
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int x, y;
//	cin >> x >> y;
//	for (int i = 0; i < 5; i++) {
//		if (i == x-1) {
//			for (int j = 0; j < 5; j++) {
//				cout << m[y-1][j]<<" ";
//			}
//		}
//		else if (i == y-1) {
//			for (int j = 0; j < 5; j++) {
//				cout << m[x-1][j] << " ";
//			}
//		}
//		else {
//			for (int j = 0; j < 5; j++) {
//				cout << m[i][j] << " ";
//			}
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//同行列对角线的格子
//#include<iostream>
//using namespace std;
//const int maxn = 15;
//int m[maxn][maxn];
//int main() {
//	int n, row, col;
//	cin >> n >> row >> col;
//	for (int i = 1; i <= n; i++) {
//		cout << "(" << row << "," << i << ") ";
//	}
//	cout << endl;
//	for (int i = 1; i <= n; i++) {
//		cout << "(" << i << "," << col << ") ";
//	}
//	cout << endl;
//	for (int i = 1; i <= n; i++) {
//		if (i + (col - row) > n || i + (col - row) < 1) continue;
//		cout << "(" << i << "," << i + (col - row) << ") ";
//	}
//	cout << endl;
//	for (int i = n; i >= 1; i--) {
//		if ((col + row) - i > n || (col + row) - i < 1)continue;
//		cout << "(" << i << "," << (col + row) - i << ") ";
//	}
//
//	system("pause");
//	return 0;
//}

//计算矩阵边缘元素之和 ？考虑行向量和列向量
//#include<iostream>
//using namespace std;
//const int maxn = 100;
//int m[maxn][maxn];
//int main() {
//	int row, col;
//	cin >> row >> col;
//	for (int i = 0; i < row; i++) {
//		for (int j = 0; j < col; j++) {
//			cin >> m[i][j];
//		}
//	}
//	long long sum = 0;
//	for (int i = 0; i < col; i++) {
//		if (row - 1 != 0) {//判断单行
//			sum = sum + m[0][i] + m[row - 1][i];
//		}else{
//			sum = sum + m[0][i];
//		}
//	}
//	for (int i =1; i < row-1; i++) {
//		if (col - 1 != 0) {//判断单列
//			sum = sum + m[i][0] + m[i][col - 1];
//		}
//		else {
//			sum = sum + m[i][0] ;
//		}
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//错误探测 ？ 先判断正确的 剩下的都是错的
//#include<iostream>
//#include<cstring>//memset要包含头文件
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int row[maxn];
//int col[maxn];
//int main() {
//	memset(row, 0, sizeof(row));
//	memset(col, 0, sizeof(col));
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			row[i] = (row[i] + m[i][j]) %2;
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			col[i] = (col[i] + m[j][i])%2;
//		}
//	}
//	int ansr = -1, ansc = -1;
//	int cntr = 0, cntc = 0;
//	for (int i = 0; i < n; i++) {
//		
//		if (row[i] % 2 != 0) {
//			ansr = i;
//			cntr++;
//		}
//		if (col[i] % 2 != 0) {
//			ansc = i;
//			cntc++;
//		}
//	}
//	//先判断特殊的正确情况 剩下的情况都是错的
//	if (ansr == -1 && ansc == -1) {
//		cout << "OK";
//	}
//	else if(cntr == 1&&cntc ==1){
//		cout << ansr + 1 << " " << ansc + 1;
//	}
//	else  {
//		cout << "Corrupt";
//	}
//	system("pause");
//	return 0;
//}

//计算鞍点
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//using namespace std;
//const int maxn = 10;
//int m[maxn][maxn];//读矩阵
//int row[maxn];//存行最大值
//int col[maxn];//存列最大值
//int main() {
//	memset(m, 0, sizeof(0));
//	memset(row, 0, sizeof(row));
//	memset(col, 0, sizeof(col));
//	int n = 5;
//	int ansr[5], ansc[5];//其实并没有什么用 存每行最大值的列坐标 每列最小值的行坐标
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (j == 0) {
//				row[i] = m[i][j];
//				ansr[i] = j;
//				//cout << i + 1 << " " << row[i] << endl;
//
//			}
//			else {
//				//cout << i + 1 << " " << row[i] << endl;
//				if (row[i] < m[i][j]) {
//					row[i] = m[i][j];
//					ansr[i] = j;
//				}
//			}
//		}
//		//cout << i + 1 << " " << ansr[i] <<" "<<row[i]<< endl;
//	}
//	//cout << ansr[0] << " " << ansr[1] << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (j == 0) {
//				col[i] = m[j][i];
//				ansc[i] = j;
//			}
//			else {
//				if (col[i] > m[j][i]) {
//					col[i] = m[j][i];
//					ansc[i] = j;
//				}
//			}
//		}
//		//cout << i + 1 << " " << ansc[i] << " " << col[i] << endl;
//	}
//	bool flag = false;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//
//			if (row[i] == col[j]) {
//				cout << i + 1 << " " << j + 1 << " " << row[i];
//				flag = true;
//			}
//		}
//	}
//	if (!flag) {
//		cout << "not found";
//	}
//
//	system("pause");
//	return 0;
//}

//图像相似度
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int m1[maxn][maxn];
//int m2[maxn][maxn];
//int main() {
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int k, n, cnt = 0;
//	cin >> k >> n;
//	for (int i = 0; i < k; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < k; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//			if (m1[i][j] == m2[i][j]) {
//				cnt++;
//			}
//		}
//	}
//	cout << fixed << setprecision(2) << double(cnt) / (n * k ) *100;
//	system("pause");
//	return 0;
//}

//矩阵归零消减序列和 自己写的只有1分  之后把输出位置调整到一开始就可以了 ？
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<vector>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int ans[maxn];
//int tempr[maxn];
//int tempc[maxn];
//int m1[maxn][maxn];
//int m2[maxn][maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(ans, 0, sizeof(ans));
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	//cout << m[2][2] << endl;
//	for (int r = 0; r < n ; r++) {
//		cout << m[2][2] << endl;
//		memset(m1, 0, sizeof(m1));
//		memset(m2, 0, sizeof(m2));
//		for (int i = 1; i <= n - r; i++) {//求每行最小值
//			tempr[i] = m[i][1];
//			for (int j = 1; j <= n - r; j++) {
//				tempr[i] = min(tempr[i], m[i][j]);
//				//cout << j << " " << tempc[j] << endl;
//			}
//			//cout << i << " " << tempr[i] << endl;
//
//		}
//		for (int i = 1; i <= n - r; i++) {//减去最小值
//			for (int j = 1; j <= n - r; j++) {
//				m[i][j] = m[i][j] - tempr[i];
//				//cout << m[i][j] << " ";
//			}
//			//cout << endl;
//		}
//		for (int i = 1; i <= n - r; i++) {//每列最小值
//			tempc[i] = m[1][i];
//			for (int j = 1; j <= n - r; j++) {
//				tempc[i] = min(tempc[i], m[j][i]);
//				//cout << j << " " << tempc[j] << endl;
//			}
//			//cout << i << " " << tempr[i] << endl;
//		}
//		for (int i = 1; i <= n - r; i++) {//减去最小值
//			for (int j = 1; j <= n - r; j++) {
//				m[j][i] = m[j][i] - tempc[i];
//			}
//
//		}
//		/*for (int i = 1; i <= n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//	/*	if (r < n - 2) {
//			cout << m[2][2] << endl;
//		}
//		else {
//			
//		}*/
//		
//	
//		for (int i = 2; i < n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//				m[i][j] = m[i + 1][j];
//			}
//		}
//		for (int i = 2; i < n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//				m[j][i] = m[j][i + 1];
//			}
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//矩阵归零消减序列和 答案 简单
//#include <iostream>
//using namespace std;
//const int maxn = 110;
//int main() {
//	int n; cin >> n;
//	int a[maxn][maxn] = { 0 }, min = 1e9;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> a[i][j];
//		}
//	}
//	for (; n; n--) {
//		cout << a[1][1] << endl;
//		for (int i = 0; i < n; i++) {
//			min = 1e9;
//			for (int j = 0; j < n; j++)min > a[i][j] ? min = a[i][j] : min;//取行最小值
//			for (int j = 0; j < n; j++) { a[i][j] -= min; if (a[i][j] < 0)a[i][j] = 0; }//每行减去行最小值
//		}
//		for (int i = 0; i < n; i++) {
//			min = 1e9;
//			for (int j = 0; j < n; j++)min > a[j][i] ? min = a[j][i] : min;//取列最小值
//			for (int j = 0; j < n; j++) { a[j][i] -= min; if (a[j][i] < 0)a[j][i] = 0; }//每列减去行最小值
//		}
//		if (n != 2) {
//			for (int i = 0; i < n; i++)for (int j = 1; j < n; j++)a[i][j] = a[i][j + 1];//删除第二行
//			for (int i = 0; i < n; i++)for (int j = 1; j < n; j++)a[j][i] = a[j + 1][i];//删除第二列
//		}
//	}
//	system("pause");
//	return 0;
//}

//矩阵加法
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//long long  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int m, n;
//	cin >> m>>n;
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//			m2[i][j] += m1[i][j];
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//矩阵乘法
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//long long  m2[maxn][maxn];
//long long ans[maxn][maxn];
//int main() {
//	memset(ans, 0, sizeof(ans));
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int n, m, k;
//	cin >> n >> m >> k;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < k; j++) {
//			cin >> m2[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {//A 行
//		for (int j = 0; j < k; j++) {// B 列
//			for (int p = 0; p < m; p++) {
//				ans[i][j] += m1[i][p] * m2[p][j];
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < k; j++) {
//			cout << ans[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//矩阵转置
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int n, m;
//	cin >> n >> m ;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m1[j][i] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//图像旋转
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int n, m;
//	cin >> n >> m;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = n-1; j >=0; j--) {
//			cout << m1[j][i] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//变幻的矩阵
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 50;
//char  m1[maxn][maxn];
//char  m2[maxn][maxn];
//char ans1[maxn][maxn];
//char ans2[maxn][maxn];
//char ans3[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	memset(ans1, 0, sizeof(ans1));
//	memset(ans2, 0, sizeof(ans2));
//	memset(ans3, 0, sizeof(ans3));
//
//	int n;
//	cin >> n;
//	//cout << n << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//			//cout << i << " " << j << endl;
//		}
//	}
//	//cout << "hhh" << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//		}
//	}
//	
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			ans1[i][j] = m1[n - j - 1][i];
//			ans2[i][j] = m1[j][n - i - 1];
//			ans3[i][j] = m1[n - i - 1][n - j - 1];
//			//cout << ans3[i][j] << " ";
//		}
//		//cout << endl;
//	}
//	int flag[4] = {1,1,1,1};
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (ans1[i][j] != m2[i][j]) {
//				flag[0] = 0;
//			}
//			if (ans2[i][j] != m2[i][j]) {
//				flag[1] = 0;
//			}
//			if (ans3[i][j] != m2[i][j]) {
//				flag[2] = 0;
//			}
//			if (m1[i][j] != m2[i][j]) {
//				//cout << m1[i][j] << " " << m2[i][j] << endl;
//				flag[3] = 0;
//			}
//		}
//	}
//	bool sus = false;
//	for (int i = 0; i < 4; i++) {
//		//cout << flag[i] << endl;
//		if (flag[i]) {
//			cout << i + 1;
//			sus = true;
//			break;
//		}
//	}
//	if (!sus) {
//		cout << 5;
//	}
//	system("pause");
//	return 0;
//}

//图像模糊处理  判断单行
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int  m1[maxn][maxn];
//int  m2[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//
//	int n, m;
//	cin >> n >> m;
//	//cout << n << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//			//cout << i << " " << j << endl;
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		cout << m1[0][i] << " ";
//	}
//	cout << endl;
//	for (int i = 1; i < n - 1; i++) {
//		for (int j = 0; j < m; j++) {
//			if (j == 0) {
//				cout << m1[i][0] << " ";
//
//			}
//			else if (j == m - 1) {
//				cout << m1[i][m - 1];
//
//			}
//			else {
//				//cout << "hhh: " << m1[i][j] << " " << m1[i - 1][j] << " " << m1[i + 1][j] << " " << m1[i][j - 1] << " " << m1[i][j + 1] << endl;
//				double a = (double(m1[i][j]) + double(m1[i - 1][j]) + double(m1[i + 1][j]) + double(m1[i][j - 1]) + double(m1[i][j + 1])) / 5.0;
//				int ans = floor(a + 0.5);
//				cout << ans << " ";
//				//cout << a << " ";
//			}
//
//		}
//		cout << endl;
//		//cout << endl;
//	}
//	if (n != 1) {
//		for (int i = 0; i < m; i++) {
//			cout << m1[n - 1][i] << " ";
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//扫雷游戏地雷数计算
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];
//int  m2[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//
//	int n, m;
//	cin >> n >> m;
//	//cout << n << endl;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++) {
//			if (m1[i][j] == '*') {//不用判断边界条件 因为边界以为的都初始化为0  只要不为*就不加
//				cout << m1[i][j] ;
//			}
//			else {
//				if (m1[i - 1][j] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i - 1][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i - 1][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				cout << m2[i][j] ;
//			}
//
//		}
//		cout << endl;
//		//cout << endl;
//	}
//	
//	system("pause");
//	return 0;
//}

//细菌的繁殖与扩散 ？？自己写的思路不对  抓住核心 以每个元素为对象写 而不是以每个元素扩散影响其他元素来写！！
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 11;
//int  m1[maxn][maxn];//前一天的状态
//int  m2[maxn][maxn];//后一天的状态 扩散之后的状态
////int  m3[maxn][maxn];//记录前一天的状态
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	//memset(m3, 0, sizeof(m3));
//	int r[8] = { 0,0,1,-1,-1,1,-1,1 };
//	int c[8] = { 1,-1,0,0,1,1,-1,-1 };
//
//	int n, m;
//	cin >> n >> m;
//	m1[5][5] = n;
//	//m2[5][5] = n;
//	/*for (int i = 1; i <= 9; i++) {
//		for (int j = 1; j <= 9; j++) {
//			cout << m1[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	for (int d = 1; d <= m; d++) {
//		for (int i = 1; i <= 9; i++) {
//			for (int j = 1; j <= 9; j++) {
//				m2[i][j] = m1[i][j] * 2;
//				for (int k = 0; k < 8; k++) {
//					m2[i][j] = m2[i][j] + m1[i+r[k]][j+c[k]];
//				}
//			}
//		}
//		for (int o = 1; o <= 9; o++) {
//			for (int p = 1; p <= 9; p++) {
//				m1[o][p] = m2[o][p];
//			}
//		}
//		/*cout << "day" << d << endl;
//		for (int i = 1; i <= 9; i++) {
//			for (int j = 1; j <= 9; j++) {
//				cout << m2[i][j] << " ";
//			}
//			cout << endl;
//		}
//		cout << endl;*/
//	}
//	for (int i = 1; i <= 9; i++) {
//		for (int j = 1; j <= 9; j++) {
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//矩阵剪刀石头布 对于矩阵一定要考虑单行单列
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];//前一天的状态
//char  m2[maxn][maxn];//后一天的状态 扩散之后的状态
//					
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int dirr[4] = { 1,-1,0,0 };// 下 上 右 左
//	int dirc[4] = { 0,0,1,-1 };
//
//	int r, c, n;
//	cin >> r >> c >> n;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	if(r==1&&c==1){
//		cout << m1[1][1];
//		system("pause");
//		return 0;
//	}
//	for (int d = 0; d < n; d++) {
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				int flag = 0;
//				for (int k = 0; k < 4; k++) {
//
//					if (isalpha(m1[i + dirr[k]][j + dirc[k]])) {
//						if (!flag) {
//							if ((m1[i][j] == 'R'&&m1[i + dirr[k]][j + dirc[k]] == 'P') || (m1[i][j] == 'S'&&m1[i + dirr[k]][j + dirc[k]] == 'R') || (m1[i][j] == 'P'&&m1[i + dirr[k]][j + dirc[k]] == 'S')) {
//								m2[i][j] = m1[i + dirr[k]][j + dirc[k]];
//								flag = 1;
//							}
//							else {
//								
//								m2[i][j] = m1[i][j];
//								
//							}
//							//cout << k << " " << i << " " << j << " " << m1[i][j] << " " << m1[i + dirr[k]][j + dirc[k]] << " " << m2[i][j] << endl;
//						}	
//					}
//				}
//			}
//		}
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				m1[i][j] = m2[i][j];
//			}
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cout << m1[i][j];
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//最好的草
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];//前一天的状态
//char  m2[maxn][maxn];//后一天的状态 扩散之后的状态
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int dirr[4] = { 1,-1,0,0 };// 下 上 右 左
//	int dirc[4] = { 0,0,1,-1 };
//
//	int r, c, n;
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	if (r == 1 && c == 1) {
//		cout << m1[1][1];
//		system("pause");
//		return 0;
//	}
//	int cnt = 0;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (m2[i][j] != '1'&&m1[i][j] == '#') {
//				//cout << i << " " << j << endl;
//				cnt++;
//				for (int k = 0; k < 4; k++) {
//					m2[i][j] = '1';
//					if (m2[i + dirr[k]][j + dirc[k]] != '1'&&m1[i + dirr[k]][j + dirc[k]] == '#') {
//						m2[i + dirr[k]][j + dirc[k]] = '1';
//					}
//				}
//				/*for (int i = 1; i <= r; i++) {
//					for (int j = 1; j <= c; j++) {
//						if (m2[i][j] == '1') {
//							cout << m2[i][j] << " ";
//
//						}
//						else {
//							cout << 0 << " ";
//						}
//					}
//					cout << endl;
//				}
//				cout << endl;*/
//			}
//			
//		}
//	}
//		cout << cnt;
//		system("pause");
//		return 0;
//	}


//肿瘤面积  注意边界的判定包括出界和遇到255两种情况 
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 1010;
//int  m1[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int  n;
//	int zs[2], zx[2], ys[2], yx[2];
//	memset(zs, 0, sizeof(zs));
//	memset(zx, 0, sizeof(zx));
//	memset(ys, 0, sizeof(ys));
//	memset(yx, 0, sizeof(yx));
//
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m1[i][j];
//
//		}
//	}
//	if (n == 1 && m1[1][1] == 255) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	//for (int i = 1; i <= n; i++) {
//	//	for (int j = 1; j <= n; j++) {
//	//		cout<< m1[i][j]<<" ";
//	//	}
//	//	cout << endl;
//	//}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			//cout << m1[i][j] << " ";
//			if (m1[i][j] == 0) {
//				//cout << "hhh" << endl;
//
//				zs[0] = i;
//				zs[1] = j;
//				zx[1] = j;
//				//cout << zs[0] << " " << zs[1] << endl;
//				while (j++) {
//					if (m1[i][j] == 255||j==n+1) {
//						j--;
//						ys[0] = i;
//						ys[1] = j;
//						while (i++) {
//							if (m1[i][j] == 255 || i == n + 1) {
//								i--;
//								yx[0] = i;
//								yx[1] = j;
//								zx[0] = i;
//								break;
//							}
//						}
//						break;
//					}
//				}
//				break;
//			}
//		}
//
//	}
//	int ans = (yx[0] - zs[0] - 1)*(yx[1] - zs[1] - 1);
//	cout << ans;
//	system("pause");
//	return 0;
//}

//肿瘤检测  思路就按照题目意思来 不要自己想算法！！！
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int  n, area = 0, per = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			if (m1[i][j] <= 50) {
//				area++;
//				if (i == 1 || i == n || j == 1 || j == n || m1[i - 1][j] > 50 || m1[i + 1][j] > 50 || m1[i][j - 1] > 50 || m1[i][j + 1] > 50) {
//					per++;
//				}
//			}
//		}
//	}
//	cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//反反复复
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn];
//char  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	char c;
//	int cnt = 0;
//	while (cin >> c) {
//		m1[cnt++] = c;
//	}
//	//cout << cnt << endl;
//	int len = cnt / n;
//	//cout << "hh " << len << endl;
//	for (int i = 0; i < len; i++) {
//		for (int j = 0; j < n; j++) {
//			//cout << i * len + j << " ";
//			if (i % 2 == 0) {
//				m2[i][j] = m1[i*n + j];
//			}
//			else {
//				m2[i][n - j - 1] = m1[i*n + j];
//			}
//		}
//
//	}
//	/*for (int i = 0; i < len; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m2[i][j];
//		}
//		cout << endl;
//	}*/
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < len; j++) {
//			cout << m2[j][i];
//		}
//		
//	}
//	//cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//二维数组右上左下遍历  
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  r, c;
//	cin >> r >> c;
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//
//	for (int i = 0; i < c; i++) {//第一行起点 上三角
//		for (int j = 0; j < r; j++) {
//			if ((i - j) >= 0) {
//				cout << m1[j][i - j] << endl;
//			}
//		}
//	}
//
//	for (int i = 1; i < r; i++) {//最后一列起点 下三角
//		for (int j = 0; j < c; j++) {
//			if ((i + j) < r) {
//				cout << m1[i + j][c - j - 1] << endl;
//			}
//		}
//	}
//	//for (int i = 1; i < r; i++) {//最后一列起点 下三角
//	//	for (int j = c - 1; j >= 0; j--) {
//	//		if ((i + c - j - 1) < r) {//c-r +j <=i
//	//			cout << m1[i + c - j - 1][j] << endl;
//	//		}
//	//	}
//	//}
//	//cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//神奇的幻方
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	n = 2 * n - 1;
//	int num = pow(n, 2);
//	int i = 1, j = n/2+1;
//	int cnt = 1;
//	//cout << n << endl;
//	while (num--) {
//		
//		m1[i][j] = cnt;
//		//cout << i << " " << j <<" "<< m1[i][j]<<endl;
//		cnt++;
//		if ((i == 1 && j == n) || (m1[i - 1][j + 1])) {
//			//cout << i << " " << j << endl;
//			i = i + 1;
//		}
//		else if (i == 1) {
//			i = n;
//			j = j + 1;
//		}
//		else if (j == n) {
//			j = 1;
//			i = i - 1;
//		}
//		else {
//			i = i - 1;
//			j = j + 1;
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cout << m1[i][j] << " ";
//		}
//		cout<<endl;
//	}	
//	system("pause");
//	return 0;
//}

//二维数组回形遍历
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  r,c;
//	cin >> r>>c;
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	int cnt = r * c;
//	int i = 0, j = 0;
//	int round = 0;
//	cout << m1[i][j] << endl;
//	cnt--;
//	while (cnt) {
//		while (cnt&&j+1<c-round) {
//			j++;
//			cnt--;
//			cout << m1[i][j]<<endl;
//			//system("pause");
//		}
//		while (cnt&&i + 1 < r - round) {
//			i++;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		while (cnt&&j - 1 >= 0+ round) {
//			j--;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		round++;
//		while (cnt&&i - 1 >= 0+round) {
//			i--;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//蛇形填充数组  
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	int v = 1;
//	int cnt = 2 * n - 1;
//	for (int sum = 0; sum < cnt; sum++) {
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//				if (i + j == sum) {
//					//cout << sum << " " << i << " " << j << " " << v << endl;
//
//					if (sum % 2 == 1) {
//						m2[i][j] = v;
//						v++;
//					}
//					else {
//						m2[j][i] = v;
//						v++;
//					}
//				}
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//螺旋加密
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 3000;
//int   m1[maxn];
//int  m2[maxn];
//int m3[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	memset(m3, 0, sizeof(m3));
//	int  r, c;
//	cin >> r >> c;
//	string s;
//	getline(cin, s);//s的第一个字符是空格
//	//cout << s;
//	int len = s.size() - 1;
//	for (int i = 1; i <= len; i++) {//s的第一个字符是空格
//		if (s[i] == ' ') {
//			m1[i] = 0;
//		}
//		else {
//			m1[i] = s[i] - 'A' + 1;
//		}
//	}
//	/*for (int i = 1; i <= len; i++) {
//		cout << m1[i] << " ";
//	}*/
//	for (int i = 1; i <= len; i++) {
//		for (int j = (i - 1) * 5 + 5; j > (i - 1) * 5; j--) {
//			m2[j] = m1[i] % 2;
//			m1[i] = m1[i] / 2;
//			//cout << m2[j];
//		}
//		//cout << endl;
//	}
//	int cnt = r * c;
//	for (int i = len * 5 + 1; i <= cnt; i++) {
//		m2[i] = 0;
//		//cout << i << " " << m2[i] << endl;
//	}
//
//	/*for (int i = 1; i <= cnt; i++) {
//		cout << m2[i];
//	}
//	cout << endl;*/
//
//	//cout << cnt << endl;
//	int i = 1, j = 1;
//	int cur = 1;
//	int round = 0;
//	m3[i][j] = m2[cur++];
//	cnt--;
//	//cout << m3[i][j];
//	while (cnt) {
//		//cout << cnt << endl;
//		while (cnt&&j+1 <= c - round) {//思想：先预判能不能走 。如果先走当前步再判断，当判断为false的时候j已经越界了
//			j++;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//			
//		}
//		//system("pause");
//		while (cnt&&i+1 <= r - round) {
//			i++;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//			
//		}
//		//system("pause");
//		while (cnt&&j-1 >= 1 + round) {
//			j--;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//			
//		}
//		//system("pause");
//		round++;
//		while (cnt&&i-1 >= 1 + round) {
//			i--;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//			
//		}
//		//system("pause");
//	}
//
//	for (int h = 1; h <= r; h++) {
//		for (int g = 1; g <= c; g++) {
//			cout << m3[h][g];
//		}
//		//cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//#include<iostream>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	int n,cnt=0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		cnt++;
//	}
//	int tar;
//	bool flag = false;
//	cin >> tar;
//	for (int i = 0; i < cnt; i++) {
//		if (m[i] == tar) {
//			cout << i + 1;
//			flag = true;
//			break;
//		}
//	}
//	if (!flag) {
//		cout << -1;
//	}
//	system("pause");
//	return 0;
//}

//输出最高分数的学生姓名
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//const int maxn = 10010;
//map<int, string, greater<int>> m;
//int main() {
//	int n, cnt = 0;
//	cin >> n;
//	int score;
//	string name;
//	for (int i = 0; i < n; i++) {
//		cin >> score;
//		cin >> name;
//		m.insert(pair<int, string>(score, name));
//	}
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		cout << itr->second << endl;
//		break;
//	}
//	system("pause");
//	return 0;
//}

//不高兴的津津
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//const int maxn = 7;
//int m[maxn];
//int main() {
//	int x, y;
//	int big = 0, d = -1;
//	for (int i = 0; i < 7; i++) {
//		cin >> x >> y;
//		m[i] = x + y;
//		if (m[i] > 8 && m[i] > big) {
//			big = m[i];
//			d = i+1;
//		}
//	}
//	if (d == -1) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < 7; i++) {
//		if (big == m[i]) {
//			cout << i + 1;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}

//谁拿了最多奖学金
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//multimap<int, string,greater<int>> multim;
//int main() {
//	int n;
//	cin >> n;
//	string name;
//	int score, classscore;
//	char leader, west;
//	int paper, sum = 0, tot = 0;
//	for (int i = 0; i < n; i++) {
//		sum = 0;
//		cin >> name >> score >> classscore >> leader >> west>>paper;
//		if (score > 80 && paper >= 1) {
//			sum += 8000;
//		}
//		//cout << name << " " << sum << endl;
//		if (score > 85 && classscore > 80) {
//			sum += 4000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (score > 90) {
//			sum += 2000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (score > 85 && west == 'Y') {
//			sum += 1000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (classscore > 80 && leader == 'Y') {
//			sum += 850;
//		}
//		//cout << name << " " << sum << endl;
//		tot += sum;
//		multim.insert(pair<int, string>(sum, name));
//	}
//	for (auto itr = multim.begin(); itr != multim.end(); itr++) {
//		cout << itr->second << endl<< itr->first << endl<<tot;
//		break;
//	}
//	system("pause");
//	return 0;
//}

//最大值和最小值的差
//#include<iostream>
//#include<map>
//#include<cstring>
//#include<limits.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//	int minv=INT_MAX, maxv=INT_MIN;//
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] < minv) {
//			minv = m[i];
//		}
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//	}
//	cout << maxv - minv;
//	system("pause");
//	return 0;
//}

//笨小猴
//#include<iostream>
//#include<map>
//#include<string>
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//using namespace std;
//string s;
//map<char, int>	m;
//int main() {
//
//	cin >> s;
//	for (int i = 0; i < s.length(); i++) {
//		map<char, int>::iterator iter;
//		iter = m.find(s[i]);
//		if (iter != m.end()) {
//			m[s[i]]++;
//		}
//		else {
//			m.insert(pair<char, int>(s[i], 1));
//		}
//	}
//	int minv = INT_MAX, maxv = INT_MIN;
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		//cout << itr->first << " " << itr->second << endl;
//		if (itr->second > maxv) {
//			maxv = itr->second;
//		}
//		if (itr->second < minv) {
//			minv = itr->second;
//		}
//	}
//	int v = maxv - minv;
//	if (v == 0||v==1) {
//		cout << "No Answer" << endl << 0;
//		system("pause");
//		return 0;
//	}
//
//	bool flag = true;
//	for (int i = 2; i < ceil(v / 2); i++) {
//		if (v%i == 0) {
//			flag = false;
//			break;
//		}
//	}
//	if (flag) {
//		cout << "Lucky Word" << endl << v;
//	}
//	else {
//		cout << "No Answer" << endl << 0;
//	}
//
//	//cout << v << endl;
//	system("pause");
//	return 0;
//}

//不与最大数相同的数字之和
//#include<iostream>
//#include<map>
//#include<string>
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//using namespace std;
//const int maxn = 110;
//long long m[maxn];
//int main() {
//	int n, maxv = INT_MIN;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//	}
//	long long sum = 0;
//	for (int i = 0; i < n; i++) {
//		if (m[i] != maxv) {
//			sum += m[i];
//		}
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//白细胞计数
//#include<iostream>
//#include<map>
//#include<string>
//#include<cmath>//abs()
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//#include<stdlib.h>
//using namespace std;
//const int maxn = 310;
//double m[maxn];
//double var[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	memset(var, 0, sizeof(0));
//	int n;
//	cin >> n;
//	cin >> m[0];
//	//cout << m[0] << endl;
//	double minv = m[0], maxv = m[0];
//	int posmin= 0, posmax=0;
//	for (int i = 1; i < n; i++) {
//		cin >> m[i];
//		//cout <<i<<" "<< m[i] << endl;
//		if (m[i] > maxv) {
//			maxv = m[i];
//			posmax = i;
//		}
//		if (m[i] < minv) {
//			minv = m[i];
//			posmin=i;
//		}
//	}
//	if (posmax == posmin) {
//		cout << fixed << setprecision(2) << m[0] << " " << fixed << setprecision(2) << 0.00;
//		system("pause");
//		return 0;
//	}
//	//cout << "hhh" << endl;
//	double sum = 0.0;
//	for (int i = 0; i < n; i++) {
//		if (i != posmax && i != posmin) {
//			sum += m[i];
//		}
//	}
//	double av = sum / double(n - 2);
//	double maxva = 0.0;
//	for (int i = 0; i < n; i++) {
//		if (i != posmax && i != posmin) {
//			double cha;
//			if (m[i] > av) {
//				cha = m[i] - av;
//			}
//			else {
//				cha = av - m[i];
//			}
//			if (cha > maxva) {
//				maxva = cha;
//			}
//		}
//	}
//	cout << fixed << setprecision(2) << av << " " << fixed << setprecision(2) << maxva;
//	system("pause");
//	return 0;
//}

//直方图
//#include<iostream>
//#include<limits.h>
//#include<map>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//map<int, int> ans;
//int main(){
//	int n,maxv = INT_MIN;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//		if (m[i] <= maxv) {
//			map<int, int>::iterator iter;
//			iter = ans.find(m[i]);
//			if (iter != ans.end()) {
//				ans[m[i]]++;
//			}
//			else {
//				ans.insert(pair<int, int>(m[i], 1));
//			}
//		}
//	}
//	int i = 0;
//	for (auto itr = ans.begin(); itr != ans.end(); itr++) {
//		while (itr->first != i) {
//			cout << 0 << endl;
//			i++;
//		}
//		cout << itr->second << endl;
//		i++;
//	}
//	system("pause");
//	return 0;
//}

//找最大数序列
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//vector<vector<int>> vv;
//vector<int> v;
//int main() {
//	string tempn;
//	int n=0;
//	getline(cin, tempn);
//	//cout << tempn.size() << endl;
//	for (int i = 0; i < tempn.size(); i++) {
//		n = tempn[i] - '0' + n * 10;
//	}
//	//cout << n;
//	string s;
//	int t=0;
//	for (int i = 0; i < n; i++) {
//		v.clear();
//		getline(cin , s);
//		for (int j = 0; j < s.size(); j++) {
//			if (s[j] != ',') {
//				t = t * 10 + s[j] - '0';
//			}
//			else {
//				//cout << t << endl;
//				v.push_back(t);
//				t = 0;
//			}
//		}
//		v.push_back(t);
//		t = 0;
//		vv.push_back(v);
//		//system("pause");
//		
//	}
//	int maxv = vv[0][0];
//	//cout << maxv;
//	for (int i = 0; i<vv.size(); i++) {
//		for (int j = 0; j < vv[i].size(); j++) {
//			if (vv[i][j] > maxv) {
//				maxv = vv[i][j];
//				
//			}
//			//cout << maxv << endl;
//		}
//	}
//	cout << maxv << endl;
//	bool flag = true;
//	for (int i = 0; i<vv.size(); i++) {
//		for (int j = 0; j < vv[i].size(); j++) {
//			if (vv[i][j]== maxv) {
//				if (flag) {
//					cout << i+1;
//					flag = false;
//					break;
//				}
//				else {
//					cout << "," << i+1;
//					break;
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//连续出现的字符
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//int main() {
//	int n;
//	string s;
//	cin >> n >> s;
//	char tar;
//	vector<char> best;
//	int temp,cnt = 1,max = 1;
//	bool flag = false;
//	for (int i = 0; i < s.size(); i++) {
//		cnt = 1;
//		tar = s[i];
//		int temp = i;
//		//cout << "i: " << i << endl;
//		while (s[++temp] == tar) {
//			cnt++;
//			i++;
//			//cout<<tar<<" "<<temp<<" " << cnt << endl;
//		}
//		if (cnt >= n) {
//			//max = cnt;
//			best.push_back(tar);
//			flag = true;
//		}
//	}
//	if (flag) {
//		cout << best[0];
//	}
//	else {
//		cout << "No";
//	}
//	system("pause");
//	return 0;
//}

//最长平台 ? 自己写的 只有9分
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	if (n == 0) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	char tar;
//	int temp,cnt = 1,maxv = 1;
//	for (int i = 0; i<n; i++) {
//		//cout << i << endl;
//		tar = m[i];
//		temp = i;
//		cnt = 1;
//		if (temp + 1 < n) {//y思想：先判断 再走
//			while (m[++temp] == tar) {
//				i++;
//				cnt++;
//			}
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	cout << maxv;
//	system("pause");
//	return 0;
//}


//最长平台 参考网上的 10分
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//#include<cmath>
//#include<cstring>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	int n,maxv = 0,cnt = 1;
//	int a, b;
//	cin >> n>>a;
//	for (int i = 1; i < n; i++) {
//		cin >> b;
//		if (a == b) {
//			cnt++;
//		}
//		if (a != b) {
//			cnt = 1;
//			a = b;
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	
//	cout << maxv;
//	system("pause");
//	return 0;
//}

//最长平台 自己写一次 
//#include<iostream>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	int  tar, cnt = 1,maxv = 0;
//	tar = m[0];
//	for (int i = 1; i < n; i++) {
//		if (tar == m[i]) {
//			cnt++;
//		}
//		else if (tar != m[i]) {
//			cnt = 1;
//			tar = m[i];
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	cout << maxv;
//	system("pause");
//	return 0;
//}

//整数去重
//#include<iostream>
//#include<set>
//using namespace std;
//const int maxn = 20010;
//int m[maxn];
//set<int> s;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		set<int>::iterator iter;
//		iter = s.find(m[i]);
//		if (iter == s.end()) {
//			s.insert(m[i]);
//			cout << m[i] << " ";
//		}
//		
//	}
//	
//	system("pause");
//	return 0;
//}

//铺地毯 ??思路很重要
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//const int maxn = 100010;
//int m[maxn];
//int a[maxn], b[maxn], g[maxn], k[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	memset(g, 0, sizeof(g));
//	memset(k, 0, sizeof(k));
//	int n,x,y;
//	cin >> n;
//	
//	for (int i = 0; i < n; i++) {
//		cin >> a[i] >> b[i] >> g[i] >> k[i];
//
//	}
//	cin >> x>>y;
//	bool flag = false;
//	for (int i = n - 1; i >= 0; i--) {
//		if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
//			cout << i + 1;
//			flag = true;
//			break;
//		}
//	}
//	if (!flag)
//	{
//		cout << -1;
//	}
//	system("pause");
//	return 0;
//}

//接水问题 ??思路  问啥求啥 每个人去总时间最少的水龙头接水
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//const int maxn = 10010;
//int m1[maxn];
//int n1[maxn];
//int main() {
//	memset(m1, 0, sizeof(m1));
//	memset(n1, 0, sizeof(n1));
//	int n,m;
//	cin >> n>>m;
//	int min,pos;
//	for (int i = 0; i < n; i++) {
//		cin >> n1[i];
//	}
//	for (int i = 0; i < n; i++) {
//		min = m1[0];
//		pos = 0;
//		for (int j = 1; j < m; j++) {
//			if (m1[j] < min) {
//				min = m1[j];
//				pos = j;
//			}
//		}
//		m1[pos] = m1[pos] + n1[i];
//	}
//	int max = m1[0];
//	for (int i = 0; i < m; i++) {
//		if (m1[i] > max) {
//			max = m1[i];
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//接水问题  网上答案
//#include <iostream>
//#include <cstdio>
//#include <string>
//#include <cstring>
//#include <algorithm>
//using namespace std;
//int main() {
//	int a[100], m, n, i, j, min, minn, x, s;//
//	cin >> n >> m;
//	memset(a, 0, sizeof(a));	//数组清零，不用说了吧
//	for (i = 0; i<n; i++) {
//		cin >> x;
//		for (j = 0; j<m; j++) {
//			if (j == 0 || minn>a[j]) {
//				min = j;	//把最小值的地址赋给min，待会用
//				minn = a[j];	//把最小值赋给minn，要进行比较
//			}
//		}
//		a[min] += x;	//把接水最少的水龙头对上
//	}
//	for (i = 0; i<m; i++) if (i == 0 || s<a[i]) s = a[i];//找出最大的时间，即为所求
//	cout << s << endl;
//	return 0;
//}


//1.10编程基础之简单排序
// 谁考了第k名
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//multimap<double, string, greater<double>> m;
//int main() {
//	int n, k;
//	string id;
//	double score;
//	cin >> n >> k;
//	for (int i = 0; i < n; i++) {
//		cin >> id >> score;
//		m.insert(pair<double, string>(score,id));
//	}
//	int i = 1;
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		if (i == k) {
//			cout << itr->second << " " << itr->first;
//		}
//		i++;
//	}
//	system("pause");
//	return 0;
//}

//奇数单增序列
//#include<iostream>
//#include<set>
//#include<string>
//using namespace std;
//multiset<int> s;
//int main() {
//	int n,temp;
//	cin >> n ;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		s.insert(temp);
//	}
//	int i = 1;
//	bool flag = true;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		if (*itr%2 == 1) {
//			if (flag) {
//				cout << *itr;
//				flag = false;
//			}
//			else {
//				cout << "," << *itr;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//成绩排序  用冒泡排序来做
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//using namespace std;
//const int maxn = 25;
//
//multimap<int,string,greater<int>> m;
//struct person {
//	char name[maxn];
//	int score;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].name >> per[i].score;
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].score < per[j + 1].score) || (per[j].score == per[j + 1].score) && strcmp(per[j].name, per[j + 1].name) > 0) {//strcmp只能比char型数组 不能比string
//				swap(per[j].score, per[j + 1].score);
//				swap(per[j].name, per[j + 1].name);
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		cout << per[i].name << " " << per[i].score << endl;
//	}
//	system("pause");
//	return 0;
//}

//奖学金
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//using namespace std;
//const int maxn = 300;
//struct person {
//	int score1;
//	int score2;
//	int score3;
//	int tot;
//	int id;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].score1 >> per[i].score2 >> per[i].score3;
//		per[i].tot = per[i].score1 + per[i].score2 + per[i].score3;
//		per[i].id = i + 1;
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].tot < per[j + 1].tot) || ((per[j].tot == per[j + 1].tot) && per[j].score1<per[j+1].score1 ) ){//strcmp只能比char型数组 不能比string
//				swap(per[j].score1, per[j + 1].score1);
//				swap(per[j].score2, per[j + 1].score2);
//				swap(per[j].score3, per[j + 1].score3);
//				swap(per[j].tot, per[j + 1].tot);
//				swap(per[j].id, per[j + 1].id);
//			}
//		}
//	}
//	for (int i = 0; i < 5; i++) {
//		cout << per[i].id<<" "<<per[i].tot<<endl;
//	}
//	system("pause");
//	return 0;
//}

//分数线划定  看清楚范围！
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 5010;
//struct person {
//	int score;
//	int id;
//};
//int main() {
//	int n, m;
//	cin >> n >> m;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].id >> per[i].score;
//
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].score < per[j + 1].score) || ((per[j].score == per[j + 1].score) && per[j].id > per[j + 1].id)) {//strcmp只能比char型数组 不能比string
//				swap(per[j].score, per[j + 1].score);
//				swap(per[j].id, per[j + 1].id);
//			}
//		}
//	}
//	int k = floor(double(m)*1.5);
//	//cout << k << endl;
//	int line;
//	for (int i = 0; i < k; i++) {
//		line = per[i].score;
//	}
//	
//	int cnt = 0;
//	for (int i = 0; per[i].score >= line; i++) {
//		cnt++;
//	}
//	cout << line << " " << cnt << endl;
//	for (int i = 0; i < cnt; i++) {
//		cout << per[i].id << " " << per[i].score << endl;
//	}
//	system("pause");
//	return 0;
//}
//


//整数奇偶排序
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//multiset<int, greater<int>> ji;
//multiset<int> ou;
//int main() {
//	int n = 10;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] % 2 == 0) {
//			ou.insert(m[i]);
//		}
//		else {
//			ji.insert(m[i]);
//		}
//	}
//	for (auto itr = ji.begin(); itr != ji.end();itr++) {
//		cout << *itr << " ";
//	}
//	for (auto itr = ou.begin(); itr != ou.end(); itr++) {
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//合影效果
//#include<iostream>
//#include<iomanip>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//multiset<double, greater<double>> female;
//multiset<double> male;
//int main() {
//	int n;
//	cin >> n;
//	string gender;
//	double h;
//	for (int i = 0; i < n; i++) {
//		cin >>gender>> h;
//		if (gender == "male") {
//			male.insert(h);
//		}
//		else {
//			female.insert(h);
//		}
//	}
//	for (auto itr = male.begin(); itr != male.end(); itr++) {
//		cout <<fixed<<setprecision(2)<< *itr << " ";
//	}
//	for (auto itr = female.begin(); itr != female.end(); itr++) {
//		cout << fixed << setprecision(2)<<*itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//病人排队
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//multimap<int, string, greater<int>> older;
//vector<string> v;
//struct person
//{	
//	string id;
//	int age;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].id >> per[i].age;
//		if (per[i].age >=60) {
//			older.insert(pair<int, string>(per[i].age,per[i].id));
//		}
//		else {
//			v.push_back(per[i].id);
//		}
//	}
//	for (auto itr = older.begin(); itr != older.end(); itr++) {
//		cout <<	itr->second << endl;
//	}
//	for (int i = 0; i < v.size();i++) {
//		cout << v[i]<<endl;
//	}
//	system("pause");
//	return 0;
//}

//明明的随机数
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//set<int> s;
//
//int main() {
//	int n,temp;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		s.insert(temp);
//	}
//	cout << s.size() << endl;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		cout <<*itr << " ";
//	}
//	
//	system("pause");
//	return 0;
//}

//单词排序
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<sstream>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//set<string> se;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		se.insert(temp);
//	}
//	for (auto itr = se.begin(); itr != se.end(); itr++) {
//		cout << *itr << endl;
//	}
//	system("pause");
//	return 0;
//}

//1.11编程基础之二分查找
//查找最接近的元素  ?? 背住模板
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100010;
//long long  m[maxn];
//long long que[maxn];
//void solve(long long tar, int tot) {
//	int left = 1;
//	int right = tot;
//	int mid;
//	//while (left + 1 < right) {
//	//	mid = left + ((right - left) / 2);
//	//	//cout << left << " " << mid << " " << right << " " << m[mid] << endl;
//
//	//	if (tar > m[mid]) {
//	//		left = mid;
//	//	}
//	//	else {
//	//		right = mid;
//	//	}
//	//}
//	while (left + 1 < right) {//下界 一般情况下是 left<right 但是这个值可能不存在 所以要改为 left+1 < right
//		mid = left + (right - left) / 2;//// 当A[m]=v时，左侧还可能存在v，所以y更新为m这时查找的是[x,m)
//		if (tar <= m[mid]) {// 当A[m]>v时，说明v在左侧，区间更新为[x,m)
//			right = mid;// 当A[m]<v时，说明v在右侧，区间更新为[m+1,y]
//		}
//		else {
//			left = mid;//这里本来是left = mid +1  但是值可能不在里面 所以 left= mid；
//		}
//	}//最后得到的下界是left
//
//	if (abs(tar - m[left]) <= abs(tar - m[left + 1])) {
//		cout << m[left] << endl;
//	}
//	else {
//		cout << m[left + 1] << endl;
//	}
//	return;
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//
//	}
//
//	int q;
//	cin >> q;
//	for (int i = 1; i <= q; i++) {
//		cin >> que[i];
//		//cout << i << endl;
//	}
//	//cout << "hhh" << endl;
//	for (int i = 1; i <= q; i++) {
//		if (n == 1) {
//			cout << m[1] << endl;
//			continue;//考虑n ==1的特殊情况
//		}
//		if (que[i] <= m[1]) {
//			cout << m[1] << endl;
//			continue;
//		}
//		if (que[i] >= m[n]) {
//			cout << m[n] << endl;
//			continue;
//		}
//		//cout << i << endl;
//		solve(que[i], n);
//	}
//	system("pause");
//	return 0;
//}

//二分法求函数的零点 ? 判断精度
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double getV(double x) {
//	return pow(x, 5) - 15 * pow(x, 4) + 85 * pow(x, 3) - 225 * pow(x, 2) + 274 * x - 121;
//}
//int main() {
//	long double left = 1.5;
//	long double right = 2.4;
//	long double mid = 1.5;
//	while (fabs(right - left)>1e-7) {
//		mid = left + (right - left) / 2;
//		//cout << getV(mid) << " " << mid << endl;
//		if (getV(mid) > 0) {
//			left = mid;
//		}
//		else {
//			right = mid;
//		}
//	}
//	cout << fixed << setprecision(6) << left;
//	system("pause");
//	return 0;
//}

//矩形分割  ??思路
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 1000010;
//long long m[maxn];//极端情形下，R=10^6，从而R^2=10^12，考虑前缀和，将超过int——所以用long long。
//long long s[maxn];
//int r;
//int solve(int left, int right) {
//	int mid;
//	while (left < right) {
//		mid = left + (right - left) / 2;
//		if (s[mid] * 2 >= s[r]) {//s[r]为总的面积
//			right = mid;
//		}
//		else {
//			left = mid + 1;
//		}
//	}
//	return left;
//}
//int main() {
//	/*memset(m, 0, sizeof(m));//超时
//	memset(s, 0, sizeof(s));*/
//	int n;
//	cin >> r >> n;
//	int L, T, W, H;
//	for (int i = 1; i <= n; i++) {
//		cin >> L >> T >> W >> H;
//		for (int j = L + 1; j <= L + W; j++) {//这里是从L+1开始算
//			m[j] = m[j] + H;//这里是m[j] =m[j]+ H 因为纵向有可能不止一个矩形
//
//		}
//	}
//
//	for (int i = 1; i <= r; i++) {
//		s[i] = s[i - 1] + m[i];//前缀和
//		//cout << s[i] << endl;
//	}
//	/*for (int i = 1; i <= r; i++) {
//		cout <<"hhh  "<< m[i] << " " << s[i] << endl;
//	}*/
//	int v = solve(1, r);
//	//cout << v << endl;
//	while (v < r&&s[v] == s[v + 1]) {
//		v++;
//	}
//	cout << v;
//	system("pause");
//	return 0;
//}

//网线主管  ？？思路
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//void solve(int n, int k, int maxv) {
//	int left = 0;//起点是0 因为有可能无法取得满足要求的绳子 中点是maxn + 1
//	int right = maxv;
//	int mid = 1;
//	int tot = 0;
//	while (left + 1 < right) {//这里要加1 否则死循环
//		mid = left + (right - left) / 2;
//		cout << left << " " << mid << " " << right << " " << tot << endl;
//		tot = 0;
//		for (int i = 1; i <= n; i++) {
//			tot += m[i] / mid;
//		}
//		if (tot < k) {//判断是否去等号的方法：加入相等了 是希望取上界还是下界！
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	cout << fixed << setprecision(2) << double(left) / 100.0 << endl;
//}
//int main() {
//	int n, k;
//	cin >> n >> k;
//	double temp;
//	int maxv;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		m[i] = 100 * temp;
//		maxv = max(maxv, m[i]);
//	}
//	solve(n, k, maxv + 1);//要加1 因为可能整条绳子刚好完全用完  而我用的二分搜索是求下界 所以会求不到最后一个元素
//	system("pause");
//	return 0;
//}

//派 ？ 精度问题 之前1e-5 和1e-8只有9分  PI的精度要求很高
//#include <iostream>
//#include<algorithm>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double PI = acos(-1.0);//精度要到位 记住PI
//const int maxn = 10020;
//int m[maxn];
//void solve(int maxv, int n, int f) {
//	//cout << "f " << f << endl;
//	double left = 0.0;
//	double right = double(maxv + 1e-8);//这里要多加一点 
//	double mid;
//	int tot = 0;
//	while (fabs(left - right) > 1e-10) {
//		mid = left + (right - left) / 2;
//		//cout << left << " " << mid << " " << right << " " << tot << endl;
//
//		tot = 0;
//		for (int i = 1; i <= n; i++) {
//			tot = tot + floor((PI * pow(m[i], 2)) / (PI * pow(mid, 2)));
//		}
//		if (tot < f) {
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	// << "l: " << left << endl;
//	cout << fixed << setprecision(3) << PI * pow(left, 2) << endl;
//}
//int main() {
//	int n, f;
//	cin >> n >> f;
//	int maxv = 0;
//	int temp;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		maxv = max(maxv, m[i]);
//		//cout << maxv << endl;
//	}
//	solve(maxv, n, f + 1);
//	system("pause");
//	return 0;
//}

//月度开销 ？？思路判断是否满足f  以及什么时候是m+1？
//#include<iostream>	
//#include<algorithm>
//#include<math.h>
//using namespace std;
//const int maxn = 100010;
//long long m[maxn];
//int  n, f;
//long long maxv;
//long long tot = 0;
//bool check(int mid) {
//	int cnt = 1;
//	long long temp = 0;
//	for (int i = 1; i <= n; i++) {
//		//cout << i << " " << m[i] << " " << cnt << endl;
//		if (m[i] + temp <= mid) {
//			temp += m[i];
//		}
//		else if (m[i] <= mid) {
//			temp = m[i];//重新开启一个月时  temp初始化为第一个月的值
//			cnt++;
//		}
//		else {
//			//cout << "false" << endl;
//			return false;
//		}
//	}
//	if (cnt > f) {
//		//cout << "false" << endl;
//		return false;
//	}
//	else
//	{
//		//cout << "true" << endl;
//		return true;
//	}
//}
//void solve() {
//	int left = maxv;
//	int right = tot;
//	int mid;
//	while (left< right) {
//		mid = left + (right - left) / 2;
//		cout << left << " " << mid << " " << right << endl;
//		//system("pause");
//		if (check(mid)) {
//			right = mid;
//		}
//		else {
//			left = mid+1;//什么时候是mid 什么时候是mid+1
//		}
//	}
//	cout << left;
//}
//int main() {
//	cin >> n >> f;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		maxv = max(maxv, m[i]);
//		tot += m[i];
//	}
//	//cout << maxv << endl;
//	solve();
//	system("pause");
//	return 0;
//}

//和为给定数 ？？思路 以及判重
//#include<iostream>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//const int maxn = 1000010;
//long long m[maxn], tar;
//int n;
//void solve() {
//	if (n == 1) {
//		cout << "No";
//		return;
//	}
//	long long temp;
//	int left, right, mid;
//	bool flag = false;
//	for (int i = 1; i <= n; i++) {
//		temp = tar - m[i];
//		left = 0;
//		right = n + 1;
//		while (left < right) {
//			mid = left + (right - left) / 2;
//			//cout << temp << " " << m[i] << " " << left << " " << mid << " " << right << " " << m[mid] << endl;
//			if (temp == m[mid] && mid !=i) {//一定要判断找到的元素不能是自己
//				
//				cout << m[i] << " " << temp << endl;
//				flag = true;
//				return;
//			}
//			else if (temp < m[mid]) {
//				right = mid;
//			}
//			else {
//				left = mid + 1;
//			}
//		}
//	}
//	if (!flag) {
//		cout << "No";
//	}
//}
//int main() {
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	sort(m + 1, m + n + 1);
//	//for (int i = 1; i <= n; i++) {
//	//	cout << m[i] << " ";
//	//}
//	cin >> tar;
//	solve();
//	system("pause");
//	return 0;
//}

//不重复地输出数 用set
//#include<iostream>
//#include<set>
//using namespace std;
//set<int> se;
//int main() {
//	int n;
//	cin >> n;
//	int temp;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		se.insert(temp);
//
//	}
//	for (auto itr = se.begin(); itr != se.end(); itr++) {
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//膨胀的木棍  ??思路 遍历圆心角 如果得不到满分 把精度改大
//#include<iostream>
//#include<math.h>
//#include<iomanip>
//using namespace std;
//#define PI (acos(-1))
//double l, n, c;
//double tar, r, templ, d;
//void solve() {
//	double left = 0;
//	double right = PI;
//	double mid;
//	while (fabs(right - left) > 1e-15) {
//		mid = left + (right - left) / 2;
//		r = l / 2 / sin(mid/2);//这里圆心角的度数要除以2
//		templ = r * mid;
//		//cout << left << " " << mid << " " << right << " " << templ << endl;
//		if (templ >= tar) {
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	r = l / 2 / sin(mid/2);
//	d = r - r * cos(left/2);
//	cout << fixed << setprecision(3) << d;
//}
//int main() {
//	cin >> l >> n >> c;
//	tar = (1.0 + n * c)*l;
//	solve();
//	system("pause");
//	return 0;
//}


//河中跳房子  ??思路 遍历最小距离 一般思路 求什么遍历什么 最开始只有5分 没有把终点石头加进去
//#include<iostream>
//#include<math.h>
//#include<iomanip>
//using namespace std;
//const long long  maxn = 50010;
//long long m[maxn];
//long long l, n, c;
//bool check(long long mid) {
//	long long pos = 0;
//	int cnt = 0;
//	for (int i = 1; i <= n; i++) {
//		if (m[i] - pos < mid) {
//			cnt++;
//		}
//		else {
//			pos = m[i];
//		}
//	}
//	if (cnt <= c) {
//		return true;
//	}
//	else { 
//		return false; 
//	}
//}
//void solve() {
//	long long left = 0;
//	long long right = l + 1;
//	long long mid;
//	while (left +1 < right) {
//		mid = left + (right - left) / 2;
//
//		//cout << left << " " << mid << " " << right << " " << check(mid) << endl;
//		if (check(mid)) {
//			left = mid;
//		}
//		else {
//			right = mid;
//		}
//	}
//	cout << left;
//}
//int main() {
//	cin >> l >> n >> c;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	m[++n] = l;
//	solve();
//	system("pause");
//	return 0;
//}

// 2.5基本算法之搜索
//maze 网友答案
//#include<iostream>
//#include<cstring>
//using namespace std;
//char a[30][30]; //原数组
//int vis_key[30][30], vis_door[30][30];
//int key[5], hasKey[5], dir_r[4] = { 1,-1,0,0}, dir_c[4] = { 0,0,1,-1 }; // b数组纪录每种钥匙的数目，bb数组纪录有没有出现这种钥匙，0下标代表a, 依此类推
//int m, n, startx, starty, flag;//flag表示是否找到
//
//void find_key(int x, int y)
//{
//	if (flag)return;
//	for (int i = 0; i<4; i++)
//	{
//		int x2 = x + dir_r[i], y2 = y + dir_c[i];
//		if (a[x2][y2] == 'G')//如果找钥匙时找到宝藏，做标记，然后直接结束所有过程。 
//		{
//			flag = 1;
//			return;
//		}
//		if (a[x2][y2] >= 'a'&&a[x2][y2] <= 'e')
//		{
//			key[a[x2][y2] - 'a']--;//每找到一个钥匙，对应的b数组自减，值为0时代表全部集齐 
//			a[x2][y2] = '.';//将被找到的钥匙标记为空地 
//		}
//		if (a[x2][y2] == '.' && !vis_key[x2][y2])
//		{
//			vis_key[x2][y2] = 1; //标记找钥匙时走过的路 
//			find_key(x2, y2);
//		}//由于找钥匙时只要把所有路径走一遍，所以不需要回溯。
//	}
//}
//void find_door(int x, int y)
//{
//	if (flag)return;//找到宝藏后直接结束 
//	for (int i = 0; i<4; i++)
//	{
//		int x2 = x + dir_r[i], y2 = y + dir_c[i];
//		if (a[x2][y2] >= 'A'&&a[x2][y2] <= 'E' && !key[a[x2][y2] - 'A'] && hasKey[a[x2][y2] - 'A'])
//		{ //找到门后，如果已经集齐全部钥匙，则把门打开 
//			a[x2][y2] = '.';//将被打开的门标记为空地 
//			memset(vis_door, 0, sizeof(vis_door));/*vis_door数组纪录找门时走过的路，由于会找到新的钥匙，可能原来没打
//									开的门可以打开，所以将vis_door数组清零。*/
//			find_key(x2, y2);//每打开一个门，从被打开门的位置开始找钥匙。 
//		}
//
//		if (a[x2][y2] == '.' && !vis_door[x2][y2])
//		{
//			vis_door[x2][y2] = 1;
//			find_door(x2, y2);
//		}//同上 ，不需要回溯。 
//	}
//}
//int main()
//{
//	cin >> m >> n;
//	while (m)
//	{
//		flag = 0;
//		memset(a, 0, sizeof(a));
//		memset(vis_key, 0, sizeof(vis_key));
//		memset(vis_door, 0, sizeof(vis_door));
//		memset(key, 0, sizeof(key));
//		memset(hasKey, 0, sizeof(hasKey));
//		for (int i = 1; i <= m; i++)
//			for (int j = 1; j <= n; j++)
//			{
//				cin >> a[i][j];
//				if (a[i][j] == 'S')
//				{
//					startx = i; starty = j;
//					a[i][j] = '.';
//				}
//				if (a[i][j] >= 'a'&&a[i][j] <= 'e')
//				{
//					key[a[i][j] - 'a']++;
//					hasKey[a[i][j] - 'a'] = 1;
//				}
//
//			}
//		find_key(startx, starty);
//		find_door(startx, starty);
//		if (flag)cout << "YES" << endl;
//		else cout << "NO" << endl;
//		cin >> m >> n;
//	}
//}

//maze 自己默写 ？？思路很重要 这里要把起点设置为通路
//#include<iostream>
//#include<cstring>
//using namespace std;
//int r, c,start[2],keycnt[5],haskey[5],flag = 0;
//
//const int maxn = 25;
//int viskey[maxn][maxn], visdoor[maxn][maxn];
//char m[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//void findkey(int x, int y) {
//	if (flag) {
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] == 'G') {
//			flag = 1;
//			return;
//		}
//		if (m[nx][ny] >= 'a'&&m[nx][ny] <= 'e') {
//			keycnt[m[nx][ny] - 'a']--;
//			m[nx][ny] = '.';
//		}
//		if (m[nx][ny] == '.' && !viskey[nx][ny]) {
//			viskey[nx][ny] = 1;
//			findkey(nx, ny);
//		}
//	}
//}
//void finddoor(int x, int y) {
//	if (flag) {
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] == 'G') {
//			flag = 1;
//			return;
//		}
//		if (m[nx][ny] >= 'A'&&m[nx][ny] <= 'E'&&!keycnt[m[nx][ny]-'A']) {
//			m[nx][ny] = '.';
//			memset(visdoor, 0, sizeof(visdoor));
//			findkey(nx, ny);
//		}
//		if (m[nx][ny] == '.' && !visdoor[nx][ny]) {
//			visdoor[nx][ny] = 1;
//			finddoor(nx, ny);
//		}
//	}
//}
//int main() {
//	while (cin >> r >> c && r != 0 && c != 0) {
//		memset(keycnt, 0, sizeof(keycnt));
//		memset(haskey, 0, sizeof(haskey));
//		memset(visdoor, 0, sizeof(visdoor));
//		memset(viskey, 0, sizeof(viskey));
//		memset(m, 0, sizeof(m));
//		for (int i = 0; i < r; i++) {
//			for (int j = 0; j < c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'S') {
//					start[0] = i;
//					start[1] = j;
//					m[i][j] = '.';//这里要把起点设置为通路
//				}
//				if (m[i][j] >= 'a'&&m[i][j] <= 'e') {
//					keycnt[m[i][j] - 'a']++;
//					haskey[m[i][j] - 'a'] = 1;
//				}
//			}
//		}
//		findkey(start[0], start[1]);
//		finddoor(start[0], start[1]);
//		if (flag) {
//			cout << "YES"<<endl;
//		}
//		else {
//			cout << "NO" << endl;;
//		}
//		flag = 0;
//	}
//}

//Dungeon Master
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int l, r, c, v[31][31][31];
//int posx[] = { 0,0,0,0,1,-1 }, posy[] = { 0,0,1,-1,0,0 }, posz[] = { 1,-1,0,0,0,0 };
//bool maze[31][31][31], uva = true;
//char tmp;
//struct point {
//	int x;
//	int y;
//	int z;
//	int step;
//};
//bool legal(point _) {
//	return _.x>0 && _.y>0 && _.z>0 && _.x <= l && _.y <= r && _.z <= c;
//}
//int bfs(point start, point des) {
//	memset(v, 0, sizeof(v));
//	queue<point> Q;
//	Q.push(start);
//	while (!Q.empty()) {
//		point now = Q.front();
//		Q.pop();
//		for (int i = 0; i<6; ++i) {
//			point next = now;
//			next.x += posx[i];
//			next.y += posy[i];
//			next.z += posz[i];
//			if (next.x == des.x&&next.y == des.y&&next.z == des.z) {
//				next.step = now.step + 1;
//				return next.step;
//			}
//			if (legal(next) && !v[next.x][next.y][next.z] && !maze[next.x][next.y][next.z]) {
//				v[next.x][next.y][next.z] = 1;
//				next.step = now.step + 1;
//				Q.push(next);
//			}
//		}
//	}
//	return -1;
//}
//int main() {
//	while ((cin >> l >> r >> c) && l&&r&&c) {
//		point start, des;
//		for (int i = 1; i <= l; ++i)
//			for (int j = 1; j <= r; ++j)
//				for (int k = 1; k <= c; ++k) {
//					cin >> tmp;
//					if (tmp == '.') maze[i][j][k] = 0;
//					if (tmp == '#') maze[i][j][k] = 1;
//					if (tmp == 'S') start.x = i, start.y = j, start.z = k, maze[i][j][k] = 1;//起始位置要置为通路
//					if (tmp == 'E') des.x = i, des.y = j, des.z = k, maze[i][j][k] = 0;//终点置为障碍
//				}
//		start.step = 0;
//		int ans = bfs(start, des);
//		if (ans == -1) cout << "Trapped!";
//		else cout << "Escaped in " << ans << " minute(s).";
//		cout << endl;
//	}
//	return 0;
//}


//自己默写 ？？ 注意要把cout注释掉 不然报Output Limit Exceeded 
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//const int maxn = 35;
//char temp;
//int h, r, c;
//int m[maxn][maxn][maxn], vis[maxn][maxn][maxn];
//int dirx[6] = { 0,0,0,0,1,-1 };
//int diry[6] = { 0,0,1,-1,0,0 };
//int dirz[6] = { 1,-1,0,0,0,0 };
//int flag = 0;
//
//struct Point
//{
//	int x, y, z, step;
//};
//int bfs(Point start, Point end) {
//	memset(vis, 0, sizeof(vis));
//	queue<Point> q;
//	q.push(start);
//	while (!q.empty()) {
//		Point oldp = q.front();
//		q.pop();
//		for (int i = 0; i < 6; i++) {
//			Point newp = oldp;//在这里开新的 因为每个方向都要是新的
//			newp.x += dirx[i];
//			newp.y += diry[i];
//			newp.z += dirz[i];
//
//			if (newp.x == end.x &&newp.y == end.y &&newp.z == end.z) {
//				flag = 1;
//				newp.step = oldp.step + 1;
//				return newp.step;
//			}
//			if (newp.x >= 0 && newp.x < h&& newp.y >= 0 && newp.y < r&&newp.z >= 0 && newp.z < c) {
//				if (m[newp.x][newp.y][newp.z] == 1 && vis[newp.x][newp.y][newp.z] == 0) {
//					//cout << newp.x << " " << newp.y << " " << newp.z << " " << newp.step << " " << flag << endl;
//					newp.step = oldp.step + 1;
//					vis[newp.x][newp.y][newp.z] = 1;
//					q.push(newp);
//				}
//			}
//
//		}
//	}
//	return -1;
//}
//int main() {
//	while (cin >> h >> r >> c && h&& r  && c) {
//		Point start, des;
//		for (int i = 0; i < h; i++) {
//			for (int j = 0; j < r; j++) {
//				for (int k = 0; k < c; k++) {
//					cin >> temp;
//					if (temp == 'S') {
//						start.x = i;
//						start.y = j;
//						start.z = k;
//						start.step = 0;
//						m[i][j][k] = 1;
//					}
//					if (temp == 'E') {
//						des.x = i;
//						des.y = j;
//						des.z = k;
//						m[i][j][k] = 0;
//					}
//					if (temp == '.') m[i][j][k] = 1;
//					if (temp == '#') m[i][j][k] = 0;
//				}
//			}
//		}
//		int ans = bfs(start, des);
//		if (flag) {
//			cout << "Escaped in " << ans << " minute(s)." << endl;
//		}
//		else {
//			cout << "Trapped!" << endl;
//		}
//		flag = 0;
//	}
//	//system("pause");
//	return 0;
//}

//Channel Allocation  ？？转化为填色问题 dfs  注意颜色和节点的下标起始
//#include<iostream>
//#include<cstring>
//#include<string>
//using namespace std;
//int n;
//const int maxn = 30;
//int m[maxn][maxn], color[maxn];
//int flag = 0;
//int cnt, ans;
//bool check(int nd, int colr) {
//	for (int i = 0; i < n; i++) {//m下标从0开始
//		if (m[nd][i] && color[i] == colr) {
//			return false;
//		}
//	}
//	return true;
//}
//void dfs(int nd, int tot) {
//	if (flag) {
//		return;
//	}
//	if (nd >= n) {//下标从0开始 取等号
//		flag = 1;
//		return;
//	}
//	for (int i = 1; i <= tot; i++) {//颜色下标从1开始
//		if (check(nd, i)) {
//			//cout << nd << " " << i <<" "<<tot<< endl;
//			color[nd] = i;
//			dfs(nd + 1, tot);
//			color[nd] = 0;
//		}
//	}
//	if (!flag) {
//		ans++;
//		dfs(nd, tot + 1);
//	}
//}
//int main() {
//	string s;
//	int a, b;
//	while (cin >> n && n) {
//		cnt = 0;
//		ans = 1;
//		flag = 0;
//		memset(m, 0, sizeof(m));
//		memset(color, 0, sizeof(color));
//		for (int i = 1; i <= n; i++) {
//			cin >> s;
//			a = s[0] - 'A';
//			for (int j = 2; j < s.length(); j++) {
//				b = s[j] - 'A';
//				m[a][b] = 1;
//				m[b][a] = 1;//相当于无向图
//			}
//		}
//		dfs(0, 1);//m下标从0开始 所以从0~n-1  颜色下标从1开始
//		if (ans == 1) {
//			cout << ans << " channel needed." << endl;
//		}
//		else {
//			cout << ans << " channels needed." << endl;
//		}
//
//	}
//	system("pause");
//	return 0;
//}


//Lake Counting ??bfs
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c;
//const int maxn = 110;
//char m[maxn][maxn];
//int dirx[8] = { 0,0,1,-1,1,1,-1,-1 };
//int diry[8] = { 1,-1,0,0,1,-1,1,-1 };
//int cnt = 0;
//struct Point
//{
//	int x, y;
//};
//
//void bfs(Point p) {
//
//	queue<Point> q;
//	q.push(p);
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();//不要忘记把队首元素去掉
//		for (int i = 0; i < 8; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (m[next.x][next.y] == 'W') {
//				m[next.x][next.y] = '.';
//				q.push(next);
//			}
//		}
//	}
//	cnt++;
//}
//int main() {
//	memset(m, 0, sizeof(m));
//
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (m[i][j] == 'W') {
//				Point start;
//				start.x = i;
//				start.y = j;
//				
//				//cout << i << " " << j << endl;
//				bfs(start);
//			}
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//A Knight's Journey  朝一个方向走两步在拐弯走一步  没用vector
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//int r, c;
//const int maxn = 30;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int flag = 0;
//int cnt = 1, step;
////字典序
//int dirx[8] = { -1,1,-2,2,-2,2,-1,1 };
//int diry[8] = { -2,-2,-1,-1,1,1,2,2 };
//
//
//int ans[maxn][2];//dfs不适合用结构体 
//void dfs(int x, int y, int step) {
//
//	if (flag) {
//		return;
//	}
//	ans[step][0] = x;//对ans的理解：step用作记录第step层选择的坐标 也可以放在if判断语句里 不过要提前记录其实step = 1的情况 
//	ans[step][1] = y;
//	if (step == r * c) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 8; i++) {
//
//		int nextx = x + dirx[i];
//		int nexty = y + diry[i];
//		if (nextx >= 1 && nextx <= r && nexty >= 1 && nexty <= c && !vis[nextx][nexty] && !flag) {//这里要判断flag 因为孩子节点返回了之后可能就已经走完了
//			vis[nextx][nexty] = 1;
//			//cout << nextx << " " << nexty<<" "<<step<<" "<<flag<<" "<<ans[step][0]<<" "<<ans[step][1] << endl;
//
//			dfs(nextx, nexty, step + 1);
//			vis[nextx][nexty] = 0;//回溯 恢复现场
//			//v.pop_back();
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	int cnt = 1;
//	for (int i = 0; i < n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//
//		flag = 0;
//		cin >> r >> c;
//
//		vis[1][1] = 1;//一定要记得初始化起点
//		//step = 1;
//		dfs(1, 1, 1);
//
//		cout << "Scenario #" << cnt << ":" << endl;
//		if (flag) {
//			//cout << "step " << step << endl;
//			for (auto i = 1; i <= r * c; i++) {
//				cout << char(ans[i][1] + 'A' - 1) << ans[i][0];
//			}
//			cout << endl;
//		}
//		else {
//			cout << "impossible" << endl;
//		}
//		if (cnt != n) {
//			cout<< endl;
//		}
//		cnt++;
//	}
//	system("pause");
//	return 0;
//}

//A Knight's Journey 自己再写一次
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 26;
//int r, c;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int flag = 0;
//int ans[maxn][2];
//int dirx[8] = {-1,1,-2,2,-2,2,-1,1};
//int cnt = 1;
//int diry[8] = {-2,-2,-1,-1,1,1,2,2};
//void dfs(int x, int  y, int step) {
//	if (flag) {
//		return;
//	}
//	ans[step][0] = x;
//	ans[step][1] = y;
//	if (step == r * c) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 8; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !vis[nx][ny] && !flag) {
//			vis[nx][ny] = 1;
//			dfs(nx, ny, step + 1);
//			vis[nx][ny] = 0;
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> r >> c;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		
//		flag = 0;
//		vis[1][1] = 1;//一定记得初始化起点！！！
//		dfs(1, 1, 1);
//		cout << "Scenario #" << cnt << ":" << endl;
//		if (flag) {
//			for (int j = 1; j <= r * c; j++) {
//				cout << char(ans[j][1] + 'A' - 1) << ans[j][0];
//			}
//			cout << endl;
//		}
//		else {
//			cout << "impossible" << endl;;
//		}
//		if (cnt != n) {
//			cout << endl;
//		}
//		cnt++;
//	}
//	system("pause");
//	return 0;
//}


//LETTERS ?? 用dfs 不用开vis
//#include<iostream>
//#include<queue>
//#include<cstring>
//#include<algorithm>
//#include<math.h>
//using namespace std;
//const int maxn = 25;
//int m[maxn][maxn];
//int r, c;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
////int vis[maxn][maxn];
//int letter[30];
//int ans = 0;
//void dfs(int x, int y, int step) {
//
//	ans = max(ans, step);
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] &&  !letter[m[nx][ny]]) {
//			//cout << nx << " " << ny << " " << endl;
//			//vis[nx][ny] = 1;
//			letter[m[nx][ny]]= 1;
//			dfs(nx, ny, step + 1);
//			//vis[nx][ny] = 0;
//			letter[m[nx][ny]] = 0;
//		}
//	}
//}
//int main() {
//	//memset(vis, 0, sizeof(vis));
//	memset(m, 0, sizeof(m));
//	cin >> r >> c;
//	char temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			m[i][j] = temp - 'A' + 1;//从1开始编号
//		}
//	}
//	//vis[1][1] = 1;
//	letter[m[1][1]] = 1;
//	dfs(1, 1, 1); 
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//The Castle  ？？ 类似于最长路径 用dfs 但是不能直接用dfs中的step来表示s  注意技巧 &
//#include<iostream>
//#include<cstring>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//int r, c;
//int s, cnt,maxs;
//const int maxn = 55;
//int m[maxn][maxn][4], vis[maxn][maxn];
//int dirx[4] = { 0,-1,0,1 };
//int diry[4] = { -1,0,1,0 };
//void dfs(int x, int y) {//这里不能直接在dfs记录步数，因为dfs只能找最长通路，而我们要求的是最大面积，只要是走过的都要算进去，不要求一定是在一条路径上
//	maxs = max(s, maxs);
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		//cout << nx << " " << ny << " " << step+1 << " "<< m[x][y][i] <<" "<< vis[nx][ny] <<endl;
//
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !m[x][y][i] && !vis[nx][ny]) {//这里是判断前一步的m[x][y][i]而不是判断走了一步之后的障碍物
//			//cout << "hh" << endl;
//			s++;
//			//cout << nx << " " << ny << " " << s<< endl;
//			vis[nx][ny] = 1;
//			dfs(nx, ny);
//		}
//	}
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	memset(m, 0, sizeof(m));
//	cin >> r >> c;
//	int temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp & 1) {
//				
//				m[i][j][0] = 1;//西边有墙
//				//cout << m[i][j][0] << endl;
//			}
//			if (temp & 2) {
//				
//				m[i][j][1] = 1;//北边有墙
//				//cout << m[i][j][1] << endl;
//			}
//			if (temp & 4) {
//				
//				m[i][j][2] = 1;//东边有墙
//				//cout << m[i][j][2] << endl;
//			}
//			if (temp & 8) {
//				
//				m[i][j][3] = 1;//南边有墙
//				//cout << m[i][j][3] << endl;
//			}
//			//system("pause");
//		}
//	}
//	cnt = 0;
//	
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (!vis[i][j]) {
//				vis[i][j] = 1;
//				s = 1;
//				cnt++;
//				//cout << "start: " << i << " " << j << endl;
//				dfs(i, j);
//				maxs = max(maxs, s);
//			}
//		}
//	}
//	cout << cnt << endl << maxs;
//	system("pause");
//	return 0;
//}

//八皇后问题 ？？思路 把主对角线 次对角线 行 各开一个数组 用作标志位
//#include<iostream>
//#include<cstring>
//using namespace std;
//int flag = 0;
//const int maxn = 20;//这里数组要开大一点 因为 i-j共有16种值
//int m[maxn][maxn];
//int path[maxn];
//int zdjx[maxn], cdjx[maxn], col[maxn];
//int sum = 0;
//
//void out() {//输出的时候行列交换 满足题意要求
//	sum++;
//	cout << "No. " << sum << endl;
//	for (int i = 1; i <= 8; i++) {//原来的列
//		for (int j = 1; j <= 8; j++) {
//			if (i == path[j]) {
//				cout << 1 << " ";
//			}
//			else {
//				cout << 0 << " ";
//			}
//		}
//		cout << endl;
//	}
//}
//void dfs(int i) {
//	if (i > 8) {//这里是>8 因为==8 第8行还没判断
//		//cout << "hh" << endl;
//		out();
//		//return;
//	}
//	for (int j = 1; j <= 8; j++) {
//		//cout << step << " " << path[step] << " " << check(i, step) << endl;
//		if (!col[j] && !zdjx[i - j + 7] && !cdjx[i + j]) {
//			path[i] = j;
//			col[j] = 1;
//			zdjx[i - j + 7] = 1;
//			cdjx[i + j] = 1;
//			//cout << i << endl;
//			dfs(i + 1);
//			col[j] = 0;
//			zdjx[i - j + 7] = 0;
//			cdjx[i + j] = 0;
//		}
//	}
//}
//int main() {
//	dfs(1);
//	system("pause");
//	return 0;
//}


//八皇后
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100;
//int num[maxn];
//int path[maxn], col[maxn], zdjx[maxn], cdjx[maxn];
//int cnt = 0;
//void out() {
//	for (int i = 1; i <= 8; i++) {
//		cout << path[i];
//	}
//	cout << endl;
//}
//void dfs(int i) {
//	if (i > 8) {
//		cnt++;
//		for (int k = 0; k <= 92; k++) {
//			if (num[k] == cnt) {
//				out();
//				break;
//			}
//		}
//		/*cout << cnt << endl;
//		out();*/
//	}
//	for (int j = 1; j <= 8; j++) {
//		if (!col[j] && !zdjx[i - j + 7] && !cdjx[i + j]) {
//		//	cout << i << " " << j << " " << endl;
//			col[j] = 1;
//			zdjx[i - j + 7] = 1;//这里下标对应的是i - j + 7  不是j
//			cdjx[i + j] = 1;
//
//			path[i] = j;
//			dfs(i + 1);
//
//			col[j] = 0;
//			zdjx[i - j + 7] = 0;
//			cdjx[i + j] = 0;
//		}
//	}
//}
//int main() {
//	memset(path, 0, sizeof(path));
//	memset(col, 0, sizeof(col));
//	memset(zdjx, 0, sizeof(zdjx));
//	memset(cdjx, 0, sizeof(cdjx));
//
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> num[i];
//	}
//	dfs(1);
//	system("pause");
//	return 0;
//}

//算24 网上标答
//#include<cstdio>
//#include<algorithm>
//#include<cmath>
//#include<string.h>
//using namespace std;
//int visit[5];
//double a[5];
//int dfs(int step)
//{
//	if (step == 4) {
//		for (int i = 1; i <= 4; i++)
//			if (!visit[i]) {
//				if (fabs(a[i] - 24.0) < 0.0000001) {
//					return 1;
//
//				}
//
//			}
//		return 0;
//
//	}
//	for (int i = 1; i <= 4; i++) //枚举第一个数
//		if (!visit[i])
//			for (int j = i + 1; j <= 4; j++)//枚举第二个数
//				if (!visit[j])
//				{
//					visit[j] = 1;
//					double tmp1 = a[i], tmp2 = a[j];
//					a[i] = tmp1 + tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 - tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp2 - tmp1;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 * tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp2 / tmp1;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 / tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1;//回溯法
//					visit[j] = 0;
//				}
//	return 0;
//
//}
//int main()
//{
//	while (1)
//	{
//		scanf("%lf%lf%lf%lf", &a[1], &a[2], &a[3], &a[4]);
//		if (a[1] || a[2] || a[3] || a[4]) {
//			memset(visit, 0, sizeof(visit));
//			if (dfs(1))printf("YES\n");
//			else printf("NO\n");
//
//		}
//		else break;
//	}
//	return 0;
//
//}

//算24 ?? 思路 网上答案的方法
//#include <iostream>
//#include<cstring>
//#include<math.h>
//using namespace std;
//const int maxn = 10;
//double m[maxn];
//int vis[maxn];
//int flag = 0;
//int dfs(int step) {
//	/*if (flag) {
//		return 1;
//	}*/
//	if (step == 4) {//4个数进行3次运算 所以在step等于4的时候就已经进行完运算了 并且只有一个数是没有访问过的 那个数就是最后的结果
//		for (int i = 1; i <= 4; i++) {
//			if (!vis[i]&&fabs(m[i] - 24.0) < 1e-8) {
//				//flag = 1;
//				return 1;
//			}
//		}
//		return 0;
//
//	}
//	for (int i = 1; i <= 4; i++) {
//		if (!vis[i]) {
//			for (int j = i+1; j <= 4; j++) {//排列组合 j起始是i+1不是1
//				if (!vis[j]) {
//					vis[j] = 1;
//					//cout << step << " " << m[i] << " " << m[j] << " " << m[i] + m[j] << endl;
//					double temp1 = m[i];
//					double temp2 = m[j];
//					m[i] = temp1 + temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 - temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 * temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 / temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp2 - temp1;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp2 / temp1;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1;//回溯
//					vis[j] = 0;
//				}
//			}
//		}
//	}
//	return 0;//这里一定要返回0
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	
//	while (cin >> m[1] >> m[2] >> m[3] >> m[4] && m[1] != 0 && m[2] != 0 && m[3] != 0 && m[4] != 0) {
//		
//		memset(vis, 0, sizeof(vis));
//		/*for (int i = 1; i <= 4; i++) {
//			cout << m[i] << " ";
//		}*/
//		if (dfs(1)) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//算24 自己的方法
//#include <iostream>
//#include<cstring>
//#include<math.h>
//using namespace std;
//const int maxn = 10;
//double m[maxn];
//int vis[maxn];
//int flag = 0;
//void dfs(int step) {
//	if (flag) {
//		return;
//	}
//	if (step == 4) {//4个数进行3次运算 所以在step等于4的时候就已经进行完运算了 并且只有一个数是没有访问过的 那个数就是最后的结果
//		for (int i = 1; i <= 4; i++) {
//			if (!vis[i] && fabs(m[i] - 24.0) < 1e-8) {
//				flag = 1;
//				return;
//			}
//		}
//
//	}
//	for (int i = 1; i <= 4; i++) {
//		if (!vis[i]) {
//			for (int j = i + 1; j <= 4; j++) {//排列组合 j起始是i+1不是1
//				if (!vis[j]) {
//					vis[j] = 1;
//					//cout << step << " " << m[i] << " " << m[j] << " " << m[i] + m[j] << endl;
//					double temp1 = m[i];
//					double temp2 = m[j];
//					m[i] = temp1 + temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 - temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 * temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 / temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp2 - temp1;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp2 / temp1;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1;//回溯
//					vis[j] = 0;
//				}
//			}
//		}
//	}
//	
//}
//int main() {
//	memset(m, 0, sizeof(m));
//
//	while (cin >> m[1] >> m[2] >> m[3] >> m[4] && m[1] != 0 && m[2] != 0 && m[3] != 0 && m[4] != 0) {
//
//		memset(vis, 0, sizeof(vis));
//		/*for (int i = 1; i <= 4; i++) {
//		cout << m[i] << " ";
//		}*/
//		dfs(1);
//		if (flag) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//		flag = 0;
//	}
//	system("pause");
//	return 0;
//}

//迷宫  使用回溯 超时 去掉回溯 满分
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n;
//const int maxn = 110;
//int m[maxn][maxn], vis[maxn][maxn];
//int sx, sy, ex, ey;
//int flag = 0;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//void dfs(int x, int y) {
//	if (flag) {
//		return;
//	}
//	if (x == ex && y == ey) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (nx >= 0 && nx < n&&ny >= 0 && ny < n && !vis[nx][ny]&&m[nx][ny]) {
//			//cout << nx << " " << ny << endl;
//			vis[nx][ny] = 1;
//			dfs(nx, ny);
//			//vis[nx][ny] = 0;
//		}
//	}
//}
//int main() {
//	int cnt;
//	char temp;
//	cin >> cnt;
//	for (int i = 0; i < cnt; i++) {
//		flag = 0;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cin >> n;
//		for (int j = 0; j < n; j++) {
//			for (int k = 0; k < n; k++) {
//				cin >> temp;
//				if (temp == '.') {
//					m[j][k] = 1;//通路
//				}
//				else {
//					m[j][k] = 0;//障碍
//				}
//			}
//		}
//
//		cin >> sx >> sy >> ex >> ey;
//		vis[sx][sy] = 1;
//		if (m[sx][sy] == 0|| m[ex][ey] == 0) {//判断起点和终点是不是通路
//			cout << "NO" << endl;
//			//system("pause");
//			continue;//这里不能直接返回 因为还有剩下的测试用例
//		}
//		dfs(sx, sy);
//		if (flag) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//小游戏 ？？bfs vis记录路径 如果遇到更短的 也可以走
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<sstream>
//#include<limits.h>
//#include<queue>
//using namespace std;
//int r, c, sx, sy, ex, ey;
//const int maxn = 80;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int cnt = 0, tot = 1;
//int ans = 99999999;
//struct Point
//{
//	int x, y, step, dir;
//	Point() {};
//	Point(int xx, int yy, int ss, int dd) :x(xx), y(yy), step(ss), dir(dd) {};
//};
//
//
//int bfs() {
//	queue<Point> q;
//	q.push(Point(sx, sy, 0, -1));
//	vis[sx][sy] = 1;
//	while (!q.empty()) {
//		//Point now = q.front();
//		int x = q.front().x, y = q.front().y, sp = q.front().step, dir = q.front().dir;
//		cout << "now: " << x << " " <<y << " " << sp << " " <<dir << endl;
//		q.pop();
//		if (x == ex && y == ey) {
//			ans = min(sp, ans);
//		}
//		for (int i = 0; i < 4; i++) {
//
//			int nx = x + dirx[i];
//			int ny = y + diry[i];
//			if (nx >= 0 && nx <= r + 1 && ny >= 0 && ny <= c + 1 && (m[nx][ny] != 'X' || (nx == ex && ny == ey))) {
//				int nsp = dir == i ? sp : sp + 1;
//				if (vis[nx][ny] == -1 || vis[nx][ny] > nsp) {//是没有被访问过的节点或者说现在这种走法更近
//					vis[nx][ny] = nsp;
//					q.push(Point(nx, ny, nsp, i));
//
//				}
//			}
//		}
//	}
//	return ans == 99999999 ? -1 : ans;
//}
//
//int main() {
//
//
//	while (cin >> c >> r) {//r和c顺序是反的
//		if (c + r == 0) {//r和c不同时为0
//			break;
//		}
//		tot = 0;//
//		memset(m, 0, sizeof(m));
//		//cout << "Board #" << ++cnt << ":" << endl;
//		printf("Board #%d:\n", ++cnt);
//		getchar();//读取换行符
//		//cout << "x" << endl;
//		for (int i = 1; i <= r; i++) {
//			string line;
//			getline(cin, line);
//			for (int j = 1; j <= c; j++) {
//				m[i][j] = line[j - 1];
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		while (cin >> sy >> sx >> ey >> ex) {//这里x和y都交换顺序读
//			if (sx + sy + ex + ey == 0)break;
//			memset(vis, -1, sizeof(vis));
//			ans = 99999999;
//
//			int res = bfs();
//			/*if (res == -1) {
//				cout << "Pair " << ++tot << ": impossible." << endl;
//
//			}
//			else {
//				cout << "Pair " << ++tot << ": " << res << " segments." << endl;
//
//			}*/
//			if (res == -1)printf("Pair %d: impossible.\n", ++tot);
//			else printf("Pair %d: %d segments.\n", ++tot, res);
//
//		}
//		cout << endl;
//	}
//	//system("pause");
//	return 0;
//}


//小游戏 自己写  bfs+vis存最短路径
//#include<iostream>
//#include<queue>
//#include<string>
//#include<cstring>
//#include<limits.h>
//#include<math.h>
//#include<sstream>
//using namespace std;
//int r, c, sx, sy, ex, ey;
//const int maxn = 80;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1, 0,0 };
//struct Point
//{
//	int x, y, step, dir;
//	Point() {};
//	Point(int xx, int yy, int ss, int dd) :x(xx), y(yy), step(ss), dir(dd) {};
//};
//int bfs() {
//	int ans = INT_MAX;
//	queue<Point> q;
//	q.push(Point(sx, sy, 0, -1));
//	vis[sx][sy] =1;
//	while (!q.empty()) {
//		Point now = q.front();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		q.pop();
//		if ((now.x == ex) && (now.y == ey)) {
//			ans = min(ans, now.step);
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x <= r + 1 && next.y >= 0 && next.y <= c + 1 && ((m[next.x][next.y] != 'X') || (next.x == ex) && (next.y == ey))) {
//				if (now.dir == i) {//可以走这一步再更新step
//					next.step = now.step;
//				}
//				else {
//					next.step = now.step + 1;
//				}
//				if (vis[next.x][next.y] == -1 || vis[next.x][next.y] > next.step) {//走了这一步才能判断是否比原来的小
//					vis[next.x][next.y] = next.step;
//					next.dir = i;
//				
//					q.push(next);
//				}
//			}
//
//		}
//	}
//	return ans == INT_MAX ? -1 : ans;
//}
//int main() {
//	int tot = 1;//在循环外初始化
//	while (cin >> c >> r) {
//		
//		if (r + c == 0) {
//			break;
//		}
//		cout << "Board #" << tot++ << ":" << endl;
//		memset(m, 0, sizeof(m));
//		getchar();
//		for (int i = 1; i <= r; i++) {
//			string line;
//			getline(cin, line);
//			for (int j = 1; j <= c; j++) {
//				m[i][j] = line[j - 1];
//			}
//		}
//		int cnt = 1;
//		while (cin >> sy >> sx >> ey >> ex) {
//			if (sx + sy + ex + ey == 0) {
//				break;
//			}
//			memset(vis, -1, sizeof(vis));
//
//			int sus = bfs();
//			if (sus == -1) {
//				cout << "Pair " << cnt++ << ": impossible." << endl;
//			}
//			else {
//				cout << "Pair " << cnt++ << ": " << sus << " segments." << endl;
//			}
//		}
//		cout << endl;//注意最后有一个空行
//	}
//	system("pause");
//	return 0;
//}


//碎纸机 网上 ？？思路
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<cstdio>
//using namespace std;
//int tar, str_len;
//int single_v[23333];
//int slide_v[23333];
//
//bool multi;
//
//int best_ans[23333];
//int best_tot;
//int best_ans_len;
//void dfs(int tot, int pos, int cnt)//初始0 1 1
//{
//	if (tot > tar)
//		return;
//	if (pos > str_len)
//	{
//		if (tot == best_tot)//和之前最佳答案重复
//		{
//			multi = 1;
//			return;
//		}
//		if (tot > best_tot)
//		{
//			multi = 0;
//			best_tot = tot;
//			for (int i = 1; i < cnt; i++)
//				best_ans[i] = slide_v[i];
//			best_ans_len = cnt - 1;
//		}
//		return;
//	}
//
//	int slide_temp = 0;
//	for (int i = pos; i <= str_len; i++)
//	{
//		slide_temp *= 10;
//		slide_temp += single_v[i];
//		slide_v[cnt] = slide_temp;
//		dfs(tot + slide_temp, i + 1, cnt + 1);
//	}
//}
//int main()
//{
//	while (1)
//	{
//		memset(single_v, 0, sizeof(single_v));
//		multi = 0;
//		best_tot = -1;
//
//		string str;
//		cin >> tar >> str;
//		int strv = 0;
//		str_len = str.size();
//		if (tar == 0)
//			break;
//		for (int i = 0; i < str_len; i++)
//		{
//			single_v[i + 1] = str[i] - '0';
//			strv *= 10;
//			strv += single_v[i + 1];
//		}
//
//		if (strv == tar)
//		{
//			printf("%d %d\n", tar, tar);
//			continue;
//		}
//		dfs(0, 1, 1);
//		if (multi)
//		{
//			puts("rejected");
//			continue;
//		}
//		if (best_tot == -1)
//			puts("error");
//		else
//		{
//			printf("%d ", best_tot);
//			for (int i = 1; i <= best_ans_len; i++)
//			{
//				printf("%d ", best_ans[i]);
//			}
//			puts("");
//		}
//	}
//	system("pause");
//	return 0;
//}

//碎纸机 自己默写
//#include <iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int tar;
//string s;
//const int maxn = 10;
//int single[maxn];
//int str_len;
//int str_v;
//int ans = -1,multi = 0,ans_slide;
//int temp_trace[maxn],ans_trace[maxn];
//void dfs(int tot, int pos, int slide_cnt) {
//	//cout << tot << " " << pos << " " << slide_cnt << endl;
//	if (tot > tar) {
//		return;
//	}
//	if (pos > str_len) {
//		if (tot == ans) {
//			multi = 1;
//		}
//		if (tot > ans) {
//			multi = 0;//如果之前被置1了 那么更新答案了之后要置0
//			ans = tot;
//			ans_slide = slide_cnt - 1;//注意cnt要减一  因为多走了一层
//			for (int i = 1; i <= slide_cnt; i++) {
//				ans_trace[i] = temp_trace[i];
//			}
//		}
//		return;
//	}
//	int temp = 0;
//	for (int i = pos; i <= str_len; i++) {
//		temp = temp * 10;
//		temp += single[i];
//		temp_trace[slide_cnt] = temp;
//		dfs(tot + temp, i+1, slide_cnt + 1);//注意这里
//	}
//}
//int main() {
//	while (cin >> tar >> s) {
//		if (tar == 0 && s == "0") {
//			break;
//		}
//		ans = -1;
//		multi = 0;
//		memset(ans_trace, 0, sizeof(ans_trace));
//		memset(temp_trace, 0, sizeof(temp_trace));
//		memset(single, 0, sizeof(single));
//
//		str_len = s.length();
//		str_v = 0;
//		for (int i = 1; i <= str_len; i++) {
//			single[i] = s[i - 1] - '0';//注意字符串和数字的转化
//			str_v = str_v * 10;
//			str_v = str_v + single[i];
//			//cout << s[i - 1] << " " << single[i] << " " << str_v << endl;
//
//		}
//		if (tar == str_v) {
//			//cout << "hhh" << endl;
//			cout << tar << " " << tar << endl;
//			continue;
//		}
//		dfs(0, 1, 1);
//		if (ans == -1) {
//			cout << "error" << endl;
//			continue;
//		}
//		if (multi == 1) {
//			cout << "rejected" << endl;
//			continue;
//		}
//		else {
//			cout << ans;
//			for (int i = 1; i <= ans_slide; i++) {
//				cout << " " << ans_trace[i];
//			}
//			cout << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}


//城堡问题
//#include <iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 55;
//int m[maxn][maxn][4];
//int vis[maxn][maxn];
//int dirx[4] = { 0,-1,0,1 };
//int diry[4] = { -1,0,1,0 };
//
//int r, c;
//int area = 0;
//int max_area = 0;
//int cnt = 0;
//void dfs(int x, int y) {
//	//cout << x << " " << y << " " << area << " " << cnt << endl;
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		//cout << x << " " << y << " " << nx << " " << ny << " " << m[x][y][i] << " " << !vis[nx][ny] << " " << area << " " << cnt << endl;
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !m[x][y][i] && !vis[nx][ny]) {
//			//cout << x << " " << y << " " << nx << " " << ny << " " << m[x][y][i] << " " << vis[nx][ny] << " " << area << " " << cnt << endl;
//			vis[nx][ny] = 1;
//			area++;
//			dfs(nx, ny);
//			//vis[nx][ny] = 0;//不用回溯
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//
//	cin >> r >> c;
//	int temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp & 1) {
//				m[i][j][0] = 1;
//			}
//			if (temp & 2) {
//				m[i][j][1] = 1;
//			}
//			if (temp & 4) {
//				m[i][j][2] = 1;
//			}
//			if (temp & 8) {
//				m[i][j][3] = 1;
//			}
//
//		}
//
//	}
//	/*for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			for (int k = 0; k < 4; k++) {
//				cout << m[i][j][k] << " ";
//			}
//			cout << endl;
//		}
//
//	}*/
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (!vis[i][j]) {
//				area = 0;
//				dfs(i, j);
//				cnt++;
//				if (area > max_area) {
//					max_area = area;
//				}
//			}
//		}
//
//	}
//	cout << cnt << endl << max_area;
//	system("pause");
//	return 0;
//}

//1818:红与黑
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int r, c, startx, starty;
//const int maxn = 25;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int cnt = 1;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y;
//};
//void bfs() {
//	queue<Point> q;
//	Point p;
//	p.x = startx;
//	p.y = starty;
//	vis[startx][starty] = 1;//处理起点
//	q.push(p);
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << cnt << endl;
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0&&m[next.x][next.y] == 0) {
//				vis[next.x][next.y] = 1;
//				cnt++;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	int first = 1;
//	while (cin >> c >> r) {
//		if (c == 0 && r == 0) {
//			break;
//		}
//		
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cnt = 1;//第一个点算进去
//		
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				char temp;
//				cin >> temp;
//				if (temp == '.') {
//					m[i][j] = 0;//通路
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//				if (temp == '@') {
//					m[i][j] = 0;
//					startx = i;
//					starty = j;
//				}
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		bfs();
//		/*if (r == 1 && c == 1) {
//			cnt = 1;
//		}*/
//		if (first) {
//			cout << cnt ;
//			first = 0;
//		}
//		else {
//			cout << endl << cnt ;
//		}
//	}
//	system("pause");
//	return 0;
//}

//寻找Nemo ？？思路啊优先队列要在出队时标记vis
//#include<iostream>
//#include<queue>
//#include<cstring>
//#include<math.h>
//#include<algorithm>
//#include<limits.h>
//using namespace std;
//const int maxn = 220;
//int m[maxn][maxn][4];
//int vis[maxn][maxn];
//int tarx, tary, ans;
//int dirx[4] = { 0,1,0,-1 };//北 东 南 西
//int diry[4] = { 1,0,-1,0 };
//int minstep = INT_MAX;
//int maxx, maxy;
//struct  Point
//{
//	int x, y, dir, step = 0;
//	bool operator<(const Point &a)const
//	{
//		return step > a.step;
//	}
//
//};
//int bfs() {
//	priority_queue<Point> q;
//	Point p;
//	p.x = tarx;
//	p.y = tary;
//	p.step = 0;
//	q.push(p);
//	//vis[tarx][tary] = 1;//这里就不能处理起点了 
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();//函数用法是top不是front
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//
//		if (vis[now.x][now.y]) {//优先队列在出栈时标记 因为当2个位置步数相同时 排列顺序是随机的  不确定谁走了一步之后谁更小 所以要都加入
//			continue;
//			//cout << "hhh " << now.x << " " << now.y << endl;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		if (now.x < 1 || now.y >= 200 || now.y < 1 || now.y >= 200) {//一进来就判断 不要等到next再判断 因为可能起点就是终点
//			minstep = now.step;
//			flag = true;
//			//cout << "hhh " << now.x << " " << now.y << endl;
//			break;
//		}
//
//
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			next.dir = i;
//			//cout << next.x << " " << next.y << " " << next.step << endl;
//
//			if (next.x >= 0 && next.x < 200 && next.y >= 0 && next.y < 200 && vis[next.x][next.y] == 0 && m[now.x][now.y][next.dir] != 1) {
//				//cout<<"hhh "<< next.x << " " << next.y << " " << next.step << endl;
//				//vis[next.x][next.y] = 1;
//				if (m[now.x][now.y][next.dir] == 0) {
//					next.step = now.step;
//				}
//				if (m[now.x][now.y][next.dir] == 2) {
//					next.step = now.step + 1;
//				}
//				q.push(next);
//
//			}
//		}
//	}
//	if (flag) {
//		return minstep;
//	}
//	else {
//		return -1;
//
//	}
//}
//int main() {
//	int M, N;
//	int x, y, d, t;
//	while (cin >> M >> N) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		minstep = INT_MAX;
//		if (M == -1 && N == -1) {
//			break;
//		}
//		for (int i = 1; i <= M; i++) {
//			cin >> x >> y >> d >> t;
//			if (d == 0) {//这里方向要搞清楚呀！！！！
//				for (int j = 0; j < t; j++) {
//					m[x + j][y][2] = 1;//南
//					m[x + j][y - 1][0] = 1;//北
//					//cout << x + j << " " << y << " " << 2 << " " << m[x + j][y][2] << endl;
//				}
//			}
//			if (d == 1) {
//				for (int j = 0; j < t; j++) {
//					m[x][y + j][3] = 1;//西
//					m[x - 1][y + j][1] = 1;//东
//				}
//			}
//			maxx = max(maxx, x);//网上说要用这个判断儿子在没在墙内 但是我现在这种写法不用判断也行
//			maxy = max(maxy, y);
//		}
//		//cout << "hhh " << maxx << " " << maxy << endl;
//		for (int i = 1; i <= N; i++) {
//			cin >> x >> y >> d;
//			if (d == 0) {
//
//				m[x][y][2] = 2;//南
//				m[x][y - 1][0] = 2;//北
//
//			}
//			if (d == 1) {
//
//				m[x][y][3] = 2;
//				m[x - 1][y][1] = 2;
//
//			}
//		}
//		/*for (int i = 0; i <= 5; i++) {
//			for (int j = 0; j <= 5; j++) {
//				for (int k = 0; k < 4; k++) {
//					cout << i << " " << j << " :" << m[i][j][k] << " ";
//
//				}
//				cout << endl;
//			}
//			cout << endl;
//		}*/
//		double tarx_temp, tary_temp;
//		cin >> tarx_temp >> tary_temp;
//		tarx = floor(tarx_temp);
//		tary = floor(tary_temp);
//
//		//cout << tarx << " " << tary << endl;
//
//		if (N == 0) {
//			ans = -1;
//		}
//		if (tarx < 1 || tarx >= 200 || tary < 1 || tary >= 200) {
//			ans = 0;
//		}
//		else {
//			ans = bfs();
//		}
//		cout << ans << endl;
//
//
//	}
//	system("pause");
//	return 0;
//}

//Solitaire
//#include <iostream>
//#include <cstdio>
//#include <cstring>
//#include <algorithm>
//#include <queue>
//using namespace std;
//
//int n, m, ans;
//char vis[8][8][8][8][8][8][8][8];
//int dx[] = { -1,1,0,0 };
//int dy[] = { 0,0,-1,1 };
//bool mp[8][8]; // 用来判断每一时刻棋盘上某一位置有无棋子
//struct Node
//{
//	int x, y;
//} p1[4], p2[4];
//struct node
//{
//	int step;
//	Node pp[4];
//} cur, now;
//queue<node>q1, q2;
//
//bool cmp(const Node&xx1, const Node&xx2) //　从小到大排序
//{
//	if (xx1.x != xx2.x) return xx1.x<xx2.x;
//	return xx1.y<xx2.y;
//}
//bool bfs()
//{
//	int i, j, nst, tst, nstep, nx, ny, tx, ty;
//	memset(vis, 0, sizeof(vis));
//	memset(mp, 0, sizeof(mp));
//	while (!q1.empty()) q1.pop();
//	sort(p1, p1 + 4, cmp);
//	for (i = 0; i<4; i++)
//	{
//		cur.pp[i] = p1[i];
//	}
//	cur.step = 0;
//	vis[p1[0].x][p1[0].y][p1[1].x][p1[1].y][p1[2].x][p1[2].y][p1[3].x][p1[3].y] = '1';
//	q1.push(cur);
//	while (!q1.empty()) // 初始状态向前走4步　走过的标记为‘１’
//	{
//		now = q1.front();
//		q1.pop();
//		nstep = now.step;
//		if (nstep >= 4) break;
//		for (i = 0; i<4; i++) // 放棋子
//		{
//			mp[now.pp[i].x][now.pp[i].y] = 1;
//		}
//		for (i = 0; i<4; i++) // 第几个piece
//		{
//			nx = now.pp[i].x;
//			ny = now.pp[i].y;
//			for (j = 0; j<4; j++) // u d l r
//			{
//				cur = now; // 这行代码需加在这里 而不是上面
//				cur.step = nstep + 1;
//				tx = nx + dx[j];
//				ty = ny + dy[j];
//				if (tx<0 || tx >= 8 || ty<0 || ty >= 8) continue;
//				if (mp[tx][ty]) // 如果前面是棋子 则跳过棋子
//				{
//					tx += dx[j];
//					ty += dy[j];
//					if (tx<0 || tx >= 8 || ty<0 || ty >= 8 || mp[tx][ty]) continue;
//				}
//				cur.pp[i].x = tx;
//				cur.pp[i].y = ty;
//				sort(cur.pp, cur.pp + 4, cmp);
//				if (!vis[cur.pp[0].x][cur.pp[0].y][cur.pp[1].x][cur.pp[1].y][cur.pp[2].x][cur.pp[2].y][cur.pp[3].x][cur.pp[3].y])
//				{
//					vis[cur.pp[0].x][cur.pp[0].y][cur.pp[1].x][cur.pp[1].y][cur.pp[2].x][cur.pp[2].y][cur.pp[3].x][cur.pp[3].y] = '1';
//					q1.push(cur);
//				}
//			}
//		}
//		for (i = 0; i<4; i++) // 拿走棋子
//		{
//			mp[now.pp[i].x][now.pp[i].y] = 0;
//		}
//	}
//	memset(mp, 0, sizeof(mp));
//	while (!q2.empty()) q2.pop();
//	sort(p2, p2 + 4, cmp);
//	for (i = 0; i<4; i++)
//	{
//		cur.pp[i] = p2[i];
//	}
//	cur.step = 0;
//	if (vis[p2[0].x][p2[0].y][p2[1].x][p2[1].y][p2[2].x][p2[2].y][p2[3].x][p2[3].y]) return true;
//	else vis[p2[0].x][p2[0].y][p2[1].x][p2[1].y][p2[2].x][p2[2].y][p2[3].x][p2[3].y] = '2';
//	q2.push(cur);
//	while (!q2.empty()) // 最终状态向后走4步
//	{
//		now = q2.front();
//		q2.pop();
//		nstep = now.step;
//		if (nstep >= 4) break;
//		for (i = 0; i<4; i++)
//		{
//			mp[now.pp[i].x][now.pp[i].y] = 1;
//		}
//		for (i = 0; i<4; i++) // 第几个piece
//		{
//			nx = now.pp[i].x;
//			ny = now.pp[i].y;
//			for (j = 0; j<4; j++) // u d l r
//			{
//				cur = now;
//				cur.step = nstep + 1;
//				tx = nx + dx[j];
//				ty = ny + dy[j];
//				if (tx<0 || tx >= 8 || ty<0 || ty >= 8) continue;
//				if (mp[tx][ty])
//				{
//					tx += dx[j];
//					ty += dy[j];
//					if (tx<0 || tx >= 8 || ty<0 || ty >= 8 || mp[tx][ty]) continue;
//				}
//				cur.pp[i].x = tx;
//				cur.pp[i].y = ty;
//				sort(cur.pp, cur.pp + 4, cmp);
//				if (!vis[cur.pp[0].x][cur.pp[0].y][cur.pp[1].x][cur.pp[1].y][cur.pp[2].x][cur.pp[2].y][cur.pp[3].x][cur.pp[3].y])
//				{ // 没有标记过就标记为‘2’
//					vis[cur.pp[0].x][cur.pp[0].y][cur.pp[1].x][cur.pp[1].y][cur.pp[2].x][cur.pp[2].y][cur.pp[3].x][cur.pp[3].y] = '2';
//					q2.push(cur);
//				} // 已经标记为‘1’ 说明在能走到
//				else if (vis[cur.pp[0].x][cur.pp[0].y][cur.pp[1].x][cur.pp[1].y][cur.pp[2].x][cur.pp[2].y][cur.pp[3].x][cur.pp[3].y] == '1') return true;
//			}
//		}
//		for (i = 0; i<4; i++)
//		{
//			mp[now.pp[i].x][now.pp[i].y] = 0;
//		}
//	}
//	return false;
//}
//int main()
//{
//	int i, j, xx, yy;
//	while (~scanf("%d%d", &xx, &yy))
//	{
//		p1[0].x = xx - 1;
//		p1[0].y = yy - 1;
//		for (i = 1; i<4; i++)
//		{
//			scanf("%d%d", &xx, &yy);
//			p1[i].x = xx - 1;
//			p1[i].y = yy - 1;
//		}
//		for (i = 0; i<4; i++)
//		{
//			scanf("%d%d", &xx, &yy);
//			p2[i].x = xx - 1;
//			p2[i].y = yy - 1;
//		}
//		if (bfs()) printf("YES\n");
//		else printf("NO\n");
//	}
//	return 0;
//}

//仙岛求药
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int r, c,startx,starty,tarx,tary;
//const int maxn = 25;
//int m[maxn][maxn],vis[maxn][maxn];
//int ans;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, step;
//	bool operator < (const Point& a) const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = startx;
//	start.y = starty;
//	start.step = 0;//初始化为0
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		if (now.x == tarx && now.y == tary) {
//			flag = true;
//			 ans = now.step;
//			
//		}
//		for (int i = 0; i < 4; i++)
//		{
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//	while (cin >> r >> c) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		if (r == 0 && c == 0) {
//			break;
//		}
//		char temp;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> temp;
//				if (temp == '@') {
//					startx = i;
//					starty = j;
//					m[i][j] = 0;
//				}
//				if (temp == '*') {
//					tarx = i;
//					tary = j;
//					m[i][j] = 0;
//				}
//				if (temp == '.') {
//					m[i][j] = 0;
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//			}
//		}
//		bfs();
//	}
//	system("pause");
//	return 0;
//}

//走迷宫
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//const int maxn = 45;
//int m[maxn][maxn], vis[maxn][maxn];
//int r, c;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = 1;
//	start.y = 1;
//	start.step = 1;
//	priority_queue<Point> q;
//	q.push(start);
//	int ans;
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		if (now.x == r && now.y == c) {
//			flag = true;
//			ans = now.step;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++)
//		{
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	cin >> r >> c;
//	char temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp == '.') {
//				m[i][j] = 0;
//			}
//			if (temp == '#') {
//				m[i][j] = 1;
//			}
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}


//抓住那头牛
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//const int maxn = 200020;
//int vis[maxn];
//int beg, tar;
//struct Point
//{
//	int x, step;
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = beg;
//	start.step = 0;
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	int ans;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.step << endl;
//		if (now.x == tar) {
//			flag = true;
//			ans = now.step;
//			break;
//		}
//		if (vis[now.x]) {
//			continue;
//		}
//		else {
//			vis[now.x] = 1;
//		}
//		
//		Point next1;
//		next1.x = now.x + 1;
//		if (next1.x >= 0 && next1.x <= 100000 && vis[next1.x] == 0) {
//			next1.step = now.step + 1;
//			q.push(next1);
//		}
//		Point next2;
//		next2.x = now.x - 1;
//		if (next2.x >= 0 && next2.x <= 100000 && vis[next2.x] == 0) {
//			next2.step = now.step + 1;
//			q.push(next2);
//		}
//		Point next3;
//		next3.x = now.x * 2;
//		if (next3.x >= 0 && next3.x <= 100000 && vis[next3.x] == 0) {
//			next3.step = now.step + 1;
//			q.push(next3);
//		}
//
//	}
//	if (flag) {
//		cout << ans;
//	}
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	
//	cin >> beg >> tar;
//	bfs();
//	system("pause");
//	return 0;
//}

//符号三角形  ？？思路 超时
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n;
//const int maxn = 30;
//int m[maxn][maxn],temp[maxn];//m记录第一行  temp记录后面几行
//int cnt;
//int sum;
//void func() {
//	cnt = 0;
//	for (int i = 1; i <= n; i++) {
//		cnt += m[1][i];
//		//if (m[1][i] == 1) {
//		//	
//		//	cnt++;
//		//	//cout << "hh " << cnt << endl;
//		//}
//	}
//	for (int i = 2; i <= n; i++) {
//		for (int j = 1; j <= n - i + 1; j++) {
//			m[i][j] = (m[i - 1][j] + m[i - 1][j + 1]) % 2;//这里用特殊值带入
//			/*if (m[i][j] == 1) {
//				cnt++;
//			}*/
//			cnt += m[i][j];
//		}
//		
//	}
//	if (cnt == n * (n + 1) / 2 / 2) {
//		sum++;
//	}
//}
//void dfs(int x) {
//	if (x > n) {
//		/*for (int i = 1; i <=n; i++)
//		{
//			cout << m[1][i] << " ";
//		}
//		cout << endl;*/
//		
//		func();
//		return;
//	}
//	for (int i = 0; i < 2; i++) {//0+ 1-
//		m[1][x] = i;
//		dfs(x + 1);
//	}
//}
//int main() {
//	while (cin >> n) {
//		memset(m, 0, sizeof(m));
//		cnt = 0;
//		sum = 0;
//		if (n == 0) {
//			break;
//		}
//		if ((n*(n + 1) / 2) % 2 != 0) {
//			cout << n << " " << 0 << endl;;
//		}
//		else {
//			dfs(1);
//			cout << n << " " << sum << endl;;
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//棋盘问题 ？？ 思路同八皇后 超时
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n, k;
//const int maxn = 20;
//char m[maxn][maxn];
//int vis[maxn];
//int cnt = 0;
//void dfs(int x, int y) {
//	if (y >= k) {//这里判断是否用完步数
//		cnt++;
//		return;
//	}
//	for (int i = x; i < n; i++) {//这里要从x开始找之后的层  而不是从1开始
//		for (int j = 0; j < n; j++) {
//
//			if (m[i][j] == '#' && vis[j] == 0) {
//				vis[j] = 1;
//				dfs(i + 1, y + 1);//这里传进去的参数是i+1  不是x+1
//				vis[j] = 0;
//			}
//		}
//	}
//	return;
//}
//int main() {
//	while (cin >> n >> k) {
//		
//		if (n == -1 && k == -1) {
//			break;
//		}
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		
//		//for (int i = 0; i < n; i++) {
//		//	for (int j = 0; j < n; j++) {
//		//		cin >> m[i][j];
//		//		/*if (temp == '.') {
//		//			m[i][j] = 1;
//		//		}
//		//		if (temp == '#') {
//		//			m[i][j] = 0;
//		//		}*/
//		//	}
//		//}
//		for (int i = 0; i<n; i++)
//			cin >> m[i];//这样写 默认是从0开始的
//		cnt = 0;
//		dfs(0, 0);
//		cout << cnt << endl;
//	}
//	//system("pause");
//	return 0;
//}

//拯救行动
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, startx, starty, tarx, tary;
//const int maxn = 220;
//char m[maxn][maxn];
//char vis[maxn][maxn];//这里vis开的是int
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//int first = 1;//用于控制输出endl
//struct Point
//{
//	int x, y, step;
//	Point(int _x, int _y, int _step) :x(_x), y(_y), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y] == 0) {//仔细检查这一行  1和0 是否取等不要搞错了
//				if (m[next.x][next.y] == '@') {
//					next.step = now.step + 1;
//				}
//				if (m[next.x][next.y] == 'a') {//这里要考虑公主呀！！！！
//					next.step = now.step + 1;
//				}
//				if (m[next.x][next.y] == 'x') {
//					next.step = now.step + 2;
//				}
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		if (first) {
//			cout << ans;
//			first = 0;
//		}
//		else {
//			cout << endl << ans;
//
//		}
//	}
//	else {
//		if (first) {
//			cout << "Impossible";
//			first = 0;
//		}
//		else {
//			cout << endl << "Impossible";
//
//		}
//	}
//}
//int main() {
//	int num;
//	cin >> num;
//
//	for (int i = 0; i < num; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'r') {
//					startx = i;
//					starty = j;
//				}
//				if (m[i][j] == 'a') {
//					tarx = i;
//					tary = j;
//				}
//			}
//		}
//		//cout << startx << " " << starty << " " << tarx << " " << tary << endl;
//		bfs();
//	}
//	system("pause");
//	return 0;
//}

//鸣人和佐助 3分
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, t, startx, starty, tarx, tary;
//const int maxn = 220;
//char m[maxn][maxn];
//int vis[maxn][maxn][15];//用x,y,t唯一表示一种状态 因为相同的x,y可能拥有的钥匙不一样 不能因为前一种情况没有
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//struct Point
//{
//	int x, y, t_num, step;//这里把t_num加进去 由Point维护 因为下一步的t_num是有上一步的得到的 并且不同走法的t_num没有联系
//	Point(int _x, int _y, int _t_num, int _step) :x(_x), y(_y), t_num(_t_num), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, t, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " <<now.t_num<<" "<< now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y][now.t_num]) {//重点
//			continue;
//		}
//		else {
//			vis[now.x][now.y][now.t_num] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (now.t_num == 0) {
//				if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y][now.t_num] == 0) {
//					next.step = now.step + 1;
//					next.t_num = now.t_num;
//					q.push(next);
//				}
//			}
//			else {
//
//				if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y][now.t_num] == 0) {
//					if (m[next.x][next.y] == '#') {
//						next.t_num = now.t_num - 1;
//					}
//					else {
//						next.t_num = now.t_num;
//					}
//					next.step = now.step + 1;
//					q.push(next);
//				}
//			}
//
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//
//
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	ans = 0;
//	cin >> r >> c >> t;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//			if (m[i][j] == '@') {
//				startx = i;
//				starty = j;
//			}
//			if (m[i][j] == '+') {
//				tarx = i;
//				tary = j;
//			}
//		}
//	}
//	bfs();
//
//	system("pause");
//	return 0;
//}

//走出迷宫
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, startx, starty, tarx, tary;
//const int maxn = 110;
//char m[maxn][maxn];
//char vis[maxn][maxn];//这里vis开的是int
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//int first = 1;//用于控制输出endl
//struct Point
//{
//	int x, y, step;
//	Point(int _x, int _y, int _step) :x(_x), y(_y), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y] == 0) {//仔细检查这一行  1和0 是否取等不要搞错了
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		if (first) {
//			cout << ans;
//			first = 0;
//		}
//		else {
//			cout << endl << ans;
//
//		}
//	}
//	else {
//		if (first) {
//			cout << "Impossible";
//			first = 0;
//		}
//		else {
//			cout << endl << "Impossible";
//
//		}
//	}
//}
//int main() {
//	
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'S') {
//					startx = i;
//					starty = j;
//				}
//				if (m[i][j] == 'T') {
//					tarx = i;
//					tary = j;
//				}
//			}
//		}
//		//cout << startx << " " << starty << " " << tarx << " " << tary << endl;
//		bfs();
//	
//	system("pause");
//	return 0;
//}

//放苹果 ??思路 dp
//#include<iostream>
//#include<cstring>
//using namespace std;
//int apple, plate;
//int dp(int a, int p) {
//	if (a == 1 || a == 0 || p == 1) {//这里要判断a==0的情况
//		return 1;
//	}
//	if (a < p) {
//		return dp(a, a);
//	}
//	else if (a >= p) {
//		return dp(a - p, p) + dp(a, p - 1);
//	}
//}
//int main() {
//	int t;
//	cin >> t;
//	for (int i = 0; i < t; i++) {
//		cin >> apple >> plate;
//		int ans = dp(apple, plate);
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//迷宫问题 bfs+记录路径  不用优先队列 并且在进队的时候置vis
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int m[10][10];
//int vis[10][10];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//const int maxn = 1000;
//
//struct Point {
//	int x, y, step;
//	//bool operator<(const Point &a)const {
//	//	return step > a.step;
//	//}
//};
//Point trace[maxn][maxn];
//Point ans[maxn];
//void track(int x, int y) {
//	//cout << "hhh" << "(" << trace[2][4].x << ", " << trace[2][4].y << ")" << endl;
//	int k = 0,a,b;
//	
//	while (x != 0 || y != 0) {//这里本来是当x == 0 && y == 0 停止  取逆
//		a = x;//这里要先记录x,y的值 因为后面更新是先更新x， 再更新y 
//		b = y;
//		ans[k].x = trace[x][y].x;
//		ans[k].y = trace[x][y].y;
//		k++;
//		x = trace[a][b].x;
//		y = trace[a][b].y;
//	}
//	for (int i = k-1; i >= 0; i--) {
//		cout << "(" << ans[i].x << ", " << ans[i].y << ")" << endl;
//	}
//	cout << "(4, 4)" << endl;
//}
//void bfs() {
//	
//	Point start;
//	start.x = 0;
//	start.y = 0;
//	start.step = 0;
//	queue<Point> q;
//	q.push(start);
//	vis[0][0] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == 4 && now.y == 4) {
//			//cout << now.step << endl;
//			track(4, 4);
//			return;
//		}
//
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x < 5 && next.y >= 0 && next.y < 5 && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				vis[next.x][next.y] = 1;
//				next.step = now.step + 1;
//				//cout << next.x << " " << next.y << " " << next.step << endl;
//
//				trace[next.x][next.y].x = now.x;
//				trace[next.x][next.y].y = now.y;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	memset(trace, 0, sizeof(trace));
//	memset(ans, 0, sizeof(ans));
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}

//迷宫问题 优先队列+记录路径 出队再置vis 也可以  因为数据保证有唯一解
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int m[10][10];
//int vis[10][10];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//const int maxn = 1000;
//
//struct Point {
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//Point trace[maxn][maxn];
//Point ans[maxn];
//void track(int x, int y) {
//	//cout << "hhh" << "(" << trace[2][4].x << ", " << trace[2][4].y << ")" << endl;
//	int k = 0, a, b;
//
//	while (x != 0 || y != 0) {//这里本来是当x == 0 && y == 0 停止  取逆
//		a = x;//这里要先记录x,y的值 因为后面更新是先更新x， 再更新y 
//		b = y;
//		ans[k].x = trace[x][y].x;
//		ans[k].y = trace[x][y].y;
//		k++;
//		x = trace[a][b].x;
//		y = trace[a][b].y;
//	}
//	for (int i = k - 1; i >= 0; i--) {
//		cout << "(" << ans[i].x << ", " << ans[i].y << ")" << endl;
//	}
//	cout << "(4, 4)" << endl;
//}
//void bfs() {
//
//	Point start;
//	start.x = 0;
//	start.y = 0;
//	start.step = 0;
//	queue<Point> q;
//	q.push(start);
//	//vis[0][0] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == 4 && now.y == 4) {
//			//cout << now.step << endl;
//			track(4, 4);
//			return;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x < 5 && next.y >= 0 && next.y < 5 && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				//vis[next.x][next.y] = 1;
//				next.step = now.step + 1;
//				//cout << next.x << " " << next.y << " " << next.step << endl;
//
//				trace[next.x][next.y].x = now.x;
//				trace[next.x][next.y].y = now.y;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	memset(trace, 0, sizeof(trace));
//	memset(ans, 0, sizeof(ans));
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}

//献给阿尔吉侬的花束
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//
//const int maxn = 220;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int r, c, startx, starty, tarx, tary, ans;
//
//struct Point {
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//
//void bfs() {
//
//	Point start;
//	start.x = startx;
//	start.y = starty;
//	start.step = 0;
//	priority_queue<Point> q;
//	q.push(start);
//	//vis[0][0] = 1;
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				next.step = now.step + 1;
//
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << "oop!" << endl;
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		char temp;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> temp;
//				if (temp == 'S') {
//					m[i][j] = 0;
//					startx = i;
//					starty = j;
//				}
//				if (temp == 'E') {
//					m[i][j] = 0;
//					tarx = i;
//					tary = j;
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//				if (temp == '.') {
//					m[i][j] = 0;
//				}
//			}
//		}
//		bfs();
//	}
//
//	system("pause");
//	return 0;
//}

//拯救公主



//分成互质组  网上答案
//#include <iostream>
//using namespace std;
//
///* 分成互质组
//* 思路:对于每个数，要么把它放到之前的组里，要么单独列成组，dfs解决
//*/
//
//int m[15], s[15], f[15][15], n, result = 0x7f; //m[15]为元素，s[15]为元素属于的集合
//
//int gcd(int x, int y) //判断最大公约数
//{
//	if (y == 0) return x;
//	else return gcd(y, x % y);
//}
//
//void DFS(int pos, int ans) //pos表示当前取到的位置，ans表示有多少个组
//{
//	if (ans >= result) return; //剪枝
//	if (pos > n) {
//		result = ans;
//		return;
//	}
//	for (int i = 1; i <= ans; i++) //枚举每个集合
//	{
//		bool flag = true;
//		for (int j = 1; j < pos; j++) { //如果有m[pos]之前的数属于这个集合且不与m[pos]互质，这个集合不满足要求		
//			if (s[j] == i && f[pos][j] != 1) {
//				flag = false;
//				break;
//			}
//		}
//		if (flag) {//否则，把m[pos]归到这个集合里，搜索下一层
//			s[pos] = i;
//			DFS(pos + 1, ans);
//		}
//	}
//	s[pos] = ans + 1; //或者，m[pos]单独再成立一个集合，搜索下一层
//	DFS(pos + 1, ans + 1);
//}
//
//int main()
//{
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			f[i][j] = gcd(m[i], m[j]);
//			//cout << f[i][j] << " ";
//		}
//		//cout << endl;
//	}
//	s[1] = 1;//第一个元素属于第一个集合
//	DFS(2, 1);//判断2个元素 1个集合
//	cout << result;
//	system("pause");
//	return 0;
//}


//分成互质组 自己默写  代码风格有变化
//#include<iostream>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int state[maxn][maxn];
//int group[maxn];
//int n;
//int ans = INT_MAX;
//bool flag = false;
//int gcd(int x, int y) {
//	if (y == 0) {
//		return x;
//	}
//	else {
//		return gcd(y, x%y);
//	}
//}
//void dfs(int pos, int num) {
//	//if (num >= ans) {
//	//	return;//剪枝
//	//}
//	if (flag) {
//		return;
//	}
//	if (pos > n) {
//		//cout << "hhh" << num << endl;
//		flag = true;
//		if (num < ans) {//这里两种写法 第一种在走到底的时候判断谁更小 更新答案 第二种 不用走到底 直接剪枝
//			ans = num;
//		}
//		return;
//	}
//	bool suc;
//	for (int i = 1; i <= num; i++) {//遍历每一种颜色 判断每一种颜色
//		suc = true;//初始置为成功 因为只要有一个失败就是失败 不好判断是不是每个都是成功
//		for (int j = 1; j < pos; j++) {//遍历是否互质
//			if (group[j] == i && state[j][pos] != 1) {// 首先找到第i中颜色的元素j  判断在第i中颜色中 j元素是否和pos元素互质
//				suc = false;
//				break;
//			}
//		}
//		if (suc) {//如果成功
//			group[pos] = i;
//			dfs(pos + 1, num);//继续搜索下去 如果能一直走到底 就能走到pos>n 就不会走到下一段代码
//		}
//	}
//
//	if (!suc) {//如果没有成功
//		group[pos] = num + 1;
//		dfs(pos + 1, num + 1);
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(state, 0, sizeof(state));
//	memset(group, 0, sizeof(group));
//
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			state[i][j] = gcd(m[i], m[j]);//如果state[i][j]== 1 则说明m[i] m[j]互质
//		}
//	}
//	group[1] = 1;
//	dfs(2, 1);
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//马走日  每步直一格再斜一格 8个方向
//#include<iostream>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 15;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int r, c, startx, starty, cnt;
//int dirx[8] = { -2 ,-2,-1,-1,1,1,2,2 };
//int diry[8] = { -1,1 ,-2,2,2,-2,-1,1 };
////int dirx[8] = { -2,-1,1,2,2,1,-1,-2 };
////int diry[8] = { 1,2,2,1,-1,-2,-2,-1 };
//void dfs(int x, int y, int step) {
//	if (step >= r * c) {
//		cnt++;
//	}
//	for (int i = 0; i < 8; i++) {
//		int nextx = x + dirx[i];
//		int nexty = y + diry[i];
//		if (vis[nextx][nexty] == 0 && nextx >= 0 && nextx < r&&nexty >= 0 && nexty < c) {
//			//cout << nextx << " " << nexty << " " << step + 1 << " " << cnt << endl;
//			vis[nextx][nexty] = 1;
//			dfs(nextx, nexty, step + 1);
//			vis[nextx][nexty] = 0;
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cnt = 0;
//		cin >> r >> c >> startx >> starty;
//		vis[startx][starty] = 1;//一定记得初始化第一步
//		dfs(startx, starty, 1);
//		cout << cnt << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//单词接龙  ??思路 dfs
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<climits>
//using namespace std;
//const int maxn = 25;
//int maxlen = INT_MIN;
////int flag = 0;
//int n;
//struct letterstr
//{
//	string s;
//	int len;
//	int t;
//};
//letterstr str[maxn];
//void dfs(int pos, int cnt) {//pos是指龙的最后一个单词  cnt是长度
//	/*if (flag) {//回溯的时候 如果找到了一条路 还要遍历完所有路 所以不加这个 如果加了 就是直走一条路
//		return;
//	}*/
//
//	for (int i = 1; i <= n; i++) {//遍历每一个单词
//		if (str[i].t < 2) {//如果被访问两次以内 则继续
//			for (int j = 0; j < str[pos].len; j++) {//遍历pos的所有字母 和每一个单词的第一个字母比对
//				if (str[pos].s[j] == str[i].s[0]) {//如果pos的单词的某一个字母和第i个单词的首字母匹配成功 则继续比对
//					int k = 1;//用于遍历第i个单词的字母 因为之前已经判断过了0  所以从1开始
//					bool suc = true;
//					for (int q = j + 1; q < str[pos].len&&k < str[i].len; q++, k++) {
//						if (str[pos].s[q] != str[i].s[k]) {
//							suc = false;
//							break;
//						}
//					}
//					if (suc) {
//						str[i].t = str[i].t + 1;
//						cout << str[i].s <<" "<< cnt + str[i].len - k<< endl;
//						
//						dfs(i, cnt + str[i].len - k);//这里是从i开始 不是从pos+1开始
//						str[i].t = str[i].t - 1;
//					}
//				}
//			}
//		}
//	}
//	if (cnt > maxlen) {//注意退出条件 放在最后
//		maxlen = cnt;
//		//flag = 1;
//		return;
//		
//	}
//}
//int main() {
//	//cout << "hhh" << maxlen << endl;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> str[i].s;
//		str[i].len = str[i].s.length();
//		str[i].t = 0;
//		//cout << str[i].s << " " << str[i].len << endl;
//	}
//	string start;
//	cin >> start;
//	str[0].s = start;
//	str[0].len = start.length();
//	dfs(0, start.length());//把开头字母也加进去处理
//	cout << maxlen << endl;
//	system("pause");
//	return 0;
//}
