//1.1编程基础之输入输出
//	Hello, World!
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "Hello, World!";
//}

//	输出第二个整数
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b>>c;
//	cout << b;
//}

//	对齐输出
//#include <iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	printf("%8d %8d %8d", a, b, c);
//	system("pause");
//	return 0;
//}

//输出保留3位小数的浮点数
//#include<iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	float a;//单精度浮点数
//	cin >> a;
//	cout << fixed << setprecision(3) << a;
//	system("pause");
//}

//输出保留12位小数的浮点数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double a;
//	cin >> a;
//	cout << fixed << setprecision(12) << a;
//	system("pause");
//}

//空格分隔输出
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	char a;
//	int b;
//	float c;
//	double d;
//	cin >> a >> b >> c >> d;
//	cout << a << " " << b << " " << fixed << setprecision(6) << c << " " << fixed << setprecision(6) << d;
//	system("pause");
//}

//输出浮点数
//#include <iostream>
//using namespace std;
//double a;
//int main() {
//	cin >> a;
//	printf("%f\n", a);
//	printf("%.5f\n", a);//.后面表示精度
//	printf("%e\n", a);
//	printf("%g", a);
//	system("pause");
//	return 0;
//}

//字符三角形
//#include <iostream>
//using namespace std;
//char a;
//int main() {
//	cin >> a;
//	cout << "  " << a << "  "<<endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << a << a << a << a << a;
//	system("pause");
//	return 0;
//}

//字符菱形
//#include <iostream>
//using namespace std;
//char a;
//int main() {
//	cin >> a;
//	cout << "  " << a << "  " << endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << a << a << a << a << a<<endl;
//	cout << " " << a << a << a << " " << endl;
//	cout << "  " << a << "  ";
//	system("pause");
//	return 0;
//}

//超级玛丽游戏 ?
//#include <iostream>
//using namespace std;
//int main() {
//	printf("                ********\n\
//               ************\n\
//               ####....#.\n\
//             #..###.....##....\n\
//             ###.......######              ###                 ###           ###           ###\n\
//                ...........               #...#               #...#         #...#         #...#\n\
//               ##*#######                 #.#.#               #.#.#         #.#.#         #.#.#\n\
//            ####*******######             #.#.#               #.#.#         #.#.#         #.#.#\n\
//           ...#***.****.*###....          #...#               #...#         #...#         #...#\n\
//           ....**********##.....           ###                 ###           ###           ###\n\
//           ....****    *****....\n\
//             ####        ####\n\
//           ######        ######\n\
//##############################################################              ##################################\n\
//#...#......#.##...#......#.##...#......#.##------------------#              #...#......#.##------------------#\n\
//###########################################------------------#              ###############------------------#\n\
//#..#....#....##..#....#....##..#....#....#####################              #..#....#....#####################\n\
//##########################################    #----------#                  ##############    #----------#\n\
//#.....#......##.....#......##.....#......#    #----------#                  #.....#......#    #----------#\n\
//##########################################    #----------#                  ##############    #----------#\n\
//#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#                  #.#..#....#..#    #----------#\n\
//##########################################    ############                  ##############    ############");
//	system("pause");
//}

//1.2编程基础之变量定义、赋值及转换
//整型数据类型 存储空间大小存储空间大小（单位：字节） 4 2
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	short b;
//	a = 1;
//	b = 1;
//	cout << sizeof(a) <<" "<< sizeof(b);
//	system("pause");
//	return 0;
//}

//浮点型数据类型存储空间大小  4 8 
//#include <iostream>
//using namespace std;
//int main() {
//	float a;
//	double b;
//	a = 1.0;
//	b = 1.0;
//	cout << sizeof(a) << " " << sizeof(b);
//	system("pause");
//	return 0;
//}

//其他基本数据类型存储空间大小 1 1 
//#include <iostream>
//using namespace std;
//int main() {
//	bool a;
//	char b;
//	a = true;
//	b = a;
//	cout << sizeof(a) << " " << sizeof(b);
//	system("pause");
//	return 0;
//}

//填空：类型转换1
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "D C";
//	system("pause");
//}

//填空：类型转换1
//#include <iostream>
//using namespace std;
//int main() {
//	cout << "F E";
//	system("pause");
//}

//浮点数向零舍入
//#include <iostream>
//using namespace std;
//int main() {
//	float a;
//	cin >> a;
//	cout << (int)a;
//	system("pause");
//}

//打印ASCII码 NULL的ascii是0
//#include <iostream>
//using namespace std;
//int main() {
//	char a;
//	cin >> a;
//	//cout << a - NULL;
//	cout << (int)a;
//	system("pause");
//}

//打印字符
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	cin >> a;
//	cout << (char)a;
//	system("pause");
//}

//整型与布尔型的转换
//#include <iostream>
//using namespace std;
//int main() {
//	int a;
//	cin >> a;
//	bool b = a;
//	a = b;
//	cout << a;
//	system("pause");
//}

//Hello, World!的大小
//#include <iostream>
//using namespace std;
//int main() {
//	char c[] = "Hello, World!";
//	cout << sizeof(c);
//	system("pause");
//}

//1.3编程基础之算术表达式与顺序执行
////A+B问题
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	cout << a + b;
//	system("pause");
//}

//计算(a+b)*c的值
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	cout << (a + b)*c;
//	system("pause");
//}

//计算(a+b)/c的值
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	cout << (a + b)/c;
//	system("pause");
//}

//带余除法
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b ;
//	cout <<a/b<<" "<<a%b;
//	system("pause");
//}

//计算分数的浮点数值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	double c = (double)a / b;
//	cout << fixed<<setprecision(9)<<c;
//	system("pause");
//}

//甲流疫情死亡率
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int a, b;
//	cin >> a >> b;
//	double c = (double)b / a;
//	c = c * 100;
//	cout << fixed << setprecision(3) << c << "%";
//	system("pause");
//}


//计算多项式的值 ？
//#include<iostream>
//#include<iomanip>
//#include<math.h>//因为用了pow 要加头文件
//using namespace std;
//int main() {
//	double x, a, b, c, d;
//	cin >> x >> a >> b >> c >> d;
//	double ans = a * pow(x, 3) + b * pow(x, 2) + c * pow(x, 1) + d;
//	cout << fixed << setprecision(7) << ans;
//	system("pause");
//}

//温度表达转化
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double f;
//	cin >>f;
//	double ans = 5*(f -32)/9;
//	cout << fixed << setprecision(5) << ans;
//	system("pause");
//}


// 与圆相关的计算
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double pi = 3.14159;
//double r;
//int main() {
//	cin >> r;
//	cout << fixed << setprecision(4) << 2*r<<" " << fixed << setprecision(4) << 2 * r * pi << " " << fixed << setprecision(4) << pi * pow(r,2) << " ";
//	system("pause");
//}

//计算并联电阻的阻值  ？
//#include<iostream>
//#include<iomanip>
//using namespace std;
//float a, b;//题目要求用浮点型
//int main() {
//	cin >> a >> b;
//	float ans = 1 / (1 / a + 1 / b);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//}

//计算浮点数相除的余数 ?
//#include<iostream>
//#include<iomanip>
//using namespace std;
//double a, b;
//int main() {
//	cin >> a >> b;
//	int k = a / b;
//	double ans = a - b * k;
//	/*注意：输出时小数尾部没有多余的0，可以用下面这种格式：
//		double x;
//	x = 1.33;
//	printf("%g", x);*/
//	printf("%g", ans);
//	system("pause");
//}

//计算球的体积
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double pi = 3.14;
//double r;
//int main() {
//	cin >> r;
//	double ans =( 4.0 / 3.0) * pi*pow(r, 3);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//}

//反向输出一个三位数
//#include<iostream>
//using namespace std;
//int a;
//int main() {
//	cin >> a;
//	cout << a % 10;
//	a = a / 10;
//
//	cout << a % 10;
//	a = a / 10;
//
//	cout << a % 10;
//	a = a / 10;
//
//	system("pause");
//}

//大象喝水
//1升 = 1000毫升
//1毫升 = 1 立方厘米
//#include<iostream>
//#include<math.h>//floor向下取整要包含头文件
//using namespace std;
//int h, r;
//double pi = 3.14159;
//int main() {
//	cin >> h >> r;
//	double v = pi * pow(r, 2)*h;
//	int  ans = floor((20.0 * 1000.0)/ v + 1);//相当于向上取整
//	cout << ans;
//	system("pause");
//}

//苹果和虫子 ?
//#include<iostream>
//#include<math.h>//ceil向上取整要包含头文件
//using namespace std;
//int n, x, y;
//int main() {
//	cin >> n >> x >> y;
//	int bad = ceil(double(y) / double(x));
//	int ans = n - bad;
//	cout << ans;
//
//	system("pause");
//}

//计算线段长度 ?头文件问题
//#include<iostream>
//#include<cmath>//包含cmath就不报错 math.h报错
//#include <iomanip>
//using namespace std;
//double xa, ya, xb, yb;
//int main() {
//	cin >> xa >> ya >> xb >> yb;
//	double  ans = sqrt(pow(abs(xa - xb), 2) + pow(abs(ya - yb), 2));
//	cout << fixed << setprecision(3) << ans;
//	system("pause");
//}

//计算三角形面积
//用海伦公式
//#include <iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//float x1, Y1, x2, y2, x3, y3;
//int main() {
//	cin >> x1 >> Y1 >> x2 >> y2 >> x3 >> y3;
//	float a = sqrt(pow(abs(x1 - x2), 2) + pow(abs(Y1 - y2), 2));
//	float b = sqrt(pow(abs(x3 - x2), 2) + pow(abs(y3 - y2), 2));
//	float c = sqrt(pow(abs(x1 - x3), 2) + pow(abs(Y1 - y3), 2));
//	float p = (a + b + c) / 2;//半周长
//	float s = sqrt(p*(p - a)*(p - b)*(p - c));
//	//cout << a << " " << b << " " << c << " " << p << endl;
//	cout << fixed << setprecision(2) << s;
//	system("pause");
//	return 0;
//}

//等差数列末项计算
//#include <iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int a, b, n;
//int main() {
//	cin >> a >> b >> n;
//	int delta = b - a;
//	int ans = a + delta * (n - 1);
//	cout << fixed << setprecision(2) << ans;
//	system("pause");
//	return 0;
//}

//A*B问题
//#include <iostream>
//using namespace std;
//long long a, b;
//int main() {
//	cin >> a >> b ;
//	
//	long long ans = a *b;
//	cout  << ans;
//	system("pause");
//	return 0;
//}

//计算2的幂
//#include <iostream>
//#include<cmath>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//
//	long long ans = pow(2, n);
//	cout << ans;
//	system("pause");
//	return 0;
//}

//1.4编程基础之逻辑表达式与条件分支
//#include <iostream>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//	if (n > 0) {
//		cout << "positive";
//	}
//	else if (n == 0) {
//		cout << "zero";
//	}
//	else{
//		cout << "negative";
//	}
//	system("pause");
//}

//输出绝对值
//#include <iostream>
//#include <iomanip>
//#include<cmath>
//using namespace std;
//float n;
//int main() {
//	cin >> n;
//	cout << fixed << setprecision(2) << abs(n);
//	system("pause");
//}

//奇偶数判断
//#include <iostream>
//#include <iomanip>
//#include<cmath>
//using namespace std;
//int n;
//int main() {
//	cin >> n;
//	if (n % 2 == 1) {
//		cout << "odd";
//	}
//	else {
//		cout << "even";
//	}
//	system("pause");
//}

//奇偶ASCII值判断 ？
//#include <iostream>
//#include <iomanip>
//using namespace std;
//char ch;
//int main() {
//	ch = getchar();//cin>>ch报错
//	if ((int)ch % 2 == 1) {
//		cout << "YES";
//	}
//	else {
//		cout << "NO";
//	}
//	system("pause");
//	return 0;
//}

// 整数大小比较
//#include <iostream>
//#include <iomanip>
//using namespace std;
//long long x, y;
//int main() {
//	cin >> x >> y;
//	if (x > y) {
//		cout << ">";
//	}
//	else if (x < y) {
//		cout << "<";
//	}
//	else {
//		cout << "=";
//	}
//	system("pause");
//	return 0;
//}

//判断是否为两位数
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x ;
//	if (x>=10&&x<=99) {
//		cout << "1";
//	}
//	else {
//		cout << "0";
//	}
//	system("pause");
//	return 0;
//}


//收集瓶盖赢大奖
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x,y;
//int main() {
//	cin >> x>>y;
//	if (x >= 10||y>=20) {
//		cout << "1";
//	}
//	else {
//		cout << "0";
//	}
//	system("pause");
//	return 0;
//}

//判断一个数能否同时被3和5整除
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x ;
//	if (x %3 == 0 && x%5 == 0) {
//		cout << "YES";
//	}
//	else {
//		cout << "NO";
//	}
//	system("pause");
//	return 0;
//}


//判断能否被3，5，7整除
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//
//int main() {
//	cin >> x;
//	bool flag = false;
//	if (x % 3 == 0) {
//		cout << "3";
//		flag = true;
//		if (x % 5 == 0) {
//			cout << " 5";
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//		else {
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//	}
//	else {
//		if (x % 5 == 0) {
//			flag = true;
//			cout << "5";
//			if (x % 7 == 0) {
//				cout << " 7";
//			}
//		}
//		else {
//			if (x % 7 == 0) {
//				flag = true;
//				cout << "7";
//			}
//		}
//	}
//	if (!flag) {
//		cout << 'n';
//	}
//
//
//	system("pause");
//	return 0;
//}

//有一门课不及格的学生
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x,y;
//int main() {
//	cin >> x>>y;
//	bool flag = false;
//	if ((x < 60 && y>=60)|| y < 60 && x >= 60) {
//		cout << 1;
//	}
//	else {
//		cout << 0;
//	}
//	
//	system("pause");
//	return 0;
//}

//晶晶赴约会
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x;
//	if (x == 1 || x == 3 || x == 5) {
//		cout << "NO";
//	}
//	else {
//		cout << "YES";
//	}
//
//	system("pause");
//	return 0;
//}

//骑车与走路
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int x;
//int main() {
//	cin >> x;
//	double walk = x / 1.2;
//	double bike = x / 3.0 + 27 + 23;
//	if (walk > bike) {
//		cout << "Bike";
//	}
//	else if(walk<bike){
//		cout << "Walk";
//	}
//	else {
//		cout << "All";
//	}
//	system("pause");
//	return 0;
//}

//	分段函数
//#include <iostream>
//#include <iomanip>
//using namespace std;
//double x;
//double y = 0.0;
//int main() {
//	cin >> x;
//	
//	if (x>=0&& x<5) {
//		y = -x + 2.5;
//	}
//	else if (x>=5&&x<10) {
//		y = 2 - 1.5*(x - 3)*(x - 3);
//	}
//	else {
//		y = x / 2 - 1.5;
//	}
//	cout <<fixed<<setprecision(3)<< y;
//	system("pause");
//	return 0;
//}


//计算邮资
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x;
//char ch;
//int tot = 0;
//int main() {
//	cin >> x>>ch;
//
//	if (x <=1000) {
//		tot = tot + 8;
//	}
//	else  {
//		int k = ceil((double(x) - 1000.0) / 500.0);
//		//cout << (double(x) - 1000.0) / 500.0;
//		tot = tot + 8 + k * 4;
//	}
//	if (ch == 'y') {
//		tot = tot + 5;
//	}
//	cout << tot;
//	system("pause");
//	return 0;
//}

//最大数输出
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x, y, z;
//int m;
//int main() {
//	cin >> x >> y >> z;
//	m = x;
//	if (y > m) {
//		m = y;
//	}
//	if (z > m) {
//		m = z;
//	}
//	cout << m;
//	system("pause");
//	return 0;
//}

//三角形判断
//#include <iostream>
//#include <iomanip>
//#include <cmath>
//using namespace std;
//int x, y, z;
//int main() {
//	cin >> x >> y >> z;
//	if (x +y >z&& x+z>y&&y+z>x) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	system("pause");
//	return 0;
//}

//判断闰年
//#include <iostream>
//using namespace std;
//int a;
//int main() {
//	cin >> a;
//	if (a % 100 == 0) {
//		if (a % 400 == 0) {
//			cout << "Y";
//		}
//		else cout << "N";
//	}
//	else if (a % 4 == 0) {
//		cout << "Y";
//	}
//	else {
//		cout << "N";
//	}
//	system("pause");
//}


//点和正方形的关系
//#include <iostream>
//using namespace std;
//int x, y;
//int main() {
//	cin >> x >> y;
//	if (x <= 1 && x >= -1 && y <= 1 && y >= -1) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	system("pause");
//}

//简单计算器
//#include <iostream>
//using namespace std;
//int x, y;
//char ch;
//int main() {
//	cin >> x >> y >> ch;
//	if (ch == '+') {
//		cout << x + y;
//	}
//	else if (ch == '-') {
//		cout << x - y;
//	}
//	else if (ch == '*') {
//		cout << x * y;
//	}
//	else if (ch == '/') {
//		if (y == 0) {
//			cout << "Divided by zero!";
//		}
//		else {
//			cout << x / y;
//		}
//	}
//	else {
//		cout << "Invalid operator!";
//	}
//	system("pause");
//	return 0;
//}

//求一元二次方程的根
//#include <iostream>
//#include <cmath>
//#include<iomanip>
//using namespace std;
//double a, b, c;
//int main() {
//	cin >> a >> b >> c;
//	if (b *b == 4 * a * c) {
//
//		cout << "x1=x2=" << fixed << setprecision(5) << (-b + sqrt(b*b - 4 * a*c)) / (2 * a);
//	}
//	else if (b*b > 4 * a * c) {
//
//		cout << "x1=" << fixed << setprecision(5) << (-b + sqrt(b*b - 4 * a*c)) / (2 * a) << ";";
//		cout << "x2=" << fixed << setprecision(5) << (-b - sqrt(b*b - 4 * a*c)) / (2 * a);
//	}
//	else if (b*b < 4 * a * c) {
//		if (b != 0) {
//			cout << "x1=" << fixed << setprecision(5) << -b / (2 * a) << '+' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i' << ";";
//			cout << "x2=" << fixed << setprecision(5) << -b / (2 * a) << '-' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i';
//		}
//		else {
//			cout << "x1=" << fixed << setprecision(5) << 0.0 << '+' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i' << ";";
//			cout << "x2=" << fixed << setprecision(5) << 0.0 << '-' << fixed << setprecision(5) << sqrt(4 * a*c - b * b) / (2 * a) << 'i';
//
//		}
//	}
//	system("pause");
//	return 0;
//}

//苹果和虫子2
//#include<iostream>
//#include<math.h>//ceil向上取整要包含头文件
//using namespace std;
//int n, x, y;
//int main() {
//	cin >> n >> x >> y;
//	int bad = ceil(double(y) / double(x));
//	int ans = n - bad;
//	if (ans < 0) {
//		cout << 0;
//	}
//	else {
//		cout << ans;
//	}
//	system("pause");
//}

// 1.5编程基础之循环控制
//	求平均年龄
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int n;
//int sum = 0;
//int main() {
//	cin >> n;
//	int tot = n;
//	int temp;
//	while (n--) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / double(tot);
//	cout <<fixed <<setprecision(2)<< ave;
//	system("pause");
//}

//财务管理
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double temp;
//	double sum = 0;
//	for(int i = 0; i < 12; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / 12.0;
//	cout << "$"<<fixed << setprecision(2) << ave;
//	system("pause");
//}


//均值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double temp;
//	double sum = 0;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) /double(n);
//	cout <<  fixed << setprecision(4) << ave;
//	system("pause");
//}

//求整数的和与均值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	long long temp;
//	long long sum = 0;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		sum = sum + temp;
//	}
//	double ave = double(sum) / double(n);
//	cout <<sum<<" "<< fixed << setprecision(5) << ave;
//	system("pause");
//}


//最高的分数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int m,f,temp;
//	int n;
//	cin >> n;
//	cin >> f;
//	m = f;
//	for (int i = 1; i < n; i++) {
//
//		cin >> temp;
//		if (temp > m) {
//			m = temp;
//		}
//	}
//	
//	cout << m;
//	system("pause");
//}

//整数序列的元素最大跨度值
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int m,s, f, temp;
//	int n;
//	cin >> n;
//	cin >> f;
//	m = f;
//	s = f;
//	for (int i = 1; i < n; i++) {
//
//		cin >> temp;
//		if (temp > m) {
//			m = temp;
//		}
//		if (temp < s) {
//			s = temp;
//		}
//	}
//
//	cout << m - s;
//	system("pause");
//}

//奥运奖牌计数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n;
//	int tj, ty, tt;
//	int j = 0;
//	int y = 0;
//	int t = 0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> tj >> ty >> tt;
//		j += tj;
//		y += ty;
//		t += tt;
//	}
//	cout << j<<" "<<y<<" "<<t<<" "<<j+y+t;
//	system("pause");
//}

//多边形内角和
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n,temp;
//	cin >> n;
//	int sum = 0;
//	for (int i = 0; i < n-1; i++) {
//		cin >> temp;
//		sum += temp;
//	}
//	cout << (n-2)*180 - sum;
//	system("pause");
//}

//奇数求和
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m;
//	int sum = 0;
//	cin >> n >> m;
//	if (n % 2 == 1) {
//		for (int i = n; i <= m; i = i + 2) {
//			
//				sum += i;
//			
//		}
//	}
//	else {
//		for (int i = n+1; i <= m; i = i + 2) {
//
//			sum += i;
//
//		}
//	}
//	
//	cout << sum;
//	system("pause");
//}

//满足条件的数累加
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m;
//	int sum = 0;
//	cin >> n >> m;
//	
//		for (int i = n; i <= m; i++) {
//			if (i % 17 == 0) {
//				sum += i;
//			}
//		}
//	
//	cout << sum;
//	system("pause");
//}

//整数的个数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	int n, m, temp;
//	int sum = 0;
//	cin >> n >> m;
//
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		if (temp == m) {
//			sum++;
//		}
//	}
//	cout << sum;
//	system("pause");
//}

//乘方计算
//#include<iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n, m;
//	long long ans;
//	cin >> n >> m;
//
//	ans = pow(n, m);
//	cout << ans;
//	system("pause");
//}

//人口增长问题
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int x,n;
//	double  ans;
//	cin >> x >> n;
//	ans = double(x);
//	for (int i = 0; i < n; i++) {
//		ans = ans *(1+ 0.1 / 100);
//	}
//	cout <<fixed<<setprecision(4)<< ans;
//	system("pause");
//}

//银行利息 ????
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int r, m, y;
//	cin >> r >> m >> y;
//	double ans = m;
//	for (int i = 0; i < y; i++) {
//		ans = ans * (100 + r) / 100;
//		//cout << ans << endl;
//	}
//	int q = floor(ans);
//	cout << q;
//	system("pause");
//	return 0;
//}


//买房子
//#include<iostream>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int n, k;
//	cin >> n >> k;
//	double price = 200.0;
//	double salary = double(n);
//	int flag = 0;
//	for (int i = 1;i<=20; i++) {
//		
//		if (salary >= price) {
//			cout << i;
//			flag = 1;
//			break;
//		}
//		price = price * (100 + k) / 100;
//		salary += n;
//	}
//	if (!flag) {
//		cout << "Impossible";
//	}
//	system("pause");
//	return 0;
//}


//菲波那契数列 ?
//#include <iostream>
//#include<string.h>//memset函数要头文件string.h
//using namespace std;
//const int maxn = 50;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	m[1] = 1;
//	m[2] = 1;
//	int k;
//	cin >> k;
//	if (k <= 2) {
//		cout << 1;
//	}
//	else {
//		for (int i = 3; i <= k; i++) {
//			m[i] = m[i - 1] + m[i - 2];
//		}
//		cout << m[k];
//	}
//	system("pause");
//	return 0;
//}

//鸡尾酒疗法
//#include <iostream>
//using namespace std;
//int main() {
//	int n, stanx, stany;
//	cin >> n;
//	cin >> stanx >> stany;
//	double stan = double(stany) / double(stanx);
//	int tempx, tempy;
//	double temp;
//	for (int i = 1; i < n; i++) {
//		cin >> tempx >> tempy;
//		temp = double(tempy) / double(tempx);
//	
//		if (temp - stan > 0.05) {
//			cout << "better" ;
//		}
//		else if (stan  - temp> 0.05) {
//			cout << "worse" ;
//		}
//		else {
//			cout << "same" ;
//		}
//		if (i < n - 1) {
//			cout << endl;
//		}
//	}
//	system("pause");
//}

//救援 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	double x, y;//读清题目条件 输入为实数
//	int z;
//	double t = 0.0;
//	for (int i = 0; i < n; i++) {
//		cin >> x >> y >> z;
//		double dist = sqrt(pow(x, 2) + pow(y, 2));
//		//cout << dist << " " << 2 * dist / 50 << endl;
//		t = t + 2 * dist / 50 + z * 1.5;
//	}
//	cout << ceil(t);
//	system("pause");
//}

//球弹跳高度的计算
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n = 10;
//	int h;
//	cin >> h;
//	double tot = 0.0;
//	double len = double(h);
//	tot = tot + len;
//	len = len / 2;
//	for (int i = 2; i <= n; i++) {
//		tot = tot + 2 * len;
//		len = len / 2;
//	}
//	printf("%g\n%g", tot, len);
//	system("pause");
//}


//角谷猜想 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	long int n, temp;//用long int 不然会报错
//	cin >> n;
//	if (n == 1) {
//		cout << "End";
//	}
//	else {
//		while (n != 1) {
//			if (n % 2 == 1) {
//				temp = n * 3 + 1;
//				cout << n << "*3+1=" << temp << endl;
//				n = temp;
//			}
//			else {
//				temp = n / 2;
//				cout << n << "/2=" << temp << endl;
//				n = temp;
//			}
//		}
//		cout << "End";
//	}
//	system("pause");
//	return 0;
//}

//津津的储蓄计划 ??
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n = 12;
//	int temp, rest = 0;
//	int win = 0;
//	bool flag = true;
//	for (int i = 1; i <= n; i++) {
//		rest = rest + 300;
//		cin >> temp;
//		if (temp > rest) {
//			cout << "-" << i;
//			flag = false;
//			break;
//		}
//		else {
//			rest = rest - temp;
//			win = win + 100 * (rest / 100);
//			rest = rest - 100 * (rest / 100);
//		}
//		//cout << rest << " " << win << endl;
//	}
//	if (flag) {
//		cout << win * 1.2 + rest;//最后一个月可能还剩下钱
//	}
//	system("pause");
//	return 0;
//}


//药房管理
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int tot, n, temp, cnt = 0;
//	cin >> tot >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		if (temp <= tot) {//可以取等
//			tot = tot - temp;
//		}
//		else {
//			cnt++;
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//正常血压 
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int n,h,l;
//	int cnt = 0,max = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> h>>l;
//		if (h>=90 &&h<=140&&l>=60&&l<=90) {
//			cnt++;
//			if (cnt >= max) {
//				max = cnt;
//			}
//		}
//		else {
//			cnt = 0;
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//求特殊自然数 ？
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  s, n;
//	int m[3];
//	bool flag = true;
//	for (int i = 101; i <= 666; i++) {//因为7进制数不能出现大于7的数字
//		int temp = i;
//		for (int j = 0; j < 3; j++) {
//			m[j] = temp % 10;
//			temp = temp / 10;
//			//cout << m[j] << endl;
//		}
//		s = m[0] + m[1] * 7 + m[2] * 49;
//		n = m[0] * 81 + m[1] * 9 + m[2];
//		if (m[0] < 7 && m[1] < 7 && s == n) {//因为7进制数不能出现大于7的数字
//			if (flag) {
//				cout << s << endl << m[2] << m[1] << m[0] << endl << m[0] << m[1] << m[2];
//				flag = false;
//			}
//			else {
//				cout << endl << s << endl << m[2] << m[1] << m[0] << endl << m[0] << m[1] << m[2];
//			}
//		}
//
//	}
//
//	system("pause");
//	return 0;
//}

//统计满足条件的4位数个数
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  n;
//	int cnt = 0;
//	int temp;
//	int m[4];
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		for (int j = 0; j < 4; j++) {
//			m[j] = temp % 10;
//			temp = temp / 10;
//		}
//		int ans = m[0] - m[1] - m[2] - m[3];
//		if (m[0] - m[1] - m[2] - m[3] > 0) {
//			cnt++;
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//级数求和
//#include <iostream>
//#include<cmath>
//using namespace std;
//int main() {
//	int  n;
//	cin >> n;
//	double s = 0.0;
//	int i;
//	for ( i = 1; s <= n; i++) {
//		if (s > n) {
//			cout << i;
//		}
//		else {
//			
//			s = s + 1.0 / i;
//			//cout << s << endl;
//		}
//	}
//	cout << i-1;
//	system("pause");
//	return 0;
//}

//分离整数的各个数位
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int main() {
//	long int  n;
//	cin >> n;
//	int i;
//	for (i = 0;; i++) {
//		if (n == 0) {
//			break;
//		}
//		else {
//			m[i] = n % 10;
//			n = n / 10;
//		}
//	}
//	bool flag = true;
//	for (int j = 0; j < i; j++) {
//		if (flag) {
//			cout << m[j];
//			flag = false;
//		}
//		else {
//			cout << " " << m[j];
//		}
//	}
//	system("pause");
//	return 0;
//}

//数字反转  之后又自己重新写了
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int main() {
//	long int  n;
//	cin >> n;
//	int i;
//	bool nag = false;
//	if (n < 0) {
//		n = -n;
//		nag = true;
//	}
//	for (i = 0;; i++) {
//		if (n == 0) {
//			break;
//		}
//		else {
//			m[i] = n % 10;
//			n = n / 10;
//		}
//	}
//	bool flag = true;
//	if (nag) {
//		cout << "-";
//	}
//	for (int j = 0; j < i; j++) {
//		
//		if (flag) {
//			if (m[j] != 0) {
//				cout << m[j];
//				flag = false;
//			}
//		}
//		else {
//			cout << m[j];
//		}
//		
//	}
//	system("pause");
//	return 0;
//}


//含k个3的数
//#include <iostream>
//#include<cmath>
//using namespace std;
//const int maxn = 15;
//int matrix[maxn];
//int main() {
//	int  m,k,cnt = 0;
//	cin >> m>>k;
//	int i;
//	if (m % 19 == 0) {
//		for (i = 0;; i++) {
//			if (m == 0) {
//				break;
//			}
//			else {
//				matrix[i] = m % 10;
//				m = m / 10;
//			}
//		}
//		for (int j = 0; j < i; j++) {
//				if (matrix[j] == 3) {
//					cnt++;
//				}
//		}
//		if (cnt == k) {
//			cout << "YES";
//			system("pause");
//			return 0;
//		}
//	}
//	cout << "NO";
//	system("pause");
//	return 0;
//}

//开关灯
//#include <iostream>
//#include<cmath>
//#include <string.h>
//using namespace std;
//const int maxn = 5001;
//int matrix[maxn];
//int main() {
//	memset(matrix, 0, sizeof(matrix));
//	
//	int  n, m;
//	cin >> n >> m;
//	for (int i = 1; i <= m; i++) {
//		for (int j = i; j <= n; j = j + i) {//这里的步长是i，不是m
//			matrix[j] = matrix[j] + 1;
//			/*for (int k = 1; k <= 5; k++) {
//				cout << matrix[k] << " ";
//			}
//			cout << endl;*/
//		}
//		//cout << "i:" << i << endl;
//	}
//	bool flag = true;
//	for (int i = 1; i <= n; i++) {
//		if (matrix[i] % 2 == 1) {
//			if (flag) {
//				cout << i;
//				flag = false;
//			}
//			else {
//				cout << "," << i;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//求分数序列和
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 35;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	m[1] = 1;
//	m[2] = 2;
//	int  n;
//	cin >> n;
//	for (int i = 3; i <= n + 1; i++) {
//		m[i] = m[i - 1] + m[i - 2];
//		//cout << m[i] << endl;
//	}
//	double sum = 0.0;
//	for (int i = 1; i <= n; i++) {
//		sum = sum + double(m[i + 1]) / double(m[i]);
//		//cout << "sum: " << sum << endl;
//	}
//	cout << fixed << setprecision(4) << sum;
//	system("pause");
//	return 0;
//}

//计算分数加减表达式的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//
//int main() {
//	double sum = 0.0;
//	int  n;
//	cin >> n;
//	for (int i = 1; i <= n ; i++) {
//		sum = sum - pow(-1, i)*1.0/double(i);
//	}
//	
//	cout << fixed << setprecision(4) << sum;
//	system("pause");
//	return 0;
//}

//求阶乘的和
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	long int sum = 1;
//	long int part = 1;
//	int  n;
//	cin >> n;
//	for (int i = 2; i <= n; i++) {
//		part = part * i;
//		sum = sum + part;
//		//cout <<" "<< sum << endl;
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//求出e的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	double sum = 2.0;
//	long int part = 1;
//	int  n;
//	cin >> n;
//	for (int i = 2; i <= n; i++) {
//		part = part * i;
//		sum = sum + 1/double(part);
//		
//	}
//	cout <<fixed<<setprecision(10)<< sum;
//	system("pause");
//	return 0;
//}

//计算多项式的值
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	double sum = 1.0;
//	float part = 1;
//	int n;
//	float x;
//	cin >> x >> n;
//	for (int i = 1; i <= n; i++) {
//		part = part * x;
//		sum = sum + part;
//
//	}
//	cout << fixed << setprecision(2) << sum;
//	system("pause");
//	return 0;
//}

//雇佣兵 注意理解题意
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int m, n, x;
//	cin >> m >> n >> x;
//	while (1) {
//		if (n > m) {
//			cout << n;
//			break;
//		}
//		else if (x*n < m) {
//			cout << n;
//			break;
//		}
//		else {
//			x = x - ceil(double(m) / double(n));
//			int add = m / n;
//			n = n + add;
//		}
//	}
//	
//	//cout << fixed << setprecision(2) << sum;
//	system("pause");
//	return 0;
//}

//计算多项式的导函数 样例输入第一行的3删掉 从第二行开始看
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n,temp;
//	bool flag = true;
//	cin >> n;
//	if (n == 0) {
//		cout << 0;
//	}
//	else {
//		for (int i = n; i > 0; i--) {
//			
//			cin >> temp;
//			if (flag) {
//				cout << i * temp;
//				flag = false;
//			}
//			else {
//				cout << " " << i * temp;
//			}
//			
//		}
//	}
//	system("pause");
//	return 0;
//}

//与7无关的数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 5;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	bool flag = false;
//	long long n, sum = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		if (i % 7 == 0) {
//			flag = true;
//		}
//		else {
//			long long temp = i;
//			for (int j = 1; temp > 0; j++) {
//				m[j] = temp % 10;
//				temp = temp / 10;
//			}
//			for (int k = 1; k <= 3; k++) {
//				if (m[k] == 7) {
//					flag = true;
//				}
//			}
//		}
//		if (!flag) {
//			sum = sum + pow(i, 2);
//			
//		}
//		flag = false;
//		//cout <<i<< " "<< sum << endl;
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//数1的个数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 6;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n, cnt = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		int temp = i;
//		while (temp != 0) {
//			if (temp % 10 == 1) {
//				cnt++;
//			}
//			temp = temp / 10;
//			//cout << temp << endl;
//		}
//		//cout << i << " " << cnt << endl;
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//数字统计
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n, m, cnt = 0;
//	cin >> n >> m;
//	for (int i = n; i <= m; i++) {
//		int temp = i;
//		while (temp != 0) {
//			if (temp % 10 == 2) {
//				cnt++;
//			}
//			temp = temp / 10;
//			//cout << temp << endl;
//		}
//		//cout << i << " " << cnt << endl;
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//画矩形
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int row, col, flag;
//	char ch;
//	cin >> row >> col >> ch >> flag;
//	for (int i = 1; i <= col; i++) {
//		cout << ch;
//	}
//	cout << endl;
//	for (int j = 2; j < row; j++) {
//		if (flag) {
//			for (int i = 1; i <= col; i++) {
//				cout << ch;
//			}
//			cout << endl;
//		}
//		else {
//			cout << ch;
//			for (int i = 2; i < col; i++) {
//				cout << " ";
//			}
//			cout << ch;
//			cout << endl;
//		}
//	}
//	for (int i = 1; i <= col; i++) {
//		cout << ch;
//	}
//	system("pause");
//	return 0;
//}

//质因数分解 ??
//分析：题目要我们求的，是某个数的最大质因数，首先，要求的数要先满足两个条件
//（1） 它要是个质数 （2）它要能被题目所给数整除
//好了 一般思路，从小到大循环求这个数（从小到大查找可以极大减小运行次数），看看能不能把题目所给的数整除，而且还要是个质数，是就输出，解决；
//但问题真的那么简单吗，仔细思考，我们会发现，题目已经保障了数据一定是两个质数想乘而得到的，这意味着除了1和它本身，它只能被其他两个质数整除，
//所以，还判断什么质数啊，找到可以整除的最大数，直接输出吧，骚年。
//（注意从小到大进行查找）
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 2; i*i <= n; i++) {
//		if (n%i == 0) {
//			cout << n / i;
//		}
//	}
//	system("pause");
//	return 0;
//}

//第n小的质数
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	int cnt = 0;
//	bool flag = true;
//	cin >> n;
//	int i;
//	for (i = 2; cnt < n; i++) {
//		for (int j = 2; j*j <= i; j++) {//要取等号
//			if (i%j == 0) {
//				flag = false;
//				break;
//			}
//		}
//		if (flag) {
//			cnt++;
//		}
//		flag = true;
//	}
//	cout << i-1;
//	system("pause");
//	return 0;
//}

////金币
//#include <iostream>
//#include<cmath>
//#include <string.h>
//#include <iomanip>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int d = 0;
//	int sum = 0;
//	for (int i = 1;; i++) {
//		for (int j = 1; j <= i; j++) {
//			sum = sum + i;
//			d++;
//			if (d == n) {
//				cout << sum;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	return 0;
//}

//1.6编程基础之一维数组
//与指定数字相同的数的个数
//#include <iostream>
//#include<string.h>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n, tar, temp,cnt =0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		m[i] = temp;
//		
//	}
//	cin >> tar;
//	for (int i = 0; i < n; i++) {
//		if (m[i] == tar) {
//			cnt++;
//			
//		}
//	}
//	cout << cnt;
//	system("pause");
//}

//陶陶摘苹果
//#include <iostream>
//#include<string.h>
//using namespace std;
//const int maxn = 11;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int can, temp, cnt = 0;
//	
//	for (int i = 0; i < 10; i++) {
//		cin >> temp;
//		m[i] = temp;
//
//	}
//	cin >> can;
//	for (int i = 0; i < 10; i++) {
//		if (m[i] <= can+30) {
//			cnt++;
//
//		}
//	}
//	cout << cnt;
//	system("pause");
//}

//计算书费
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//float book[maxn] = { 28.9,32.7 ,45.6,78.0,35.0, 86.2 ,27.8 ,43.0 ,56.0,65.0 };
//int main() {
//	float tot = 0.0;
//	int temp;
//	for (int i = 0; i < 10; i++) {
//		cin >> temp;
//		tot = tot + book[i] * temp;
//	}
//	cout << fixed << setprecision(1) << tot;
//	system("pause");
//}

//数组逆序重放
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//int m[maxn];
//int main() {
//	int n, temp;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		m[i] = temp;
//	}
//	bool flag = true;
//	for (int i = n-1; i >= 0; i--) {
//		if (flag) {
//			cout << m[i];
//			flag = false;
//		}
//		else {
//			cout << " " << m[i];
//		}
//	}
//	system("pause");
//}

//年龄与疾病
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10;
//int m[maxn];
//int cnt[4];
//int main() {
//	int n, temp;
//	memset(cnt, 0, sizeof(cnt));
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		if (temp <= 18 && temp >= 0) {
//			cnt[0] = cnt[0] + 1;
//		}
//		if (temp <= 35 && temp >= 19) {
//			cnt[1] = cnt[1] + 1;
//		}
//		if (temp <= 60 && temp >= 36) {
//			cnt[2] = cnt[2] + 1;
//		}
//		if (temp >= 61) {
//			cnt[3] = cnt[3] + 1;
//		}
//	}
//	bool flag = true;
//	for (int i = 0; i < 4; i++) {
//		if (flag) {
//			cout << fixed << setprecision(2) << double(cnt[i]) / double(n)*100.0 << "%";
//			flag = false;
//		}
//		else {
//			cout << endl << fixed << setprecision(2) << double(cnt[i]) / double(n)*100.0 << "%";
//		}
//	}
//	system("pause");
//}

//校门外的树 ？
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	int len, amount, templ, tempr,cnt=0;
//	memset(m, 0, sizeof(m));
//
//	cin >> len >> amount;
//	for (int i = 0; i < amount; i++) {
//		cin >> templ >> tempr;
//		for (int j = templ; j <= tempr; j++) {
//			m[j] = 1;
//		}
//	}
//	for (int i = 0; i <= len; i++) {//这里要取0，因为0处也要种树
//		if(m[i]==1){
//			cnt++;
//		}
//	}
//	cout << len + 1 - cnt;
//	system("pause");
//}

//有趣的跳跃 注意是排序后的
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 3010;
//long long m[maxn];
//long long ans[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(ans, 0, sizeof(ans));
//	int  n, cnt = 0;
//	long long temp;
//	cin >> n;
//	if (n == 1) {
//		cout << "Jolly";
//	}
//	else {
//		cin >> m[0];
//		for (int i = 1; i < n; i++) {
//			cin >> m[i];
//		}
//		for (int i = 0; i < n - 1; i++) {
//			ans[i] = abs(m[i] - m[i + 1]);//注意这里的范围，是m+1而不是m-1
//		}
//		sort(ans, ans + n - 1);
//		for (int i = 0; i < n - 2; i++) {
//			//cout << ans[i] << " ";
//			if (ans[i] - ans[i + 1] != -1) {
//				cout << "Not jolly";
//				system("pause");
//				return 0;
//			}
//		}
//		cout << "Jolly";
//	}
//	system("pause");
//	return 0;
//}

//石头剪刀布
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 110;
//int a[maxn], b[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	int n, na, nb,cnta= 0,cntb = 0;
//	cin >> n >> na >> nb;
//	for (int i = 0; i < na; i++) {
//		cin >> a[i];
//	}
//	for (int i = 0; i < nb; i++) {
//		cin >> b[i];
//	}
//	for (int i = 0; i < n; i++) {
//		a[i] = a[i%na];
//		b[i] = b[i%nb];
//	}
//	for (int i = 0; i < n; i++) {
//		if (a[i] == 0) {
//			if (b[i] == 2) {
//				cnta++;
//			}
//			else if (b[i] == 5) {
//				cntb++;
//			}
//		}
//		if (a[i] == 2) {
//			if (b[i] == 5) {
//				cnta++;
//			}
//			else if (b[i] == 0) {
//				cntb++;
//			}
//		}
//		if (a[i] == 5) {
//			if (b[i] == 0) {
//				cnta++;
//			}
//			else if (b[i] == 2) {
//				cntb++;
//			}
//		}
//	}
//	if (cnta > cntb) {
//		cout << "A";
//	}
//	else if (cnta < cntb) {
//		cout << "B";
//	}
//	else {
//		cout << "draw";
//	}
//	system("pause");
//	return 0;
//}

//向量点积计算
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 1100;
//int a[maxn], b[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	int n;
//	long long sum = 0;//不然会溢出
//	cin >> n ;
//	for (int i = 0; i < n; i++) {
//		cin >> a[i];
//	}
//	for (int i = 0; i < n; i++) {
//		cin >> b[i];
//	}
//	
//	for (int i = 0; i < n; i++) {
//		sum = sum + a[i] * b[i];
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//大整数加法
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 210;
//char a[maxn], b[maxn], ra[maxn], rb[maxn]; //用于存储输入和反转后的数组
//int aa[maxn], bb[maxn];//数字化数组
//int result[maxn];
//int carry[maxn];
//int main() {
//	//一定要初始化 因为可能会进位，要确保每一位进位时原来就是0
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(result, 0, sizeof(result));
//	memset(carry, 0, sizeof(carry));
//	memset(aa, 0, sizeof(aa));//重新开一个数组，确保后面每一位都是0
//	memset(bb, 0, sizeof(bb));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0, cntb = 0;
//	//统计开头的0的个数 方便后面翻转时不要把高位0也算进去了
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != '0') {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != '0') {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//	//这里是考虑边界情况，如果0+0，即字符串的长度等于高位0的个数，此时直接输出0
//	if (lena - cnta == 0 && lenb - cntb == 0) {
//		cout << 0;
//	}
//	//翻转数组 方便处理，不用翻转高位0，此时先不处理len 因为从最小位开始往前去 需要定位到len
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//	//翻转完之后再跟新len  并求最长len
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lenb * (lena < lenb) + lena * (lena >= lenb);
//	//_strrev(a);//编译器不让用
//	//_strrev(b);
//
//	//将字符转化为数字 要重新开一个int数组 因为后面计算是基于数字的  不是基于char的（ascii码）
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//	//先不考虑进位 直接相加
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = aa[i] + bb[i];
//		result[i + 1] = 0;//防止最后一位有进位
//		//cout << "i: " << i << " " << result[i] << endl;
//	}
//	//考虑进位 注意 这里应该先将当前位的数 加上进位位后 在计算下一个下一个进位位和当前的数
//	for (int i = 0; i < lenmax + 1; i++) {//最后一位可能有进位
//		result[i] = result[i] + carry[i];
//		carry[i + 1] = (result[i]) / 10;
//		result[i] = result[i] % 10;
//	}
//
//	//可能最高位进位了 则lenmax+1
//	if (result[lenmax] != 0) {
//		lenmax++;
//	}
//	//倒着输出
//	for (int i = lenmax - 1; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}


//大整数加法 法二
//#include <iostream>
//#include <string.h>
//using namespace std;
//const int maxn = 210;
//char a[maxn];
//char b[maxn];
//char ra[maxn];
//char rb[maxn];
//int aa[maxn];
//int bb[maxn];
//int result[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(aa, 0, sizeof(aa));
//	memset(bb, 0, sizeof(bb));
//	memset(result, 0, sizeof(result));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0;
//	int cntb = 0;
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != 0) {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != 0) {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lena * (lena >= lenb) + lenb * (lenb > lena);
//
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//	int temp, carry = 0;
//	for (int i = 0; i < lenmax + 1; i++) {
//		temp = aa[i] + bb[i] + carry;
//		result[i] = temp % 10;
//		carry = temp / 10;
//	}
//	if (result[lenmax] != 0) {
//		lenmax++;
//	}
//	for (int i = lenmax - 1; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}


//大整数减法
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 210;
//char a[maxn], b[maxn], ra[maxn], rb[maxn]; //用于存储输入和反转后的数组
//int aa[maxn], bb[maxn];//数字化数组
//int result[maxn];
//int carry[maxn];
//int main() {
//	//一定要初始化 因为可能会进位，要确保每一位进位时原来就是0
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	memset(ra, '0', sizeof(ra));
//	memset(rb, '0', sizeof(rb));
//	memset(result, 0, sizeof(result));
//	memset(carry, 0, sizeof(carry));
//	memset(aa, 0, sizeof(aa));//重新开一个数组，确保后面每一位都是0
//	memset(bb, 0, sizeof(bb));
//
//	cin >> a;
//	cin >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnta = 0, cntb = 0;
//	//统计开头的0的个数 方便后面翻转时不要把高位0也算进去了
//	for (int i = 0; i < lena; i++) {
//		if (a[i] != '0') {
//			break;
//		}
//		else {
//			cnta++;
//		}
//	}
//	for (int i = 0; i < lenb; i++) {
//		if (b[i] != '0') {
//			break;
//		}
//		else {
//			cntb++;
//		}
//	}
//	//这里是考虑边界情况，如果0+0，即字符串的长度等于高位0的个数，此时直接输出0
//	if (lena - cnta == 0 && lenb - cntb == 0) {
//		cout << 0;
//	}
//	//翻转数组 方便处理，不用翻转高位0，此时先不处理len 因为从最小位开始往前去 需要定位到len
//	for (int i = 0; i < lena - cnta; i++) {
//		ra[i] = a[lena - i - 1];
//	}
//	for (int i = 0; i < lenb - cntb; i++) {
//		rb[i] = b[lenb - i - 1];
//	}
//	//翻转完之后再跟新len  并求最长len
//	lena = lena - cnta;
//	lenb = lenb - cntb;
//	int lenmax = lenb * (lena < lenb) + lena * (lena >= lenb);
//	//_strrev(a);//编译器不让用
//	//_strrev(b);
//
//	//将字符转化为数字 要重新开一个int数组 因为后面计算是基于数字的  不是基于char的（ascii码）
//	for (int i = 0; i < lena; i++) {
//		aa[i] = ra[i] - '0';
//	}
//	for (int i = 0; i < lenb; i++) {
//		bb[i] = rb[i] - '0';
//	}
//
//	//先不考虑进位 直接相减
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = aa[i] - bb[i];
//		//result[i + 1] = 0;//防止最后一位有进位
//		//cout << i << " " << result[i] << endl;
//	}
//
//	//考虑进位 注意 只要小于零 借位自动为1
//	for (int i = 0; i < lenmax; i++) {
//		result[i] = result[i] - carry[i];
//		if (result[i] < 0) {
//			carry[i + 1] = 1;
//		}
//		result[i] = (result[i] + 10) % 10;
//	}
//	int cnt = 0;
//	//最高位的0不输出
//	for (int i = lenmax - 1; i >= 0; i--) {
//		if (result[i] != 0) {
//			break;
//		}
//		else {
//			cnt++;
//		}
//	}
//	
//	//倒着输出
//	for (int i = lenmax - 1 - cnt; i >= 0; i--) {
//		cout << result[i];
//	}
//	system("pause");
//	return 0;
//}

//计算2的N次方
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 50;
//int a[maxn];
//int main() {
//	memset(a, 0, sizeof(a));
//	int n;
//	cin >> n;
//	int carry = 0;
//	int temp;
//	a[0] = 1;
//	while (n--) {
//		for (int i = 0; i < 50; i++) {
//			temp = a[i] * 2 + carry;
//			carry = temp / 10;
//			a[i] = temp % 10;
//		}
//	}
//	int j;
//	for (j = 49; j >= 0; j--) {
//		if (a[j] != 0) {
//			break;
//		}
//	}
//	for (; j >= 0; j--) {
//		cout << a[j];
//	}
//	system("pause");
//	return 0;
//}

//大整数的因子
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 35;
//char ch[maxn];
//int m[maxn];
//int main() {
//	memset(ch, '0', sizeof(ch));
//	memset(m, 0, sizeof(m));
//	int left, temp, cnt = 0, flag = 1;
//	cin >> ch;
//	int len = strlen(ch);
//	for (int i = 0; i < len; i++) {
//		m[i] = ch[i] - '0';
//	}
//	for (int i = 2; i < 10; i++) {
//		left = 0;
//		for (int j = 0; j < len; j++) {
//			temp = m[j] + 10 * left;
//			left = temp % i;
//		}
//		if (left == 0) {
//			if (flag) {
//				cout << i;
//				flag = 0;
//			}
//			else {
//				cout << " " << i;
//			}
//			cnt++;
//		}
//	}
//	if (!cnt) {
//		cout << "none";
//	}
//	system("pause");
//	return 0;
//}

//求10000以内n的阶乘
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 35670;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	long long left, temp;//防止溢出
//	cin >> n;
//	m[0] = 1;
//	for (int i = 1; i <= n; i++) {
//		left = 0;
//		for (int j = 0; j < maxn; j++) {
//			temp = m[j] * i + left;
//			m[j] = temp % 10;
//			left = temp / 10;
//		}
//	}
//	int k;
//	for (k = maxn; k >= 0; k--) {
//		if (m[k] != 0) {
//			break;
//		}
//	}
//	for (; k >= 0; k--) {
//		cout << m[k];
//	}
//
//
//	system("pause");
//	return 0;
//}

//阶乘和
//#include <iostream>
//#include<string.h>
//#include <iomanip>
//#include<algorithm>
//using namespace std;
//const int maxn = 200;
//int m[maxn],sum[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(sum, 0, sizeof(sum));
//	int n, alt,carry;
//	long long left, temp;//防止溢出
//	cin >> n;
//	m[0] = 1;
//	for (int i = 1; i <= n; i++) {
//		left = 0;
//		for (int j = 0; j < maxn; j++) {
//			temp = m[j] * i + left;
//			m[j] = temp % 10;
//			left = temp / 10;
//		}
//		carry = 0;
//		for (int a = 0; a < maxn; a++) {
//			alt = sum[a] + m[a] + carry;
//			sum[a] = alt % 10;
//			carry = alt / 10;
//		}
//	}
//	int k;
//	for (k = maxn; k >= 0; k--) {
//		if (sum[k] != 0) {
//			break;
//		}
//	}
//	for (; k >= 0; k--) {
//		cout << sum[k];
//	}
//
//	system("pause");
//	return 0;
//}

//1.7编程基础之字符串
//统计数字字符个数 isdigit()
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//int main() {
//	int cnt = 0;
//	char x;
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	while (ss >> x) {
//		if (isdigit(x)) {
//			cnt++;
//		}
//		//cout << x;
//	}
//	cout << cnt;
//	system("pause");
//}

//找第一个只出现一次的字符
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 100000;
//char ch[maxn];
//int res[maxn];
//int main() {
//	memset(ch, '0', sizeof(ch));
//	memset(res, 0, sizeof(res));
//	bool flag = false;
//	cin >> ch;
//	int len = strlen(ch);
//	for (int i = 0; i < len; i++) {
//		res[ch[i] - '0'] = res[ch[i] - '0'] + 1;
//		//cout << ch[i] << " " << res[ch[i] - '0'] << endl;
//	}
//	for (int i = 0; i < len; i++) {
//		if (res[ch[i] - '0'] == 1) {
//			cout <<ch[i];
//			flag = true;
//			break;
//		}
//	}
//	if (!flag) {
//		cout << "no";
//	}
//	system("pause");
//}

//基因相关性
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 100000;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	double h;
//	int cnt = 0;
//	cin >> h;
//	cin >> a>>b;
//	int len = strlen(a);
//	for (int i = 0; i < len; i++) {
//		if (a[i] == b[i]) {
//			cnt++;
//		}
//	}
//	double real = double(cnt) / double(len);
//	if (real >= h) {
//		cout << "yes";
//	}
//	else {
//		cout << "no";
//	}
//	
//	system("pause");
//}

//石头剪子布 ???
//#include<iostream>
//#include<string.h>
//#include<sstream>
//using namespace std;
//const int maxn = 1000;
//char a[maxn];
//char b[maxn];
//int main() {
//	int n;
//	cin >> n;
//	bool flag = true;
//	for (int i = 0; i < n; i++) {
//		cin >> a;
//		cin >> b;
//		/*if (flag) {
//		flag = false;
//		}
//		else {
//		cout << endl;
//		}*/
//		if ((a[0] == 'R'&&b[0] == 'S') || (a[0] == 'S'&&b[0] == 'P') || (a[0] == 'P'&&b[0] == 'R'))
//			cout << "Player1" << endl;
//		if ((b[0] == 'R'&&a[0] == 'S') ||( b[0] == 'S'&&a[0] == 'P') ||( b[0] == 'P'&&a[0] == 'R'))
//			cout << "Player2" << endl;
//		if (a[0] == b[0])
//			cout << "Tie" << endl;
//
//
//	}
//	system("pause");
//	return 0;
//}

//输出亲朋字符串 ? cin读不了空格
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);//gets_s 和 gets
//	int len = strlen(a);
//	for (int i = 0; i < len -1; i++) {
//		//b[i] = int(a[i] - NULL) + int(a[i + 1] -NULL);//审题第一个字符的ASCII值加第二个字符的ASCII值
//		//cout << a[i] - NULL;
//		cout << char(a[i] + a[i + 1]);
//	}
//	cout << char(a[len - 1] + a[0]);
//	/*b[len - 1] = a[0] + a[len - 1];
//	for (int i = 0; i < len; i++) {
//		cout << char(b[i]);
//	}*/
//	system("pause");
//	return 0;
//}

//合法 C 标识符
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 25;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//	if (a[0] >= '0'&&a[0] <= '9') {
//		cout << "no";
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < len; i++) {
//		if ((a[i] >= '0'&&a[i] <= '9') || (a[i] <= 'Z'&&a[i] >= 'A') || (a[i] >= 'a'&&a[i] <= 'z')||a[i] == '_') {
//
//		}
//		else {
//			cout << "no";
//			system("pause");
//			return 0;
//		}
//	}
//	cout << "yes";
//	system("pause");
//	return 0;
//}

//配对碱基链
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 260;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (a[i] == 'A') {
//			cout << 'T';
//		}
//		if (a[i] == 'T') {
//			cout << 'A';
//		}
//		if (a[i] == 'G') {
//			cout << 'C';
//		}
//		if (a[i] == 'C') {
//			cout << 'G';
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//字符替换
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	char tar, nw;
//	cin >> a >> tar >> nw;
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (a[i] == tar) {
//			cout << nw;
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//密码翻译
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 90;
//char stan_l[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
//char stan_u[26] = { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z' };
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (isalpha(a[i])) {
//			if (a[i] >= 'a'&&a[i] <= 'z') {
//				if (a[i] == 'z') {
//					cout<<"a";
//				}
//				else {
//					for (int j = 0; j < 26; j++) {
//						if (stan_l[j] == a[i]) {
//							cout << stan_l[j + 1];
//							break;
//						}
//					}
//				}
//				
//			}
//			if (a[i] >= 'A'&&a[i] <= 'Z') {
//				if (a[i] == 'Z') {
//					cout << "A";
//				}
//				else {
//					for (int j = 0; j < 26; j++) {
//						if (stan_u[j] == a[i]) {
//							cout << stan_u[j + 1];
//							break;
//						}
//					}
//				}
//				
//			}
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//简单密码
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 210;
//char secret[26] = { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z' };
//char white[26] = { 'V','W','X', 'Y', 'Z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U' };
//
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	gets_s(a);	
//	int len = strlen(a);
//
//	for (int i = 0; i < len; i++) {
//		if (isalpha(a[i])) {
//			for (int j = 0; j < 26; j++) {
//				if (secret[j] == a[i]) {
//					cout << white[j];
//					break;
//				}
//			}
//		}
//		else {
//			cout << a[i];
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//潜伏者 ??最开始只考虑了stan[secret]不能对应不同的原文 没有stan[0] = stan[1]这种情况
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char stan[26];
//char real[maxn];
//char secret[maxn];
//char now[maxn];
//int main() {
//	memset(stan, '0', sizeof(stan));
//	memset(secret, '0', sizeof(secret));
//	memset(real, '0', sizeof(real));
//	memset(now, '0', sizeof(now));
//	cin >> secret;
//	cin >> real;
//	cin >> now;
//	int len = strlen(secret);
//	int lenr = strlen(real);
//	if (len != lenr) {
//		cout << "Failed";
//		system("pause");
//		return 0;
//	}
//	int lenn = strlen(now);
//
//	for (int i = 0; i < len; i++) {
//		if (stan[secret[i] - 'A'] != '0') {
//			if (stan[secret[i] - 'A'] != real[i]) {
//				cout << "Failed";
//				system("pause");
//				return 0;
//			}
//		}
//		else {
//			stan[secret[i] - 'A'] = real[i];
//		}
//	}
//	for (int i = 0; i < 26; i++) {
//		for (int j = i + 1; j < 26; j++) {
//			if (stan[i] == stan[j]) {
//				cout << "Failed";
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	for (int i = 0; i < 26; i++) {
//		//cout << i << " " << stan[i] << endl;
//		if (stan[i] == '0') {
//			cout << "Failed";
//			system("pause");
//			return 0;
//		}
//	}
//	for (int i = 0; i < lenn; i++) {
//
//		cout << stan[now[i] - 'A'];
//	}
//
//	system("pause");
//	return 0;
//}

//加密的病历单
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 55;
//char stan[26];
//char real[maxn];
//char pr1[maxn];
//char pr2[maxn];
//char ans[maxn];
//int main() {
//	memset(stan, '0', sizeof(stan));
//	memset(pr1, '0', sizeof(pr1));
//	memset(pr2, '0', sizeof(pr2));
//	memset(ans, '0', sizeof(ans));
//	cin >> real;
//	int len = strlen(real);
//	
//	for (int i = 0; i < len; i++) {
//		if (real[i] == 'z') {
//			pr1[i] = 'c';
//		}
//		else if (real[i] == 'y') {
//			pr1[i] = 'b';
//			
//		}
//		else if (real[i] == 'x') {
//			pr1[i] = 'a';
//		}
//		else if (real[i] == 'Z') {
//			pr1[i] = 'C';
//		}
//		else if (real[i] == 'Y') {
//			pr1[i] = 'B';
//
//		}
//		else if (real[i] == 'X') {
//			pr1[i] = 'A';
//		}
//		else {
//			pr1[i] = real[i] + 3;//97-122
//			
//		}
//		//cout << pr1[i];
//	}
//	//cout << endl;
//	for (int i = 0; i < len; i++) {
//		pr2[i] = pr1[len - 1 - i];
//		//cout << pr2[i];
//	}
//	//cout << endl;
//	for (int i = 0; i < len; i++) {
//		if (pr2[i] <= 'z'&&pr2[i] >= 'a') {
//			ans[i] = pr2[i] - 32;
//		}
//		if (pr2[i] <= 'Z'&&pr2[i] >= 'A') {
//			ans[i] = pr2[i] + 32;
//		}
//		cout << ans[i];
//	}
//	system("pause");
//	return 0;
//}

//将字符串中的小写字母转换成大写字母
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char m[maxn];
//int main() {
//	memset(m, '0', sizeof(m));
//	gets_s(m);
//	int len = strlen(m);
//	
//	for (int i = 0; i < len; i++) {
//		if (m[i] >= 'a'&&m[i] <= 'z') {
//			cout <<char( m[i] - 32);
//		}
//		else {
//			cout << m[i];
//		}
//	}
//	
//	system("pause");
//	return 0;
//}


//大小写字母互换
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//char m[maxn];
//int main() {
//	memset(m, '0', sizeof(m));
//	gets_s(m);
//	int len = strlen(m);
//	
//	for (int i = 0; i < len; i++) {
//		if (m[i] >= 'a'&&m[i] <= 'z') {
//			cout <<char( m[i] - 32);
//		}
//		else if (m[i] >= 'A'&&m[i] <= 'Z') {
//			cout << char(m[i] + 32);
//		}
//		else {
//			cout << m[i];
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//整理药名
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 25;
//char m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		memset(m, '0', sizeof(m));
//		cin>> m;
//		int len = strlen(m);
//		if (m[0] >= 'a'&&m[0] <= 'z') {
//			cout << char(m[0] - 32);
//		}
//		else {
//			cout << m[0];
//		}
//		for (int j = 1; j < len; j++) {
//			if (m[j] >= 'A'&&m[j] <= 'Z') {
//				cout << char(m[j] + 32);
//			}
//			else {
//				cout << m[j];
//			}
//		}
//		cout << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//忽略大小写的字符串比较
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 85;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	gets_s(a);
//	gets_s(b);
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int lenmax = lena * (lena >= lenb) + lenb * (lenb > lena);
//	int flag = -1;
//	
//	for (int i = 0; i < lenmax; i++) {
//		if (a[i] >= 'A'&&a[i] <= 'Z') {
//			a[i] = char(a[i] + 32);
//		}
//		if (b[i] >= 'A'&&b[i] <= 'Z') {
//			b[i] = char(b[i] + 32);
//		}
//		if (a[i] < b[i]) {
//			cout << "<";
//			system("pause");
//			return 0;
//		}
//		else if (a[i] > b[i]) {
//			cout << ">";
//			system("pause");
//			return 0;
//		}
//
//
//	}
//
//	cout << "=";
//
//	system("pause");
//	return 0;
//}

//字符串判等
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 85;
//
//int main() {
//	string linea;
//	string lineb;
//	getline(cin, linea);
//	getline(cin, lineb);
//	string a;
//	string b;
//	stringstream ssa(linea);
//	stringstream ssb(lineb);
//	char temp;
//	while (ssa >> temp) {
//		if (temp >= 'A'&&temp <= 'Z') {
//			temp = char(temp + 32);
//		}
//		a.push_back(temp);
//	}
//	while (ssb >> temp) {
//		if (temp >= 'A'&&temp <= 'Z') {
//			temp = char(temp + 32);
//		}
//		b.push_back(temp);
//	}
//	int lena = a.length();
//	int lenb = b.length();
//	if (lena != lenb) {
//		cout << "NO";
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < lena; i++) {
//		
//		if (a[i] != b[i]) {
//			cout << "NO";
//			system("pause");
//			return 0;
//		}
//		
//	}
//	cout << "YES";
//	system("pause");
//	return 0;
//}

//验证子串  数组做法
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 200;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	int cnt = 0,temp;
//	if (lena < lenb) {
//		for (int i = 0; i < lenb; i++) {
//			cnt = 0;
//			temp = i;
//			for (int j = 0; j < lena; j++) {
//				if (b[temp] == a[j]) {
//					cnt++;
//					//cout << temp << " " << j << " " << cnt << endl;
//					temp++;
//				}
//				else {
//					break;
//				}
//			}
//			if (cnt == lena) {
//				cout << a << " is substring of " << b;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	else {
//		for (int i = 0; i < lena; i++) {
//			cnt = 0;
//			temp = i;//防止后面第二重循环时的++对第一重循环造成影响
//			for (int j = 0; j < lenb; j++) {
//				if (b[j] == a[temp]) {
//					//cout << temp << " " << j << " " << cnt << endl;
//					temp++;
//					cnt++;
//				}
//				else {
//					break;
//				}
//			}
//			if (cnt == lenb) {
//				cout << b << " is substring of " << a;
//				system("pause");
//				return 0;
//			}
//		}
//	}
//	
//	cout << "No substring";
//	system("pause");
//	return 0;
//}

//验证子串 调用函数
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 200;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//
//	if (strstr(a, b) != NULL) {
//		cout << b << " is substring of " << a;
//		system("pause");
//		return 0;
//	}
//	if (strstr(b, a) != NULL) {
//		cout << a << " is substring of " << b;
//		system("pause");
//		return 0;
//	}
//	
//
//	cout << "No substring";
//	system("pause");
//	return 0;
//}

//字符串移位包含问题 ? 审题 a,b不确定哪个长 哪个短
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//char b[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	memset(b, '0', sizeof(b));
//	cin >> a >> b;
//	int lena = strlen(a);
//	int lenb = strlen(b);
//	if (lenb > lena) {
//		swap(a, b);
//		swap(lena, lenb);
//	}
//	int cnt = 0;
//	int temp;
//	//cout << "lena: " << lena << endl;
//	for (int i = 0; i < lena; i++) {
//		cnt = 0;
//		temp = i;
//		//cout << "i: " << a[i] << endl;
//		for (int j = 0; j < lenb; j++) {
//			//cout << temp << ": " << a[temp] << " " << j << ": " << b[j] <<endl;
//
//			//cout << "temp: " << temp << endl;
//			if (temp == lena) {//若temp超出了lena 则置0 从第一个开始找
//				temp = 0;
//				j--;//因为这一步循环没有比较两个字符串但是又加了1 所以要先减去
//				//cout << "hhh" << endl;
//			}
//			else {
//				if (a[temp] == b[j]) {
//					cnt++;
//					//cout << i << " " << temp << " " << cnt << endl;
//					temp++;
//				}
//				else {
//					break;
//				}
//			}
//			//cout << " " << cnt << endl;
//		}
//		if (cnt == lenb) {
//			cout << "true";
//			system("pause");
//			return 0;
//		}
//	}
//
//	cout << "false";
//	system("pause");
//	return 0;
//}

////删除单词后缀
//#include<iostream>
//#include<string.h>
//#include<sstream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 35;
//char a[maxn];
//int main() {
//	memset(a, '0', sizeof(a));
//	cin >> a;
//	int len = strlen(a);
//	//cout << len << endl;
//	if (a[len - 1] == 'r' &&a[len - 2] == 'e') {
//		//cout << "h";
//		for (int i = 0; i < len - 2; i++) {
//			//cout << i << endl;
//			cout << a[i];
//			
//		}
//	}
//	else if (a[len - 1] == 'y' &&a[len - 2] == 'l') {
//		for (int i = 0; i < len - 2; i++) {
//			cout << a[i];
//			
//		}
//	}
//	else if (a[len - 1] == 'g' &&a[len - 2] == 'n'&&a[len - 3] == 'i') {
//		for (int i = 0; i < len - 3; i++) {
//			cout << a[i];
//			
//		}
//	}
//	else {
//		for (int i = 0; i < len ; i++) {
//			cout << a[i];
//			
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//单词替换
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	string tar;
//	string nw;
//	
//	getline(cin, line);
//	cin >> tar >> nw;
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		if (temp == tar) {
//			cout << nw;
//		}
//		else {
//			cout << temp;
//		}
//		cout << " ";
//	}
//	system("pause");
//	return 0;
//}

//紧急措施
//#include <iostream>
//#include <string>
//using namespace std;
//string tar;
//string adr;
//string user;
//string pw;
//int main() {
//	cin >> tar;
//	int n;
//	int len;
//	bool flag = false;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> user >> pw >> adr;
//		if (adr == tar) {
//			cout << user << " ";
//			len = pw.length();
//			for (int j = 0; j < len; j++) {
//				if (pw[j] <= 'z' && pw[j] >= 'a') {
//					cout << char(pw[j] - 32);
//				}
//				else if (pw[j] <= 'Z' && pw[j] >= 'A') {
//					cout << char(pw[j] + 32);
//				}
//				else {
//					cout << pw[j];
//				}
//			}
//			cout << endl;//每输出一行要空行
//			flag = true;
//		}
//	}
//	if (!flag) {
//		cout << "empty";
//	}
//	system("pause");
//	return 0;
//}

//过滤多余的空格
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		cout << temp << " ";
//	}
//	system("pause");
//	return 0;
//
//}

//单词的长度
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	int len;
//	bool flag = true;
//	while (ss >> temp) {
//		len = temp.length();
//		if (flag) {
//			cout << len;
//			flag = !flag;
//		}
//		else {
//			cout << "," << len;
//		}
//	}
//	system("pause");
//	return 0;
//}

//最长最短单词
//#include <iostream>
//#include <string>
//#include <sstream>
//using namespace std;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	int len,min,max;
//	string mins;
//	string maxs;
//
//	ss >> temp;
//	len = temp.length();
//	if (temp[len - 1] == ',') {
//		len = len - 1;
//		temp.pop_back();
//	}
//	min = max = len;
//	mins = temp;
//	maxs = temp;
//	//cout << mins << endl;
//	while (ss >> temp) {
//		len = temp.length();
//		if (temp[len - 1] == ',') {
//			len = len - 1;
//			temp.pop_back();
//		}
//		if (len < min) {
//			min = len;
//			mins = temp;
//		}
//		if (len>max) {
//			max = len;
//			maxs = temp;
//		}
//	}
//	cout << maxs << endl << mins;
//	system("pause");
//	return 0;
//}

////字符串最大跨距
//#include <iostream>
//#include <string>
//using namespace std;
//string origin;
//string s;
//string s1, s2;
//int main() {
//
//
//	//我自己想的比较笨的方法
//	//cin >> origin;
//	//for (int i = 0; i < origin.length(); i++) {
//	//	if (origin[i] != ',') {
//	//		s.push_back(origin[i]);
//	//		//cout << s << endl;
//	//	}
//	//	else {
//	//		for (int j = i + 1; j < origin.length(); j++) {
//	//			if (origin[j] != ',') {
//	//				s1.push_back(origin[j]);
//	//			}
//	//			else {
//	//				for (int k = j + 1; k < origin.length(); k++) {
//	//					s2.push_back(origin[k]);
//	//				}
//	//				break;
//	//			}
//	//		}
//	//		break;
//	//	}
//
//	//}
//
//	getline(cin, s, ',');
//	getline(cin, s1, ',');
//	getline(cin, s2);
//	//cout << s << endl << s1 << endl << s2;
//	int len1 = s1.length();
//
//	int p1 = s.find(s1);//这里p1不能加len1 因为后面要判断是否为空
//	int p2 = s.rfind(s2);
//
//	if (p1 == -1 || p2 == -1 || p1 + len1 > p2) {//这里是>而不是>=
//		cout << -1;
//	}
//	else {
//		cout << p2 - p1 - len1;
//	}
//	system("pause");
//	return 0;
//}

////单词翻转 
//#include <iostream>
//#include <string>
//#include <vector>
//using namespace std;
//const int maxn = 500;
//vector<string> v(maxn);
//vector<string> space(maxn);
//string s;
//int main() {
//	getline(cin, s);
//	int start, end;
//	int flag = 1;
//	int num = 0;
//	//cout << s << endl;
//	for (int i = 0; i < s.length(); i++) {
//		if (s[i] == ' ') {
//			
//			//cout << s[i];
//			if (flag) {
//				num++;
//				flag = 0;
//			}
//			space[num].push_back(s[i]);
//		}
//		else {
//			//cout << "HH" << endl;
//			v[num].push_back(s[i]);
//			flag = 1;
//		}
//	}
//	for (int i = 0; i <= num; i++) {
//		for (int j = v[i].length() -1 ; j >=0; j--) {
//			cout << v[i][j];
//		}
//		cout<<space[i+1];
//	}
//	system("pause");
//	return 0;
//}


//单词倒排
//#include <iostream>
//#include <string>
//#include <vector>
//using namespace std;
//const int maxn = 500;
//vector<string> v(maxn);
//vector<string> space(maxn);
//string s;
//int main() {
//	getline(cin, s);
//	int start, end;
//	int flag = 1;
//	int num = 0;
//	//cout << s << endl;
//	for (int i = 0; i < s.length(); i++) {
//		if (s[i] == ' ') {
//			
//			//cout << s[i];
//			if (flag) {
//				num++;
//				flag = 0;
//			}
//			space[num].push_back(s[i]);
//		}
//		else {
//			//cout << "HH" << endl;
//			v[num].push_back(s[i]);
//			flag = 1;
//		}
//	}
//	for (int i = num; i>=0; i--) {
//		cout << v[i];
//		cout<<space[i];
//	}
//	system("pause");
//	return 0;
//}

//ISBN号码
//#include <iostream>
//#include <string>
//using namespace std;
//int main() {
//	string s1, s2, s3, tar;
//	getline(cin, s1, '-');
//	getline(cin, s2, '-');
//	getline(cin, s3, '-');
//	getline(cin, tar);
//	int sum = 0;
//	bool flag = true;
//	string str = s1 + s2 + s3;
//	for (int i = 0; i < 9; i++) {
//		sum = sum + (i + 1)*(str[i] - '0');
//	}
//	int res = sum % 11;
//	//cout << res << endl;
//	if (res != 10) {
//		if (res != tar[0] - '0') {
//			//cout << "hhh" << endl;
//			flag = false;
//		}
//	}
//	else {
//		if (tar[0] != 'X') {
//			//cout << "111" << endl;
//			flag = false;
//		}
//	}
//
//	if (flag) {
//		cout << "Right";
//	}
//	else {
//		if (res == 10) {
//			cout << s1 << "-" << s2 << '-' << s3 << "-X";
//		}
//		else {
//			cout << s1 << "-" << s2 << '-' << s3 << "-" << res;
//
//		}
//	}
//	system("pause");
//	return 0;
//}

//字符环
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s1, s2;
//	cin >> s1 >> s2;
//	int len1 = s1.length();
//	int len2 = s2.length();
//	int cnt = 0, max = 0;
//	for (int i = 0; i < len1; i++) {
//
//		//cout << "HHH" << endl;
//		for (int j = 0; j < len2; j++) {
//			int tempi = i;
//			int tempj = j;
//			cnt = 0;
//			//cout<<"hhh " << (tempi) << ": " << s1[tempi] << " " << tempj << ": " << s2[tempj] << " " << cnt << endl;
//			while (s1[tempi] == s2[tempj] && cnt < min(len1, len2)) {
//				cnt++;
//				//cout << (tempi) << ": " << s1[tempi] << " " << tempj << ": " << s2[tempj] << " " << cnt << endl;
//				tempi = (tempi + 1) % len1;
//				tempj = (tempj + 1) % len2;
//			}
//			if (cnt > max) {
//				max = cnt;
//			}
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//字符串p型编码
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int cnt = 0;
//	char ch;
//	int temp;
//	for (int i = 0; i < s.length(); i++) {
//		ch = s[i];
//		while (ch == s[i]) {
//			i++;
//			cnt++;
//		}
//		i--;
//		cout << cnt << s[i];
//		cnt = 0;
//	}
//	system("pause");
//	return 0;
//}

//行程长度编码
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int cnt = 0;
//	char ch;
//	int temp;
//	for (int i = 0; i < s.length(); i++) {
//		s[i] = toupper(s[i]);
//	}
//	for (int i = 0; i < s.length(); i++) {
//		
//		ch = s[i];
//		while (ch == s[i]) {
//			i++;
//			cnt++;
//		}
//		i--;
//		cout <<"("<<s[i]<<","<<cnt<<")";
//		cnt = 0;
//	}
//	system("pause");
//	return 0;
//}

//判断字符串是否为回文
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	string s;
//	cin >> s;
//	int len = s.length();
//	for (int i = 0; i < len/ 2; i++) {
//		if (s[i] != s[len - i - 1]) {
//			cout << "no";
//			system("pause");
//			return 0;
//		}
//		
//	}
//	cout << "yes";
//	system("pause");
//	return 0;
//}

//回文子串
//#include <iostream>
//#include <algorithm>
//#include <string>
//#include <map>
//
//using namespace std;
//
//const int maxn = 250;
//multimap<int, string> m;
//int main() {
//	string s;
//	cin >> s;
//	bool flag;
//	int len = s.length();
//	int i, j, period;
//	for (period = 2; period <= len; period++) {//表示子串的长度
//		for (i = 0; i <= len - period; i++) {//带入特殊值验证是否取等号  起始位置
//			flag = true;
//			//cout << "hhh" << endl;
//			for (j = i; j < i + period; j++) { //判断是否是回文
//				//cout << i << " " << j << " " << period << endl;
//				//cout << j << " " << s[j] << " " << i + period - (j - i) - 1 << " " << s[i + period - (j - i) - 1] << endl;
//				if (s[j] != s[i+period-(j-i) - 1]) {
//					flag = false;
//					//cout << "h" << endl;
//					break;
//				}
//			}
//			//cout << flag << endl;
//			if (flag) {
//				cout << s.substr(i, period) << endl;
//			}
//		}
//		//cout << period << endl;
//	}
//	system("pause");
//	return 0;
//}

//回文子串 只有3分
//#include <iostream>
//#include <algorithm>
//#include <string>
//#include <map>
//
//using namespace std;
//
//const int maxn = 250;
//multimap<int, string> m;
//int main() {
//	string s;
//	cin >> s;
//	bool flag = false;
//	int len = s.length();
//	int cnt = -1;
//	int maxl = 0, minl = len;
//	for (int i = 0; i < len - 1; i++) {
//		for (int j = i + 1; j < len; j++) {
//
//			//cout << "hhh" << endl;
//			int tempi = i, tempj = j;
//			//cout << "hhh " << tempi << " " << s[tempi] << " " << tempj << " " << s[tempj] << endl;
//
//			flag = false;
//			while ((s[tempi] == s[tempj]) && (tempi <= tempj)) {
//				//cout <<tempi<<" "<<s[tempi]<<" "<<tempj<<" "<<s[tempj] << endl;
//				if (tempi + 1 == tempj) {
//					flag = true;
//					cnt++;
//				}
//				tempi++;
//				tempj--;
//				//cout << "hhh" << endl;
//
//			}
//
//			if (flag) {
//				//cout << i << " " << j << endl;
//				m.insert(pair<int, string >(j - i + 1, s.substr(i, j - i + 1)));
//				flag = false;
//				maxl = max(j - i + 1, maxl);
//				minl = min(j - i + 1, minl);
//			}
//		}
//	}
//
//
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		for (int i = minl; i <= maxl; i++) {
//			if (itr->first == i) {
//				cout << itr->second << endl;
//			}
//		}
//	}
//
//
//	system("pause");
//	return 0;
//}

//字符串的展开 自己做的 有很多bug  只能得4-6分 
//#include <iostream>
//#include <algorithm>
//#include <string>
//using namespace std;
//int main() {
//	int p1, p2, p3;
//	cin >> p1 >> p2 >> p3;
//	string s;
//	cin >> s;
//	int len = s.length();
//	bool flag[120] = { false };
//	//cout << len << endl;
//	for (int i = 0; i < len; i++) {
//
//		//先判断越界，否则会报错越界了
//		if (i >= 0 && i + 2 < len) {
//			if ((isalpha(s[i]) && isalpha(s[i + 2]) && s[i + 1] == '-') || (isdigit(s[i]) && isdigit(s[i + 2]) && s[i + 1] == '-')) {
//				if (s[i + 2] - s[i] == 1) {//相邻的可以省略-
//										   //cout << 1 << endl;
//					cout << s[i] << s[i + 2];
//					i = i + 2;
//				}
//				else if (int(s[i + 2] - s[i]) <= 0) {//后面比前面小 保留等号
//					if (!flag) {
//						cout << s[i];
//					}
//					cout << "-" << s[i + 2];
//					i = i + 2;
//				}
//				else {
//					//cout << i << ": " << s[i] << endl;
//					int period = s[i + 2] - s[i] - 1;//两者之间的间隔
//					if (!flag[i]) {
//						cout << s[i];
//						flag[i + 2] = true;
//					}
//					//cout << s[i];
//					//cout << s[i];//直接输出当前字符
//					if (p1 == 1) {
//						if (p3 == 1) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {//重复次数
//									if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i] + j + 32);
//									}
//									else if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i] + j);
//									}
//									else {
//										cout << s[i] + j - '0';
//										//cout << "i: "<<i<<" j: "<<j<< s[i] + j - '0' << endl;
//									}
//								}
//							}
//						}
//						else if (p3 == 2) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {
//									if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i + 2] - j);
//
//									}
//									else if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i + 2] - j + 32);
//									}
//									else {
//										cout << s[i + 2] - j - '0';
//									}
//								}
//							}
//						}
//
//					}
//					else if (p1 == 2) {
//						if (p3 == 1) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {//重复次数
//									if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i] + j);
//									}
//									else if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i] + j - 32);
//									}
//									else {
//										cout << s[i] + j - '0';
//									}
//								}
//							}
//						}
//						else if (p3 == 2) {
//							for (int j = 1; j <= period; j++) {
//								for (int k = 0; k < p2; k++) {
//									if (s[i] <= 'z'&&s[i] >= 'a') {
//										cout << char(s[i + 2] - j - 32);
//
//									}
//									else if (s[i] <= 'Z'&&s[i] >= 'A') {
//										cout << char(s[i + 2] - j);
//									}
//									else {
//										cout << s[i + 2] - j - '0';
//									}
//								}
//							}
//						}
//
//					}
//					else if (p1 == 3) {
//
//						for (int j = 1; j <= period; j++) {
//							for (int k = 0; k < p2; k++) {
//								cout << '*';
//							}
//						}
//
//					}
//					//cout << "i+2: "<<i+2 << endl;
//					cout << s[i + 2];
//					//cout << "2222" << endl;
//					flag[i + 2] = true;
//					//cout << "2222" << endl;
//					i = i + 1;
//				}
//
//
//
//			}
//			else {
//				//cout << "hhh" << endl;
//				if (!flag[i]) {
//					cout << s[i];
//				}
//
//			}
//		}
//
//		else {
//			if (!flag[i]) {
//				cout << s[i];
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//字符串的展开 网上的答案
//#include<iostream>
//#include<cstring>
//#include<algorithm> 
//using namespace std;
//int p1, p2, p3, len, sum;
//char a[30000], b[30000];
//int main()
//{
//	cin >> p1 >> p2 >> p3 >> a;
//	len = strlen(a);
//	for (int i = 0; i < len; i++)
//		if (a[i] == '-'&&i > 0 && i < strlen(a) - 1)//开头或结尾的-直接else输出 
//		{
//			if (a[i - 1] == '-' || a[i + 1] == '-') cout << '-';//几个-连在一起，直接输出- 
//			else if (a[i + 1] == a[i - 1] + 1) continue;//-两边ascll码是连续的，跳过- 
//			else if (a[i - 1] >= a[i + 1] || (a[i - 1] <= '9'&&a[i + 1] >= 'A')) cout << '-';//-两边是字符和数字或者没有按升序排列，输出-；因为字母的acsll码本来就大于数字的，所以只需要另判断左边是数字右边是字母即可 
//			else
//			{
//				int l = 0;
//				if (p1 == 1)
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)//枚举过程中字符型自动转化为整形 
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = tolower((char)j);//整形强制转换成字符型 
//					}
//				}
//				else if (p1 == 2)
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = toupper((char)j);
//					}
//				}
//				else
//				{
//					for (int j = a[i - 1] + 1; j < a[i + 1]; j++)
//					{
//						for (int k = 1; k <= p2; k++)
//							b[l++] = '*';
//					}
//				}
//				if (p3 == 2)
//					reverse(b, b + l);//数组翻转 
//				for (int j = 0; j < l; j++)
//					cout << b[j];
//			}
//		}
//		else cout << a[i];
//		system("pause");
//}

//字符串的展开 自己写的一次
//#include <iostream>
//#include <string>
//#include<algorithm> 
//using namespace std;
//const int maxn = 50000;
//char ch[maxn];
//int main() {
//	int p1, p2, p3;
//	string s;
//	cin >> p1 >> p2 >> p3 >> s;
//	int len = s.length();
//	for (int i = 0; i < len; i++) {
//		if (i > 0 && i < len - 1 &&s[i] =='-') {
//			if (s[i - 1] == '-'||s[i + 1] == '-') {//几个-连在一起，直接输出-   逻辑符号是|| 而不是&&
//				cout << '-';
//			}
//			else if (s[i+1] - s[i-1] == 1) {
//				continue;
//			}
//			else if (s[i + 1] <= s[i - 1] || (isalpha(s[i-1])&&isdigit(s[i+1]))|| (isalpha(s[i + 1]) && isdigit(s[i - 1]))) {
//				cout << '-';
//			}
//			else {
//				int cnt = 0;
//				if (p1 == 1) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = tolower(char(j));
//						}
//						
//					}
//				}
//				else if (p1 == 2) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = toupper(char(j));
//						}
//					}
//				}
//				else if (p1 == 3) {
//					for (int j = s[i - 1] + 1; j < s[i + 1]; j++) {
//						for (int k = 0; k < p2; k++) {
//							ch[cnt++] = '*';
//						}
//					}
//				}
//				if (p3 == 2) {
//					reverse(ch, ch + cnt);
//				}
//				for (int j = 0; j < cnt; j++) {
//					cout << ch[j];
//				}
//			}
//		}
//		else {
//			cout << s[i];
//		}
//	}
//	system("pause");
//	return 0;
//}

//1.8编程基础之多维数组
//矩阵交换行
//#include<iostream>
//using namespace std;
//int m[5][5];
//int main() {
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int x, y;
//	cin >> x >> y;
//	for (int i = 0; i < 5; i++) {
//		if (i == x-1) {
//			for (int j = 0; j < 5; j++) {
//				cout << m[y-1][j]<<" ";
//			}
//		}
//		else if (i == y-1) {
//			for (int j = 0; j < 5; j++) {
//				cout << m[x-1][j] << " ";
//			}
//		}
//		else {
//			for (int j = 0; j < 5; j++) {
//				cout << m[i][j] << " ";
//			}
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//同行列对角线的格子
//#include<iostream>
//using namespace std;
//const int maxn = 15;
//int m[maxn][maxn];
//int main() {
//	int n, row, col;
//	cin >> n >> row >> col;
//	for (int i = 1; i <= n; i++) {
//		cout << "(" << row << "," << i << ") ";
//	}
//	cout << endl;
//	for (int i = 1; i <= n; i++) {
//		cout << "(" << i << "," << col << ") ";
//	}
//	cout << endl;
//	for (int i = 1; i <= n; i++) {
//		if (i + (col - row) > n || i + (col - row) < 1) continue;
//		cout << "(" << i << "," << i + (col - row) << ") ";
//	}
//	cout << endl;
//	for (int i = n; i >= 1; i--) {
//		if ((col + row) - i > n || (col + row) - i < 1)continue;
//		cout << "(" << i << "," << (col + row) - i << ") ";
//	}
//
//	system("pause");
//	return 0;
//}

//计算矩阵边缘元素之和 ？考虑行向量和列向量
//#include<iostream>
//using namespace std;
//const int maxn = 100;
//int m[maxn][maxn];
//int main() {
//	int row, col;
//	cin >> row >> col;
//	for (int i = 0; i < row; i++) {
//		for (int j = 0; j < col; j++) {
//			cin >> m[i][j];
//		}
//	}
//	long long sum = 0;
//	for (int i = 0; i < col; i++) {
//		if (row - 1 != 0) {//判断单行
//			sum = sum + m[0][i] + m[row - 1][i];
//		}else{
//			sum = sum + m[0][i];
//		}
//	}
//	for (int i =1; i < row-1; i++) {
//		if (col - 1 != 0) {//判断单列
//			sum = sum + m[i][0] + m[i][col - 1];
//		}
//		else {
//			sum = sum + m[i][0] ;
//		}
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//错误探测 ？ 先判断正确的 剩下的都是错的
//#include<iostream>
//#include<cstring>//memset要包含头文件
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int row[maxn];
//int col[maxn];
//int main() {
//	memset(row, 0, sizeof(row));
//	memset(col, 0, sizeof(col));
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			row[i] = (row[i] + m[i][j]) %2;
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			col[i] = (col[i] + m[j][i])%2;
//		}
//	}
//	int ansr = -1, ansc = -1;
//	int cntr = 0, cntc = 0;
//	for (int i = 0; i < n; i++) {
//		
//		if (row[i] % 2 != 0) {
//			ansr = i;
//			cntr++;
//		}
//		if (col[i] % 2 != 0) {
//			ansc = i;
//			cntc++;
//		}
//	}
//	//先判断特殊的正确情况 剩下的情况都是错的
//	if (ansr == -1 && ansc == -1) {
//		cout << "OK";
//	}
//	else if(cntr == 1&&cntc ==1){
//		cout << ansr + 1 << " " << ansc + 1;
//	}
//	else  {
//		cout << "Corrupt";
//	}
//	system("pause");
//	return 0;
//}

//计算鞍点
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//using namespace std;
//const int maxn = 10;
//int m[maxn][maxn];//读矩阵
//int row[maxn];//存行最大值
//int col[maxn];//存列最大值
//int main() {
//	memset(m, 0, sizeof(0));
//	memset(row, 0, sizeof(row));
//	memset(col, 0, sizeof(col));
//	int n = 5;
//	int ansr[5], ansc[5];//其实并没有什么用 存每行最大值的列坐标 每列最小值的行坐标
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (j == 0) {
//				row[i] = m[i][j];
//				ansr[i] = j;
//				//cout << i + 1 << " " << row[i] << endl;
//
//			}
//			else {
//				//cout << i + 1 << " " << row[i] << endl;
//				if (row[i] < m[i][j]) {
//					row[i] = m[i][j];
//					ansr[i] = j;
//				}
//			}
//		}
//		//cout << i + 1 << " " << ansr[i] <<" "<<row[i]<< endl;
//	}
//	//cout << ansr[0] << " " << ansr[1] << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (j == 0) {
//				col[i] = m[j][i];
//				ansc[i] = j;
//			}
//			else {
//				if (col[i] > m[j][i]) {
//					col[i] = m[j][i];
//					ansc[i] = j;
//				}
//			}
//		}
//		//cout << i + 1 << " " << ansc[i] << " " << col[i] << endl;
//	}
//	bool flag = false;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//
//			if (row[i] == col[j]) {
//				cout << i + 1 << " " << j + 1 << " " << row[i];
//				flag = true;
//			}
//		}
//	}
//	if (!flag) {
//		cout << "not found";
//	}
//
//	system("pause");
//	return 0;
//}

//图像相似度
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int m1[maxn][maxn];
//int m2[maxn][maxn];
//int main() {
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int k, n, cnt = 0;
//	cin >> k >> n;
//	for (int i = 0; i < k; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < k; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//			if (m1[i][j] == m2[i][j]) {
//				cnt++;
//			}
//		}
//	}
//	cout << fixed << setprecision(2) << double(cnt) / (n * k ) *100;
//	system("pause");
//	return 0;
//}

//矩阵归零消减序列和 自己写的只有1分  之后把输出位置调整到一开始就可以了 ？
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<vector>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int ans[maxn];
//int tempr[maxn];
//int tempc[maxn];
//int m1[maxn][maxn];
//int m2[maxn][maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(ans, 0, sizeof(ans));
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	//cout << m[2][2] << endl;
//	for (int r = 0; r < n ; r++) {
//		cout << m[2][2] << endl;
//		memset(m1, 0, sizeof(m1));
//		memset(m2, 0, sizeof(m2));
//		for (int i = 1; i <= n - r; i++) {//求每行最小值
//			tempr[i] = m[i][1];
//			for (int j = 1; j <= n - r; j++) {
//				tempr[i] = min(tempr[i], m[i][j]);
//				//cout << j << " " << tempc[j] << endl;
//			}
//			//cout << i << " " << tempr[i] << endl;
//
//		}
//		for (int i = 1; i <= n - r; i++) {//减去最小值
//			for (int j = 1; j <= n - r; j++) {
//				m[i][j] = m[i][j] - tempr[i];
//				//cout << m[i][j] << " ";
//			}
//			//cout << endl;
//		}
//		for (int i = 1; i <= n - r; i++) {//每列最小值
//			tempc[i] = m[1][i];
//			for (int j = 1; j <= n - r; j++) {
//				tempc[i] = min(tempc[i], m[j][i]);
//				//cout << j << " " << tempc[j] << endl;
//			}
//			//cout << i << " " << tempr[i] << endl;
//		}
//		for (int i = 1; i <= n - r; i++) {//减去最小值
//			for (int j = 1; j <= n - r; j++) {
//				m[j][i] = m[j][i] - tempc[i];
//			}
//
//		}
//		/*for (int i = 1; i <= n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//	/*	if (r < n - 2) {
//			cout << m[2][2] << endl;
//		}
//		else {
//			
//		}*/
//		
//	
//		for (int i = 2; i < n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//				m[i][j] = m[i + 1][j];
//			}
//		}
//		for (int i = 2; i < n - r; i++) {
//			for (int j = 1; j <= n - r; j++) {
//				m[j][i] = m[j][i + 1];
//			}
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//矩阵归零消减序列和 答案 简单
//#include <iostream>
//using namespace std;
//const int maxn = 110;
//int main() {
//	int n; cin >> n;
//	int a[maxn][maxn] = { 0 }, min = 1e9;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> a[i][j];
//		}
//	}
//	for (; n; n--) {
//		cout << a[1][1] << endl;
//		for (int i = 0; i < n; i++) {
//			min = 1e9;
//			for (int j = 0; j < n; j++)min > a[i][j] ? min = a[i][j] : min;//取行最小值
//			for (int j = 0; j < n; j++) { a[i][j] -= min; if (a[i][j] < 0)a[i][j] = 0; }//每行减去行最小值
//		}
//		for (int i = 0; i < n; i++) {
//			min = 1e9;
//			for (int j = 0; j < n; j++)min > a[j][i] ? min = a[j][i] : min;//取列最小值
//			for (int j = 0; j < n; j++) { a[j][i] -= min; if (a[j][i] < 0)a[j][i] = 0; }//每列减去行最小值
//		}
//		if (n != 2) {
//			for (int i = 0; i < n; i++)for (int j = 1; j < n; j++)a[i][j] = a[i][j + 1];//删除第二行
//			for (int i = 0; i < n; i++)for (int j = 1; j < n; j++)a[j][i] = a[j + 1][i];//删除第二列
//		}
//	}
//	system("pause");
//	return 0;
//}

//矩阵加法
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//long long  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int m, n;
//	cin >> m>>n;
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//			m2[i][j] += m1[i][j];
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//矩阵乘法
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//long long  m2[maxn][maxn];
//long long ans[maxn][maxn];
//int main() {
//	memset(ans, 0, sizeof(ans));
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int n, m, k;
//	cin >> n >> m >> k;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < k; j++) {
//			cin >> m2[i][j];
//		}
//	}
//	for (int i = 0; i < n; i++) {//A 行
//		for (int j = 0; j < k; j++) {// B 列
//			for (int p = 0; p < m; p++) {
//				ans[i][j] += m1[i][p] * m2[p][j];
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < k; j++) {
//			cout << ans[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//矩阵转置
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int n, m;
//	cin >> n >> m ;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m1[j][i] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//图像旋转
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//long long  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int n, m;
//	cin >> n >> m;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		for (int j = n-1; j >=0; j--) {
//			cout << m1[j][i] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//变幻的矩阵
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 50;
//char  m1[maxn][maxn];
//char  m2[maxn][maxn];
//char ans1[maxn][maxn];
//char ans2[maxn][maxn];
//char ans3[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	memset(ans1, 0, sizeof(ans1));
//	memset(ans2, 0, sizeof(ans2));
//	memset(ans3, 0, sizeof(ans3));
//
//	int n;
//	cin >> n;
//	//cout << n << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m1[i][j];
//			//cout << i << " " << j << endl;
//		}
//	}
//	//cout << "hhh" << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cin >> m2[i][j];
//		}
//	}
//	
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			ans1[i][j] = m1[n - j - 1][i];
//			ans2[i][j] = m1[j][n - i - 1];
//			ans3[i][j] = m1[n - i - 1][n - j - 1];
//			//cout << ans3[i][j] << " ";
//		}
//		//cout << endl;
//	}
//	int flag[4] = {1,1,1,1};
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			if (ans1[i][j] != m2[i][j]) {
//				flag[0] = 0;
//			}
//			if (ans2[i][j] != m2[i][j]) {
//				flag[1] = 0;
//			}
//			if (ans3[i][j] != m2[i][j]) {
//				flag[2] = 0;
//			}
//			if (m1[i][j] != m2[i][j]) {
//				//cout << m1[i][j] << " " << m2[i][j] << endl;
//				flag[3] = 0;
//			}
//		}
//	}
//	bool sus = false;
//	for (int i = 0; i < 4; i++) {
//		//cout << flag[i] << endl;
//		if (flag[i]) {
//			cout << i + 1;
//			sus = true;
//			break;
//		}
//	}
//	if (!sus) {
//		cout << 5;
//	}
//	system("pause");
//	return 0;
//}

//图像模糊处理  判断单行
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int  m1[maxn][maxn];
//int  m2[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//
//	int n, m;
//	cin >> n >> m;
//	//cout << n << endl;
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < m; j++) {
//			cin >> m1[i][j];
//			//cout << i << " " << j << endl;
//		}
//	}
//	for (int i = 0; i < m; i++) {
//		cout << m1[0][i] << " ";
//	}
//	cout << endl;
//	for (int i = 1; i < n - 1; i++) {
//		for (int j = 0; j < m; j++) {
//			if (j == 0) {
//				cout << m1[i][0] << " ";
//
//			}
//			else if (j == m - 1) {
//				cout << m1[i][m - 1];
//
//			}
//			else {
//				//cout << "hhh: " << m1[i][j] << " " << m1[i - 1][j] << " " << m1[i + 1][j] << " " << m1[i][j - 1] << " " << m1[i][j + 1] << endl;
//				double a = (double(m1[i][j]) + double(m1[i - 1][j]) + double(m1[i + 1][j]) + double(m1[i][j - 1]) + double(m1[i][j + 1])) / 5.0;
//				int ans = floor(a + 0.5);
//				cout << ans << " ";
//				//cout << a << " ";
//			}
//
//		}
//		cout << endl;
//		//cout << endl;
//	}
//	if (n != 1) {
//		for (int i = 0; i < m; i++) {
//			cout << m1[n - 1][i] << " ";
//		}
//	}
//
//	system("pause");
//	return 0;
//}

//扫雷游戏地雷数计算
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];
//int  m2[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//
//	int n, m;
//	cin >> n >> m;
//	//cout << n << endl;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++) {
//			cin >> m1[i][j];
//		}
//	}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++) {
//			if (m1[i][j] == '*') {//不用判断边界条件 因为边界以为的都初始化为0  只要不为*就不加
//				cout << m1[i][j] ;
//			}
//			else {
//				if (m1[i - 1][j] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i - 1][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i - 1][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j - 1] == '*') {
//					m2[i][j]++;
//				}
//				if (m1[i + 1][j + 1] == '*') {
//					m2[i][j]++;
//				}
//				cout << m2[i][j] ;
//			}
//
//		}
//		cout << endl;
//		//cout << endl;
//	}
//	
//	system("pause");
//	return 0;
//}

//细菌的繁殖与扩散 ？？自己写的思路不对  抓住核心 以每个元素为对象写 而不是以每个元素扩散影响其他元素来写！！
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 11;
//int  m1[maxn][maxn];//前一天的状态
//int  m2[maxn][maxn];//后一天的状态 扩散之后的状态
////int  m3[maxn][maxn];//记录前一天的状态
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	//memset(m3, 0, sizeof(m3));
//	int r[8] = { 0,0,1,-1,-1,1,-1,1 };
//	int c[8] = { 1,-1,0,0,1,1,-1,-1 };
//
//	int n, m;
//	cin >> n >> m;
//	m1[5][5] = n;
//	//m2[5][5] = n;
//	/*for (int i = 1; i <= 9; i++) {
//		for (int j = 1; j <= 9; j++) {
//			cout << m1[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	for (int d = 1; d <= m; d++) {
//		for (int i = 1; i <= 9; i++) {
//			for (int j = 1; j <= 9; j++) {
//				m2[i][j] = m1[i][j] * 2;
//				for (int k = 0; k < 8; k++) {
//					m2[i][j] = m2[i][j] + m1[i+r[k]][j+c[k]];
//				}
//			}
//		}
//		for (int o = 1; o <= 9; o++) {
//			for (int p = 1; p <= 9; p++) {
//				m1[o][p] = m2[o][p];
//			}
//		}
//		/*cout << "day" << d << endl;
//		for (int i = 1; i <= 9; i++) {
//			for (int j = 1; j <= 9; j++) {
//				cout << m2[i][j] << " ";
//			}
//			cout << endl;
//		}
//		cout << endl;*/
//	}
//	for (int i = 1; i <= 9; i++) {
//		for (int j = 1; j <= 9; j++) {
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//矩阵剪刀石头布 对于矩阵一定要考虑单行单列
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];//前一天的状态
//char  m2[maxn][maxn];//后一天的状态 扩散之后的状态
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int dirr[4] = { 1,-1,0,0 };// 下 上 右 左
//	int dirc[4] = { 0,0,1,-1 };
//
//	int r, c, n;
//	cin >> r >> c >> n;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	if (r == 1 && c == 1) {
//		cout << m1[1][1];
//		system("pause");
//		return 0;
//	}
//	for (int d = 0; d < n; d++) {
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				int vis = 0;//必须要  因为一旦被其他的单元占领了之后 就直接更改了自己的状态 而不再受其他单元的影响 否则会被覆盖
//				for (int k = 0; k < 4; k++) {
//					if (isalpha(m1[i + dirr[k]][j + dirc[k]])) {
//						if (!vis) {
//							if ((m1[i][j] == 'R'&&m1[i + dirr[k]][j + dirc[k]] == 'P') || (m1[i][j] == 'S'&&m1[i + dirr[k]][j + dirc[k]] == 'R') || (m1[i][j] == 'P'&&m1[i + dirr[k]][j + dirc[k]] == 'S')) {
//								m2[i][j] = m1[i + dirr[k]][j + dirc[k]];
//								vis = 1;
//							}
//							else {
//
//								m2[i][j] = m1[i][j];
//
//							}
//							//cout << k << " " << i << " " << j << " " << m1[i][j] << " " << m1[i + dirr[k]][j + dirc[k]] << " " << m2[i][j] << endl;
//						}
//					}
//				}
//			}
//		}
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				m1[i][j] = m2[i][j];
//			}
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cout << m1[i][j];
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//最好的草
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn][maxn];//前一天的状态
//char  m2[maxn][maxn];//后一天的状态 扩散之后的状态
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	int dirr[4] = { 1,-1,0,0 };// 下 上 右 左
//	int dirc[4] = { 0,0,1,-1 };
//
//	int r, c, n;
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	if (r == 1 && c == 1) {
//		cout << m1[1][1];
//		system("pause");
//		return 0;
//	}
//	int cnt = 0;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (m2[i][j] != '1'&&m1[i][j] == '#') {
//				//cout << i << " " << j << endl;
//				cnt++;
//				for (int k = 0; k < 4; k++) {
//					m2[i][j] = '1';
//					if (m2[i + dirr[k]][j + dirc[k]] != '1'&&m1[i + dirr[k]][j + dirc[k]] == '#') {
//						m2[i + dirr[k]][j + dirc[k]] = '1';
//					}
//				}
//				/*for (int i = 1; i <= r; i++) {
//					for (int j = 1; j <= c; j++) {
//						if (m2[i][j] == '1') {
//							cout << m2[i][j] << " ";
//
//						}
//						else {
//							cout << 0 << " ";
//						}
//					}
//					cout << endl;
//				}
//				cout << endl;*/
//			}
//			
//		}
//	}
//		cout << cnt;
//		system("pause");
//		return 0;
//	}


//肿瘤面积  注意边界的判定包括出界和遇到255两种情况 
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 1010;
//int  m1[maxn][maxn];
//
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int  n;
//	int zs[2], zx[2], ys[2], yx[2];
//	memset(zs, 0, sizeof(zs));
//	memset(zx, 0, sizeof(zx));
//	memset(ys, 0, sizeof(ys));
//	memset(yx, 0, sizeof(yx));
//
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m1[i][j];
//
//		}
//	}
//	if (n == 1 && m1[1][1] == 255) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	//for (int i = 1; i <= n; i++) {
//	//	for (int j = 1; j <= n; j++) {
//	//		cout<< m1[i][j]<<" ";
//	//	}
//	//	cout << endl;
//	//}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			//cout << m1[i][j] << " ";
//			if (m1[i][j] == 0) {
//				//cout << "hhh" << endl;
//
//				zs[0] = i;
//				zs[1] = j;
//				zx[1] = j;
//				//cout << zs[0] << " " << zs[1] << endl;
//				while (j++) {
//					if (m1[i][j] == 255||j==n+1) {
//						j--;
//						ys[0] = i;
//						ys[1] = j;
//						while (i++) {
//							if (m1[i][j] == 255 || i == n + 1) {
//								i--;
//								yx[0] = i;
//								yx[1] = j;
//								zx[0] = i;
//								break;
//							}
//						}
//						break;
//					}
//				}
//				break;
//			}
//		}
//
//	}
//	int ans = (yx[0] - zs[0] - 1)*(yx[1] - zs[1] - 1);
//	cout << ans;
//	system("pause");
//	return 0;
//}

//肿瘤检测  思路就按照题目意思来 不要自己想算法！！！
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 110;
//int  m1[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//
//	int  n, area = 0, per = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			if (m1[i][j] <= 50) {
//				area++;
//				if (i == 1 || i == n || j == 1 || j == n || m1[i - 1][j] > 50 || m1[i + 1][j] > 50 || m1[i][j - 1] > 50 || m1[i][j + 1] > 50) {
//					per++;
//				}
//			}
//		}
//	}
//	cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//反反复复
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//char  m1[maxn];
//char  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	char c;
//	int cnt = 0;
//	while (cin >> c) {
//		m1[cnt++] = c;
//	}
//	//cout << cnt << endl;
//	int len = cnt / n;
//	//cout << "hh " << len << endl;
//	for (int i = 0; i < len; i++) {
//		for (int j = 0; j < n; j++) {
//			//cout << i * len + j << " ";
//			if (i % 2 == 0) {
//				m2[i][j] = m1[i*n + j];
//			}
//			else {
//				m2[i][n - j - 1] = m1[i*n + j];
//			}
//		}
//
//	}
//	/*for (int i = 0; i < len; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m2[i][j];
//		}
//		cout << endl;
//	}*/
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < len; j++) {
//			cout << m2[j][i];
//		}
//		
//	}
//	//cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//二维数组右上左下遍历  
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  r, c;
//	cin >> r >> c;
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//
//	for (int i = 0; i < c; i++) {//第一行起点 上三角
//		for (int j = 0; j < r; j++) {
//			if ((i - j) >= 0) {
//				cout << m1[j][i - j] << endl;
//			}
//		}
//	}
//
//	for (int i = 1; i < r; i++) {//最后一列起点 下三角
//		for (int j = 0; j < c; j++) {
//			if ((i + j) < r) {
//				cout << m1[i + j][c - j - 1] << endl;
//			}
//		}
//	}
//	//for (int i = 1; i < r; i++) {//最后一列起点 下三角
//	//	for (int j = c - 1; j >= 0; j--) {
//	//		if ((i + c - j - 1) < r) {//c-r +j <=i
//	//			cout << m1[i + c - j - 1][j] << endl;
//	//		}
//	//	}
//	//}
//	//cout << area << " " << per;
//	system("pause");
//	return 0;
//}

//神奇的幻方
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	n = 2 * n - 1;
//	int num = pow(n, 2);
//	int i = 1, j = n/2+1;
//	int cnt = 1;
//	//cout << n << endl;
//	while (num--) {
//		
//		m1[i][j] = cnt;
//		//cout << i << " " << j <<" "<< m1[i][j]<<endl;
//		cnt++;
//		if ((i == 1 && j == n) || (m1[i - 1][j + 1])) {
//			//cout << i << " " << j << endl;
//			i = i + 1;
//		}
//		else if (i == 1) {
//			i = n;
//			j = j + 1;
//		}
//		else if (j == n) {
//			j = 1;
//			i = i - 1;
//		}
//		else {
//			i = i - 1;
//			j = j + 1;
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cout << m1[i][j] << " ";
//		}
//		cout<<endl;
//	}	
//	system("pause");
//	return 0;
//}

//二维数组回形遍历
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  r,c;
//	cin >> r>>c;
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> m1[i][j];
//		}
//	}
//	int cnt = r * c;
//	int i = 0, j = 0;
//	int round = 0;
//	cout << m1[i][j] << endl;
//	cnt--;
//	while (cnt) {
//		while (cnt&&j+1<c-round) {
//			j++;
//			cnt--;
//			cout << m1[i][j]<<endl;
//			//system("pause");
//		}
//		while (cnt&&i + 1 < r - round) {
//			i++;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		while (cnt&&j - 1 >= 0+ round) {
//			j--;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		round++;
//		while (cnt&&i - 1 >= 0+round) {
//			i--;
//			cout << m1[i][j] << endl;
//			cnt--;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//蛇形填充数组  
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 110;
//int   m1[maxn][maxn];
//int  m2[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int  n;
//	cin >> n;
//	int v = 1;
//	int cnt = 2 * n - 1;
//	for (int sum = 0; sum < cnt; sum++) {
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//				if (i + j == sum) {
//					//cout << sum << " " << i << " " << j << " " << v << endl;
//
//					if (sum % 2 == 1) {
//						m2[i][j] = v;
//						v++;
//					}
//					else {
//						m2[j][i] = v;
//						v++;
//					}
//				}
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = 0; j < n; j++) {
//			cout << m2[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//螺旋加密
//#include<iostream>
//#include<cstring>//memset要包含头文件
//#include<algorithm>
//#include<iomanip>
//#include<string>
//using namespace std;
//const int maxn = 3000;
//int   m1[maxn];
//int  m2[maxn];
//int m3[maxn][maxn];
//int main() {
//
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//	memset(m3, 0, sizeof(m3));
//	int  r, c;
//	cin >> r >> c;
//	string s;
//	getline(cin, s);//s的第一个字符是空格
//	//cout << s;
//	int len = s.size() - 1;
//	for (int i = 1; i <= len; i++) {//s的第一个字符是空格
//		if (s[i] == ' ') {
//			m1[i] = 0;
//		}
//		else {
//			m1[i] = s[i] - 'A' + 1;
//		}
//	}
//	/*for (int i = 1; i <= len; i++) {
//		cout << m1[i] << " ";
//	}*/
//	for (int i = 1; i <= len; i++) {
//		for (int j = (i - 1) * 5 + 5; j > (i - 1) * 5; j--) {
//			m2[j] = m1[i] % 2;
//			m1[i] = m1[i] / 2;
//			//cout << m2[j];
//		}
//		//cout << endl;
//	}
//	int cnt = r * c;
//	for (int i = len * 5 + 1; i <= cnt; i++) {
//		m2[i] = 0;
//		//cout << i << " " << m2[i] << endl;
//	}
//
//	/*for (int i = 1; i <= cnt; i++) {
//		cout << m2[i];
//	}
//	cout << endl;*/
//
//	//cout << cnt << endl;
//	int i = 1, j = 1;
//	int cur = 1;
//	int round = 0;
//	m3[i][j] = m2[cur++];
//	cnt--;
//	//cout << m3[i][j];
//	while (cnt) {
//		//cout << cnt << endl;
//		while (cnt&&j + 1 <= c - round) {//思想：先预判能不能走 。如果先走当前步再判断，当判断为false的时候j已经越界了
//			j++;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//
//		}
//		//system("pause");
//		while (cnt&&i + 1 <= r - round) {
//			i++;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//
//		}
//		//system("pause");
//		while (cnt&&j - 1 >= 1 + round) {
//			j--;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//
//		}
//		//system("pause");
//		round++;
//		while (cnt&&i - 1 >= 1 + round) {
//			i--;
//			cnt--;
//			m3[i][j] = m2[cur++];
//			//cout << i << " " << j << " " << m3[i][j] << endl;
//
//		}
//		//system("pause");
//	}
//
//	for (int h = 1; h <= r; h++) {
//		for (int g = 1; g <= c; g++) {
//			cout << m3[h][g];
//		}
//		//cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//#include<iostream>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	int n,cnt=0;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		cnt++;
//	}
//	int tar;
//	bool flag = false;
//	cin >> tar;
//	for (int i = 0; i < cnt; i++) {
//		if (m[i] == tar) {
//			cout << i + 1;
//			flag = true;
//			break;
//		}
//	}
//	if (!flag) {
//		cout << -1;
//	}
//	system("pause");
//	return 0;
//}

//输出最高分数的学生姓名
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//const int maxn = 10010;
//map<int, string, greater<int>> m;
//int main() {
//	int n, cnt = 0;
//	cin >> n;
//	int score;
//	string name;
//	for (int i = 0; i < n; i++) {
//		cin >> score;
//		cin >> name;
//		m.insert(pair<int, string>(score, name));
//	}
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		cout << itr->second << endl;
//		break;
//	}
//	system("pause");
//	return 0;
//}

//不高兴的津津
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//const int maxn = 7;
//int m[maxn];
//int main() {
//	int x, y;
//	int big = 0, d = -1;
//	for (int i = 0; i < 7; i++) {
//		cin >> x >> y;
//		m[i] = x + y;
//		if (m[i] > 8 && m[i] > big) {
//			big = m[i];
//			d = i+1;
//		}
//	}
//	if (d == -1) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < 7; i++) {
//		if (big == m[i]) {
//			cout << i + 1;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}

//谁拿了最多奖学金
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//multimap<int, string,greater<int>> multim;
//int main() {
//	int n;
//	cin >> n;
//	string name;
//	int score, classscore;
//	char leader, west;
//	int paper, sum = 0, tot = 0;
//	for (int i = 0; i < n; i++) {
//		sum = 0;
//		cin >> name >> score >> classscore >> leader >> west>>paper;
//		if (score > 80 && paper >= 1) {
//			sum += 8000;
//		}
//		//cout << name << " " << sum << endl;
//		if (score > 85 && classscore > 80) {
//			sum += 4000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (score > 90) {
//			sum += 2000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (score > 85 && west == 'Y') {
//			sum += 1000;
//		}
//		//cout << name << " " << sum << endl;
//
//		if (classscore > 80 && leader == 'Y') {
//			sum += 850;
//		}
//		//cout << name << " " << sum << endl;
//		tot += sum;
//		multim.insert(pair<int, string>(sum, name));
//	}
//	for (auto itr = multim.begin(); itr != multim.end(); itr++) {
//		cout << itr->second << endl<< itr->first << endl<<tot;
//		break;
//	}
//	system("pause");
//	return 0;
//}

//最大值和最小值的差
//#include<iostream>
//#include<map>
//#include<cstring>
//#include<limits.h>
//#include <iomanip>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//	int minv=INT_MAX, maxv=INT_MIN;//
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] < minv) {
//			minv = m[i];
//		}
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//	}
//	cout << maxv - minv;
//	system("pause");
//	return 0;
//}

//笨小猴
//#include<iostream>
//#include<map>
//#include<string>
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//using namespace std;
//string s;
//map<char, int>	m;
//int main() {
//
//	cin >> s;
//	for (int i = 0; i < s.length(); i++) {
//		map<char, int>::iterator iter;
//		iter = m.find(s[i]);
//		if (iter != m.end()) {
//			m[s[i]]++;
//		}
//		else {
//			m.insert(pair<char, int>(s[i], 1));
//		}
//	}
//	int minv = INT_MAX, maxv = INT_MIN;
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		//cout << itr->first << " " << itr->second << endl;
//		if (itr->second > maxv) {
//			maxv = itr->second;
//		}
//		if (itr->second < minv) {
//			minv = itr->second;
//		}
//	}
//	int v = maxv - minv;
//	if (v == 0||v==1) {
//		cout << "No Answer" << endl << 0;
//		system("pause");
//		return 0;
//	}
//
//	bool flag = true;
//	for (int i = 2; i < ceil(v / 2); i++) {
//		if (v%i == 0) {
//			flag = false;
//			break;
//		}
//	}
//	if (flag) {
//		cout << "Lucky Word" << endl << v;
//	}
//	else {
//		cout << "No Answer" << endl << 0;
//	}
//
//	//cout << v << endl;
//	system("pause");
//	return 0;
//}

//不与最大数相同的数字之和
//#include<iostream>
//#include<map>
//#include<string>
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//using namespace std;
//const int maxn = 110;
//long long m[maxn];
//int main() {
//	int n, maxv = INT_MIN;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//	}
//	long long sum = 0;
//	for (int i = 0; i < n; i++) {
//		if (m[i] != maxv) {
//			sum += m[i];
//		}
//	}
//	cout << sum;
//	system("pause");
//	return 0;
//}

//白细胞计数
//#include<iostream>
//#include<map>
//#include<string>
//#include<cmath>//abs()
//#include<math.h>//ceil floor
//#include<cstring>//memset
//#include<limits.h>//INT_MAX
//#include <iomanip>
//#include<stdlib.h>
//using namespace std;
//const int maxn = 310;
//double m[maxn];
//double var[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	memset(var, 0, sizeof(0));
//	int n;
//	cin >> n;
//	cin >> m[0];
//	//cout << m[0] << endl;
//	double minv = m[0], maxv = m[0];
//	int posmin= 0, posmax=0;
//	for (int i = 1; i < n; i++) {
//		cin >> m[i];
//		//cout <<i<<" "<< m[i] << endl;
//		if (m[i] > maxv) {
//			maxv = m[i];
//			posmax = i;
//		}
//		if (m[i] < minv) {
//			minv = m[i];
//			posmin=i;
//		}
//	}
//	if (posmax == posmin) {
//		cout << fixed << setprecision(2) << m[0] << " " << fixed << setprecision(2) << 0.00;
//		system("pause");
//		return 0;
//	}
//	//cout << "hhh" << endl;
//	double sum = 0.0;
//	for (int i = 0; i < n; i++) {
//		if (i != posmax && i != posmin) {
//			sum += m[i];
//		}
//	}
//	double av = sum / double(n - 2);
//	double maxva = 0.0;
//	for (int i = 0; i < n; i++) {
//		if (i != posmax && i != posmin) {
//			double cha;
//			if (m[i] > av) {
//				cha = m[i] - av;
//			}
//			else {
//				cha = av - m[i];
//			}
//			if (cha > maxva) {
//				maxva = cha;
//			}
//		}
//	}
//	cout << fixed << setprecision(2) << av << " " << fixed << setprecision(2) << maxva;
//	system("pause");
//	return 0;
//}

//直方图
//#include<iostream>
//#include<limits.h>
//#include<map>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//map<int, int> ans;
//int main(){
//	int n,maxv = INT_MIN;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] > maxv) {
//			maxv = m[i];
//		}
//		if (m[i] <= maxv) {
//			map<int, int>::iterator iter;
//			iter = ans.find(m[i]);
//			if (iter != ans.end()) {
//				ans[m[i]]++;
//			}
//			else {
//				ans.insert(pair<int, int>(m[i], 1));
//			}
//		}
//	}
//	int i = 0;
//	for (auto itr = ans.begin(); itr != ans.end(); itr++) {
//		while (itr->first != i) {
//			cout << 0 << endl;
//			i++;
//		}
//		cout << itr->second << endl;
//		i++;
//	}
//	system("pause");
//	return 0;
//}

//找最大数序列
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//vector<vector<int>> vv;
//vector<int> v;
//int main() {
//	string tempn;
//	int n=0;
//	getline(cin, tempn);
//	//cout << tempn.size() << endl;
//	for (int i = 0; i < tempn.size(); i++) {
//		n = tempn[i] - '0' + n * 10;
//	}
//	//cout << n;
//	string s;
//	int t=0;
//	for (int i = 0; i < n; i++) {
//		v.clear();
//		getline(cin , s);
//		for (int j = 0; j < s.size(); j++) {
//			if (s[j] != ',') {
//				t = t * 10 + s[j] - '0';
//			}
//			else {
//				//cout << t << endl;
//				v.push_back(t);
//				t = 0;
//			}
//		}
//		v.push_back(t);
//		t = 0;
//		vv.push_back(v);
//		//system("pause");
//		
//	}
//	int maxv = vv[0][0];
//	//cout << maxv;
//	for (int i = 0; i<vv.size(); i++) {
//		for (int j = 0; j < vv[i].size(); j++) {
//			if (vv[i][j] > maxv) {
//				maxv = vv[i][j];
//				
//			}
//			//cout << maxv << endl;
//		}
//	}
//	cout << maxv << endl;
//	bool flag = true;
//	for (int i = 0; i<vv.size(); i++) {
//		for (int j = 0; j < vv[i].size(); j++) {
//			if (vv[i][j]== maxv) {
//				if (flag) {
//					cout << i+1;
//					flag = false;
//					break;
//				}
//				else {
//					cout << "," << i+1;
//					break;
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//连续出现的字符
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//int main() {
//	int n;
//	string s;
//	cin >> n >> s;
//	char tar;
//	vector<char> best;
//	int temp,cnt = 1,max = 1;
//	bool flag = false;
//	for (int i = 0; i < s.size(); i++) {
//		cnt = 1;
//		tar = s[i];
//		int temp = i;
//		//cout << "i: " << i << endl;
//		while (s[++temp] == tar) {
//			cnt++;
//			i++;
//			//cout<<tar<<" "<<temp<<" " << cnt << endl;
//		}
//		if (cnt >= n) {
//			//max = cnt;
//			best.push_back(tar);
//			flag = true;
//		}
//	}
//	if (flag) {
//		cout << best[0];
//	}
//	else {
//		cout << "No";
//	}
//	system("pause");
//	return 0;
//}

//最长平台 ? 自己写的 只有9分
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	if (n == 0) {
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	char tar;
//	int temp,cnt = 1,maxv = 1;
//	for (int i = 0; i<n; i++) {
//		//cout << i << endl;
//		tar = m[i];
//		temp = i;
//		cnt = 1;
//		if (temp + 1 < n) {//y思想：先判断 再走
//			while (m[++temp] == tar) {
//				i++;
//				cnt++;
//			}
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	cout << maxv;
//	system("pause");
//	return 0;
//}


//最长平台 参考网上的 10分
//#include<iostream>
//#include<limits.h>
//#include<vector>
//#include<string>
//#include<sstream>
//#include<cmath>
//#include<cstring>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(0));
//	int n,maxv = 0,cnt = 1;
//	int a, b;
//	cin >> n>>a;
//	for (int i = 1; i < n; i++) {
//		cin >> b;
//		if (a == b) {
//			cnt++;
//		}
//		if (a != b) {
//			cnt = 1;
//			a = b;
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	
//	cout << maxv;
//	system("pause");
//	return 0;
//}

//最长平台 自己写一次 
//#include<iostream>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	int  tar, cnt = 1,maxv = 0;
//	tar = m[0];
//	for (int i = 1; i < n; i++) {
//		if (tar == m[i]) {
//			cnt++;
//		}
//		else if (tar != m[i]) {
//			cnt = 1;
//			tar = m[i];
//		}
//		if (cnt > maxv) {
//			maxv = cnt;
//		}
//	}
//	cout << maxv;
//	system("pause");
//	return 0;
//}

//整数去重
//#include<iostream>
//#include<set>
//using namespace std;
//const int maxn = 20010;
//int m[maxn];
//set<int> s;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		set<int>::iterator iter;
//		iter = s.find(m[i]);
//		if (iter == s.end()) {
//			s.insert(m[i]);
//			cout << m[i] << " ";
//		}
//		
//	}
//	
//	system("pause");
//	return 0;
//}

//铺地毯 ??思路很重要
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//const int maxn = 100010;
//int m[maxn];
//int a[maxn], b[maxn], g[maxn], k[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(a, 0, sizeof(a));
//	memset(b, 0, sizeof(b));
//	memset(g, 0, sizeof(g));
//	memset(k, 0, sizeof(k));
//	int n,x,y;
//	cin >> n;
//	
//	for (int i = 0; i < n; i++) {
//		cin >> a[i] >> b[i] >> g[i] >> k[i];
//
//	}
//	cin >> x>>y;
//	bool flag = false;
//	for (int i = n - 1; i >= 0; i--) {
//		if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
//			cout << i + 1;
//			flag = true;
//			break;
//		}
//	}
//	if (!flag)
//	{
//		cout << -1;
//	}
//	system("pause");
//	return 0;
//}

//接水问题 ??思路  问啥求啥 每个人去总时间最少的水龙头接水
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//const int maxn = 10010;
//int m1[maxn];
//int n1[maxn];
//int main() {
//	memset(m1, 0, sizeof(m1));
//	memset(n1, 0, sizeof(n1));
//	int n,m;
//	cin >> n>>m;
//	int min,pos;
//	for (int i = 0; i < n; i++) {
//		cin >> n1[i];
//	}
//	for (int i = 0; i < n; i++) {//遍历每个人
//		min = m1[0];
//		pos = 0;
//		for (int j = 1; j < m; j++) {//遍历水龙头 找到时间最短的水龙头
//			if (m1[j] < min) {
//				min = m1[j];
//				pos = j;
//			}
//		}
//		m1[pos] = m1[pos] + n1[i];
//	}
//	int max = m1[0];
//	for (int i = 0; i < m; i++) {
//		if (m1[i] > max) {
//			max = m1[i];
//		}
//	}
//	cout << max;
//	system("pause");
//	return 0;
//}

//接水问题  网上答案
//#include <iostream>
//#include <cstdio>
//#include <string>
//#include <cstring>
//#include <algorithm>
//using namespace std;
//int main() {
//	int a[100], m, n, i, j, min, minn, x, s;//
//	cin >> n >> m;
//	memset(a, 0, sizeof(a));	//数组清零，不用说了吧
//	for (i = 0; i<n; i++) {
//		cin >> x;
//		for (j = 0; j<m; j++) {
//			if (j == 0 || minn>a[j]) {
//				min = j;	//把最小值的地址赋给min，待会用
//				minn = a[j];	//把最小值赋给minn，要进行比较
//			}
//		}
//		a[min] += x;	//把接水最少的水龙头对上
//	}
//	for (i = 0; i<m; i++) if (i == 0 || s<a[i]) s = a[i];//找出最大的时间，即为所求
//	cout << s << endl;
//	return 0;
//}


//1.10编程基础之简单排序
// 谁考了第k名
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//multimap<double, string, greater<double>> m;
//int main() {
//	int n, k;
//	string id;
//	double score;
//	cin >> n >> k;
//	for (int i = 0; i < n; i++) {
//		cin >> id >> score;
//		m.insert(pair<double, string>(score,id));
//	}
//	int i = 1;
//	for (auto itr = m.begin(); itr != m.end(); itr++) {
//		if (i == k) {
//			cout << itr->second << " " << itr->first;
//		}
//		i++;
//	}
//	system("pause");
//	return 0;
//}

//奇数单增序列
//#include<iostream>
//#include<set>
//#include<string>
//using namespace std;
//multiset<int> s;
//int main() {
//	int n,temp;
//	cin >> n ;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		s.insert(temp);
//	}
//	int i = 1;
//	bool flag = true;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		if (*itr%2 == 1) {
//			if (flag) {
//				cout << *itr;
//				flag = false;
//			}
//			else {
//				cout << "," << *itr;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//成绩排序  用冒泡排序来做
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//using namespace std;
//const int maxn = 25;
//
////multimap<int,string,greater<int>> m;
//struct person {
//	char name[maxn];
//	int score;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].name >> per[i].score;
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].score < per[j + 1].score) || (per[j].score == per[j + 1].score) && strcmp(per[j].name, per[j + 1].name) > 0) {//strcmp只能比char型数组 不能比string
//				swap(per[j].score, per[j + 1].score);
//				swap(per[j].name, per[j + 1].name);
//			}
//		}
//	}
//	for (int i = 0; i < n; i++) {
//		cout << per[i].name << " " << per[i].score << endl;
//	}
//	system("pause");
//	return 0;
//}

//奖学金
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//using namespace std;
//const int maxn = 300;
//struct person {
//	int score1;
//	int score2;
//	int score3;
//	int tot;
//	int id;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].score1 >> per[i].score2 >> per[i].score3;
//		per[i].tot = per[i].score1 + per[i].score2 + per[i].score3;
//		per[i].id = i + 1;
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].tot < per[j + 1].tot) || ((per[j].tot == per[j + 1].tot) && per[j].score1<per[j+1].score1 ) ){//strcmp只能比char型数组 不能比string
//				swap(per[j].score1, per[j + 1].score1);
//				swap(per[j].score2, per[j + 1].score2);
//				swap(per[j].score3, per[j + 1].score3);
//				swap(per[j].tot, per[j + 1].tot);
//				swap(per[j].id, per[j + 1].id);
//			}
//		}
//	}
//	for (int i = 0; i < 5; i++) {
//		cout << per[i].id<<" "<<per[i].tot<<endl;
//	}
//	system("pause");
//	return 0;
//}

//分数线划定  看清楚范围！
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 5010;
//struct person {
//	int score;
//	int id;
//};
//int main() {
//	int n, m;
//	cin >> n >> m;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].id >> per[i].score;
//
//	}
//	for (int i = n - 1; i >= 0; i--) {
//		for (int j = 0; j < i; j++) {
//			if ((per[j].score < per[j + 1].score) || ((per[j].score == per[j + 1].score) && per[j].id > per[j + 1].id)) {//strcmp只能比char型数组 不能比string
//				swap(per[j].score, per[j + 1].score);
//				swap(per[j].id, per[j + 1].id);
//			}
//		}
//	}
//	int k = floor(double(m)*1.5);
//	//cout << k << endl;
//	int line;
//	for (int i = 0; i < k; i++) {
//		line = per[i].score;
//	}
//	
//	int cnt = 0;
//	for (int i = 0; per[i].score >= line; i++) {
//		cnt++;
//	}
//	cout << line << " " << cnt << endl;
//	for (int i = 0; i < cnt; i++) {
//		cout << per[i].id << " " << per[i].score << endl;
//	}
//	system("pause");
//	return 0;
//}
//


//整数奇偶排序
//#include<iostream>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//multiset<int, greater<int>> ji;
//multiset<int> ou;
//int main() {
//	int n = 10;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//		if (m[i] % 2 == 0) {
//			ou.insert(m[i]);
//		}
//		else {
//			ji.insert(m[i]);
//		}
//	}
//	for (auto itr = ji.begin(); itr != ji.end();itr++) {
//		cout << *itr << " ";
//	}
//	for (auto itr = ou.begin(); itr != ou.end(); itr++) {
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//合影效果
//#include<iostream>
//#include<iomanip>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//multiset<double, greater<double>> female;
//multiset<double> male;
//int main() {
//	int n;
//	cin >> n;
//	string gender;
//	double h;
//	for (int i = 0; i < n; i++) {
//		cin >>gender>> h;
//		if (gender == "male") {
//			male.insert(h);
//		}
//		else {
//			female.insert(h);
//		}
//	}
//	for (auto itr = male.begin(); itr != male.end(); itr++) {
//		cout <<fixed<<setprecision(2)<< *itr << " ";
//	}
//	for (auto itr = female.begin(); itr != female.end(); itr++) {
//		cout << fixed << setprecision(2)<<*itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//病人排队
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//multimap<int, string, greater<int>> older;
//vector<string> v;
//struct person
//{	
//	string id;
//	int age;
//};
//int main() {
//	int n;
//	cin >> n;
//	person per[maxn];
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].id >> per[i].age;
//		if (per[i].age >=60) {
//			older.insert(pair<int, string>(per[i].age,per[i].id));
//		}
//		else {
//			v.push_back(per[i].id);
//		}
//	}
//	for (auto itr = older.begin(); itr != older.end(); itr++) {
//		cout <<	itr->second << endl;
//	}
//	for (int i = 0; i < v.size();i++) {
//		cout << v[i]<<endl;
//	}
//	system("pause");
//	return 0;
//}

//明明的随机数
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//set<int> s;
//
//int main() {
//	int n,temp;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		s.insert(temp);
//	}
//	cout << s.size() << endl;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		cout <<*itr << " ";
//	}
//	
//	system("pause");
//	return 0;
//}

//单词排序
//#include<iostream>
//#include<iomanip>
//#include<vector>
//#include<set>
//#include<map>
//#include<string>
//#include<sstream>
//#include<cstring>//strcmp()
//#include<cmath>//floor()
//using namespace std;
//const int maxn = 110;
//set<string> se;
//
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		se.insert(temp);
//	}
//	for (auto itr = se.begin(); itr != se.end(); itr++) {
//		cout << *itr << endl;
//	}
//	system("pause");
//	return 0;
//}

//1.11编程基础之二分查找
//查找最接近的元素  ?? 背住模板
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100010;
//long long  m[maxn];
//long long que[maxn];
//void solve(long long tar, int tot) {
//	int left = 1;
//	int right = tot;
//	int mid;
//	//while (left + 1 < right) {
//	//	mid = left + ((right - left) / 2);
//	//	//cout << left << " " << mid << " " << right << " " << m[mid] << endl;
//
//	//	if (tar > m[mid]) {
//	//		left = mid;
//	//	}
//	//	else {
//	//		right = mid;
//	//	}
//	//}
//	while (left + 1 < right) {//下界 一般情况下是 left<right 但是这个值可能不存在 所以要改为 left+1 < right
//		mid = left + (right - left) / 2;//// 当A[m]=v时，左侧还可能存在v，所以y更新为m这时查找的是[x,m)
//		if (tar <= m[mid]) {// 当A[m]>v时，说明v在左侧，区间更新为[x,m)
//			right = mid;// 当A[m]<v时，说明v在右侧，区间更新为[m+1,y]
//		}
//		else {
//			left = mid;//这里本来是left = mid +1  但是值可能不在里面 所以 left= mid；
//		}
//	}//最后得到的下界是left
//
//	if (abs(tar - m[left]) <= abs(tar - m[left + 1])) {
//		cout << m[left] << endl;
//	}
//	else {
//		cout << m[left + 1] << endl;
//	}
//	return;
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//
//	}
//
//	int q;
//	cin >> q;
//	for (int i = 1; i <= q; i++) {
//		cin >> que[i];
//		//cout << i << endl;
//	}
//	//cout << "hhh" << endl;
//	for (int i = 1; i <= q; i++) {
//		if (n == 1) {
//			cout << m[1] << endl;
//			continue;//考虑n ==1的特殊情况
//		}
//		if (que[i] <= m[1]) {
//			cout << m[1] << endl;
//			continue;
//		}
//		if (que[i] >= m[n]) {
//			cout << m[n] << endl;
//			continue;
//		}
//		//cout << i << endl;
//		solve(que[i], n);
//	}
//	system("pause");
//	return 0;
//}

//二分法求函数的零点 ? 判断精度
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double getV(double x) {
//	return pow(x, 5) - 15 * pow(x, 4) + 85 * pow(x, 3) - 225 * pow(x, 2) + 274 * x - 121;
//}
//int main() {
//	long double left = 1.5;
//	long double right = 2.4;
//	long double mid = 1.5;
//	while (fabs(right - left)>1e-7) {
//		mid = left + (right - left) / 2;
//		//cout << getV(mid) << " " << mid << endl;
//		if (getV(mid) > 0) {
//			left = mid;
//		}
//		else {
//			right = mid;
//		}
//	}
//	cout << fixed << setprecision(6) << left;
//	system("pause");
//	return 0;
//}

//矩形分割  ??思路
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1000010;
//long long m[maxn];//极端情形下，R=10^6，从而R^2=10^12，考虑前缀和，将超过int——所以用long long。
//long long s[maxn];
//int r;
//int solve(int left, int right) {
//	int mid;
//	while (left < right) {
//		mid = left + (right - left) / 2;
//		if (s[mid] * 2 >= s[r]) {//s[r]为总的面积
//			right = mid;
//		}
//		else {
//			left = mid + 1;
//		}
//	}
//	return left;
//}
//int main() {
//	/*memset(m, 0, sizeof(m));//超时
//	memset(s, 0, sizeof(s));*/
//	int n;
//	cin >> r >> n;
//	int L, T, W, H;
//	for (int i = 1; i <= n; i++) {
//		cin >> L >> T >> W >> H;
//		for (int j = L + 1; j <= L + W; j++) {//这里是从L+1开始算
//			m[j] = m[j] + H;//这里是m[j] =m[j]+ H 因为纵向有可能不止一个矩形
//
//		}
//	}
//	/*for (int i = 0; i < 10; i++) {
//		cout << i << " " << m[i] << endl;
//	}*/
//	for (int i = 1; i <= r; i++) {
//		s[i] = s[i - 1] + m[i];//前缀和
//		//cout << s[i] << endl;
//	}
//	/*for (int i = 0; i < 10; i++) {
//		cout << i << " " << m[i] << " " << s[i] << endl;
//	}*/
//	if (s[r] % 2 == 0) {
//		int ans = lower_bound(s, s + r, s[r] / 2) - s;
//		while (ans < r&&s[ans] == s[ans + 1]) {
//			ans++;
//		}
//		cout << ans << endl;
//	}
//	else {
//		int ans = lower_bound(s, s + r, s[r] / 2 + 1) - s;
//		while (ans < r&&s[ans] == s[ans + 1]) {
//			ans++;
//		}
//		cout << ans << endl;
//	}
//	//自己写的二分 是对的
//	//int v = solve(1, r);
//	////cout << v << endl;
//	//while (v < r&&s[v] == s[v + 1]) {
//	//	v++;
//	//}
//	//cout << v;
//	system("pause");
//	return 0;
//}

//网线主管  ？？思路
//#include<iostream>
//#include<iomanip>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//const int maxn = 10020;
//int m[maxn];
//void solve(int n, int k, int maxv) {
//	int left = 0;//起点是0 因为有可能无法取得满足要求的绳子 中点是maxn + 1
//	int right = maxv;
//	int mid = 1;
//	int tot = 0;
//	while (left + 1 < right) {//这里要加1 否则死循环
//		mid = left + (right - left) / 2;
//		cout << left << " " << mid << " " << right << " " << tot << endl;
//		tot = 0;
//		for (int i = 1; i <= n; i++) {
//			tot += m[i] / mid;
//		}
//		if (tot < k) {//判断是否去等号的方法：加入相等了 是希望取上界还是下界！
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	cout << fixed << setprecision(2) << double(left) / 100.0 << endl;
//}
//int main() {
//	int n, k;
//	cin >> n >> k;
//	double temp;
//	int maxv;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		m[i] = 100 * temp;
//		maxv = max(maxv, m[i]);
//	}
//	solve(n, k, maxv + 1);//要加1 因为可能整条绳子刚好完全用完  而我用的二分搜索是求下界 所以会求不到最后一个元素
//	system("pause");
//	return 0;
//}

//派 ？ 精度问题 之前1e-5 和1e-8只有9分  PI的精度要求很高
//#include <iostream>
//#include<algorithm>
//#include<iomanip>
//#include<math.h>
//using namespace std;
//double PI = acos(-1.0);//精度要到位 记住PI
//const int maxn = 10020;
//int m[maxn];
//void solve(int maxv, int n, int f) {
//	//cout << "f " << f << endl;
//	double left = 0.0;
//	double right = double(maxv + 1e-8);//这里要多加一点 
//	double mid;
//	int tot = 0;
//	while (fabs(left - right) > 1e-10) {
//		mid = left + (right - left) / 2;
//		//cout << left << " " << mid << " " << right << " " << tot << endl;
//
//		tot = 0;
//		for (int i = 1; i <= n; i++) {
//			tot = tot + floor((PI * pow(m[i], 2)) / (PI * pow(mid, 2)));
//		}
//		if (tot < f) {
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	// << "l: " << left << endl;
//	cout << fixed << setprecision(3) << PI * pow(left, 2) << endl;
//}
//int main() {
//	int n, f;
//	cin >> n >> f;
//	int maxv = 0;
//	int temp;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		maxv = max(maxv, m[i]);
//		//cout << maxv << endl;
//	}
//	solve(maxv, n, f + 1);
//	system("pause");
//	return 0;
//}

//月度开销 ？？思路判断是否满足f  以及什么时候是m+1？
//#include<iostream>	
//#include<algorithm>
//#include<math.h>
//using namespace std;
//const int maxn = 100010;
//long long m[maxn];
//int  n, f;
//long long maxv;
//long long tot = 0;
//bool check(int mid) {
//	int cnt = 1;
//	long long temp = 0;
//	for (int i = 1; i <= n; i++) {
//		//cout << i << " " << m[i] << " " << cnt << endl;
//		if (m[i] + temp <= mid) {
//			temp += m[i];
//		}
//		else if (m[i] <= mid) {
//			temp = m[i];//重新开启一个月时  temp初始化为第一个月的值
//			cnt++;
//		}
//		else {
//			//cout << "false" << endl;
//			return false;
//		}
//	}
//	if (cnt > f) {
//		//cout << "false" << endl;
//		return false;
//	}
//	else
//	{
//		//cout << "true" << endl;
//		return true;
//	}
//}
//void solve() {
//	int left = maxv;
//	int right = tot;
//	int mid;
//	while (left< right) {
//		mid = left + (right - left) / 2;
//		cout << left << " " << mid << " " << right << endl;
//		//system("pause");
//		if (check(mid)) {
//			right = mid;
//		}
//		else {
//			left = mid+1;//什么时候是mid 什么时候是mid+1
//		}
//	}
//	cout << left;
//}
//int main() {
//	cin >> n >> f;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		maxv = max(maxv, m[i]);
//		tot += m[i];
//	}
//	//cout << maxv << endl;
//	solve();
//	system("pause");
//	return 0;
//}

//和为给定数 ？？思路 以及判重
//#include<iostream>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//const int maxn = 1000010;
//long long m[maxn], tar;
//int n;
//void solve() {
//	if (n == 1) {
//		cout << "No";
//		return;
//	}
//	long long temp;
//	int left, right, mid;
//	bool flag = false;
//	for (int i = 1; i <= n; i++) {
//		temp = tar - m[i];
//		left = 0;
//		right = n + 1;
//		while (left < right) {
//			mid = left + (right - left) / 2;
//			//cout << temp << " " << m[i] << " " << left << " " << mid << " " << right << " " << m[mid] << endl;
//			if (temp == m[mid] && mid !=i) {//一定要判断找到的元素不能是自己
//				
//				cout << m[i] << " " << temp << endl;
//				flag = true;
//				return;
//			}
//			else if (temp < m[mid]) {
//				right = mid;
//			}
//			else {
//				left = mid + 1;
//			}
//		}
//	}
//	if (!flag) {
//		cout << "No";
//	}
//}
//int main() {
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	sort(m + 1, m + n + 1);
//	//for (int i = 1; i <= n; i++) {
//	//	cout << m[i] << " ";
//	//}
//	cin >> tar;
//	solve();
//	system("pause");
//	return 0;
//}

//不重复地输出数 用set
//#include<iostream>
//#include<set>
//using namespace std;
//set<int> se;
//int main() {
//	int n;
//	cin >> n;
//	int temp;
//	for (int i = 0; i < n; i++) {
//		cin >> temp;
//		se.insert(temp);
//
//	}
//	for (auto itr = se.begin(); itr != se.end(); itr++) {
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//膨胀的木棍  ??思路 遍历圆心角 如果得不到满分 把精度改大
//#include<iostream>
//#include<math.h>
//#include<iomanip>
//using namespace std;
//#define PI (acos(-1))
//double l, n, c;
//double tar, r, templ, d;
//void solve() {
//	double left = 0;
//	double right = PI;
//	double mid;
//	while (fabs(right - left) > 1e-15) {
//		mid = left + (right - left) / 2;
//		r = l / 2 / sin(mid/2);//这里圆心角的度数要除以2
//		templ = r * mid;
//		//cout << left << " " << mid << " " << right << " " << templ << endl;
//		if (templ >= tar) {
//			right = mid;
//		}
//		else {
//			left = mid;
//		}
//	}
//	r = l / 2 / sin(mid/2);
//	d = r - r * cos(left/2);
//	cout << fixed << setprecision(3) << d;
//}
//int main() {
//	cin >> l >> n >> c;
//	tar = (1.0 + n * c)*l;
//	solve();
//	system("pause");
//	return 0;
//}


//河中跳房子  ??思路 遍历最小距离 一般思路 求什么遍历什么 最开始只有5分 没有把终点石头加进去
//#include<iostream>
//#include<math.h>
//#include<iomanip>
//using namespace std;
//const long long  maxn = 50010;
//long long m[maxn];
//long long l, n, c;
//bool check(long long mid) {
//	long long pos = 0;
//	int cnt = 0;
//	for (int i = 1; i <= n; i++) {
//		if (m[i] - pos < mid) {
//			cnt++;
//		}
//		else {
//			pos = m[i];
//		}
//	}
//	if (cnt <= c) {
//		return true;
//	}
//	else { 
//		return false; 
//	}
//}
//void solve() {
//	long long left = 0;
//	long long right = l + 1;
//	long long mid;
//	while (left +1 < right) {
//		mid = left + (right - left) / 2;
//
//		//cout << left << " " << mid << " " << right << " " << check(mid) << endl;
//		if (check(mid)) {
//			left = mid;
//		}
//		else {
//			right = mid;
//		}
//	}
//	cout << left;
//}
//int main() {
//	cin >> l >> n >> c;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	m[++n] = l;
//	solve();
//	system("pause");
//	return 0;
//}

//1.12编程基础之函数与过程抽象
//简单算术表达式求值
//#include<iostream>
//#include<string>
//using namespace std;
//int main() {
//	int a, b;
//	char c;
//	cin >> a >> c >> b;
//	int res;
//	if (c == '+') {
//		res = a + b;
//	}
//	else if (c == '-') {
//		res = a - b;
//
//	}
//	else if (c == '*') {
//		res = a * b;
//	}
//	else if (c == '/') {
//		res = double(a) / double(b);
//	}
//	else if (c == '%') {
//		res = a % b;
//
//	}
//	cout << res << endl;
//	system("pause");
//	return 0;
//}

//短信计费
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	double tot = 0.0;
//	int x;
//	for (int i = 0; i < n; i++) {
//		cin >> x;
//		tot += ceil(double(x) / 70.0);
//	}
//	cout << fixed << setprecision(1) << tot * 0.1 << endl;
//	system("pause");
//	return 0;
//}

//甲流病人初筛
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<cmath>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	string name;
//	double t;
//	int kesou;
//	int cnt = 0;
//	for (int i = 0; i < n; i++) {
//		cin >> name >> t >> kesou;
//		if (t >= 37.5&&kesou == 1) {
//			cout << name << endl;
//			cnt++;
//		}
//	}
//	cout << cnt << endl;
//	system("pause");
//	return 0;
//}

//最匹配的矩阵
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<climits>
//#include<cmath>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int part[maxn][maxn];
//int main() {
//	int row, col, r, c;
//	cin >> row >> col;
//	for (int i = 0; i < row; i++) {
//		for (int j = 0; j < col; j++) {
//			cin >> m[i][j];
//		}
//	}
//	cin >> r >> c;
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> part[i][j];
//		}
//	}
//
//	int minv = INT_MAX;
//	int posx, posy;
//	for (int i = 0; i <= row - r; i++) {
//		for (int j = 0; j <= col - c; j++) {
//			int tot = 0;
//			for (int p = i; p < i + r; p++) {
//				for (int q = j; q < j + c; q++) {
//					//cout << "hhh " << p << " " << q << " " << m[p][q] << endl;
//					tot += abs(m[p][q] - part[p - i][q - j]);
//				}
//			}
//			//cout << i << " " << j << " " << tot << endl;
//			if (tot < minv) {
//				minv = tot;
//				posx = i;
//				posy = j;
//			}
//		}
//	}
//	//cout << posx << " " << posy << endl;
//	for (int i = posx; i < posx + r; i++)
//	{
//		for (int j = posy; j < posy + c; j++)
//		{
//			cout << m[i][j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//统计单词数  题意理解错了 单词首字母在文章中的位置
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<climits>
//#include<cmath>
//#include<sstream>
//using namespace std;
//int main() {
//	string tar;
//	string line;
//	cin >> tar;
//	for (int i = 0; i < tar.length(); i++) {
//		tar[i] = tolower(tar[i]);
//	}
//
//	string nonsens;
//	getline(cin, nonsens);
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;  
//
//	int pos = 0;
//	int cnt = 0;
//	int p = 0;
//	int flag = 1;
//	while (ss >> temp) {
//		for (int i = 0; i < temp.length(); i++) {
//			temp[i] = tolower(temp[i]);
//		}
//
//		if (temp == tar) {
//			if (flag) {
//				pos = p;
//				flag = 0;
//			}
//			cnt++;
//		}
//		p++;
//		pos = pos + temp.size() + 1;
//	}
//	if (cnt == 0) {
//		cout << -1;
//	}
//	else {
//		cout << cnt << " " << pos << endl;
//	}
//	system("pause");
//	return 0;
//}


//统计单词数  重新写  
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<climits>
//#include<cmath>
//#include<sstream>
//#include<cstring>
//using namespace std;
//int main() {
//	string tar;
//	string str;
//	cin >> tar;
//	for (int i = 0; i < tar.length(); i++) {
//		tar[i] = tolower(tar[i]);
//	}
//
//	string nonsens;
//	getline(cin, nonsens);
//	getline(cin, str);
//	int cnt = 0;
//	int pos = -1;
//	string temp = "";
//	int flag = 1;//判断是否是第一次出现
//
//	for (int i = 0; i < str.length(); i++) {
//		if (isalpha(str[i])) {
//			str[i] = tolower(str[i]);
//			temp += str[i];
//			//cout << j << " " << temp << endl;
//			if (i == str.length() - 1) {
//				//cout << temp << endl;
//
//				if (!temp.empty()) {
//					if (temp == tar) {
//						cnt++;
//						if (flag) {
//							pos = i - temp.length();
//							flag = 0;
//						}
//					}
//				}
//			}
//		}
//		else {
//			//cout << temp << endl;
//			if (temp == tar) {
//				cnt++;
//				if (flag) {
//					//cout << "hh " << temp << " " << pos_i << endl;
//					pos = i - temp.length();
//					flag = 0;
//				}
//			}
//
//			temp = "";
//		}
//	}
//
//
//	if (cnt) {
//		cout << cnt << " " << pos;
//	}
//	else {
//		cout << -1;
//	}
//	system("pause");
//	return 0;
//}


//寻宝  网上答案1  有点繁琐
//#include <iostream>
//using namespace std;
//int stairs_cnt[10010], has_stairs[10010][101], board_number[10001][101];
//int read() //输入模板 ，在本题中很重要 
//{
//	int x = 0, f = 1;
//	char ch = getchar();
//	while (ch<'0' || ch>'9')
//	{
//		if (ch == '-') f = -1;
//		ch = getchar();
//	}
//	while (ch >= '0'&&ch <= '9')
//	{
//		x = x * 10 + ch - '0';
//		ch = getchar();
//	}
//	return x * f;
//}
//int main()
//{
//	int i, j, flr, room, frt_room;
//	flr = read();
//	room = read();
//	//cout << n << " " << m << endl;
//	for (i = 1; i <= flr; i++)//楼层从1开始
//	{
//		//has_stairs数组表示当前房间有没有楼梯，b数组表示当前房间的指示牌 
//		for (j = 0; j < room; j++) {//房间从0开始 
//			has_stairs[i][j] = read();
//			board_number[i][j] = read();
//			if (has_stairs[i][j] == 1) {
//				stairs_cnt[i]++;
//			}
//		}
//	}
//	frt_room = read();
//	j = frt_room;
//	int ans = 0, temp = 0;
//	for (i = 1; i <= flr; i++)
//	{
//		ans += board_number[i][frt_room];
//		ans %= 20123;
//		j = frt_room;
//		temp = 0;
//		if (board_number[i][frt_room] % stairs_cnt[i] == 0) {
//			board_number[i][frt_room] = stairs_cnt[i];
//		} //为了防止指示牌上是一个比m大很多倍的数，循环太多遍会超限 
//		else {
//			board_number[i][frt_room] = board_number[i][frt_room] % stairs_cnt[i];
//		}
//		if (has_stairs[i][frt_room] == 1) {
//			temp++;  //如果起点有楼梯，要减去当前楼梯 
//		}
//		// cout<<"ans"<<ans<<endl;
//		while (temp < board_number[i][frt_room])  //找第二层的起始位置 
//		{
//			j++;
//			if (j >= room) j = 0;
//			if (has_stairs[i][j] == 1) temp++;
//		}
//		frt_room = j;
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}


//寻宝 网上答案2 
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//typedef pair<int, int> PII;
//PII a[10010][110];
//int main()
//{
//	int n, m;
//	cin >> n >> m;
//	for (int i = 0; i<n; i++)
//	{
//		int cnt = 0;
//		for (int j = 0; j<m; j++)
//		{
//			//cin>>a[i][j].first>>a[i][j].second;
//			scanf("%d%d", &a[i][j].first, &a[i][j].second);
//			if (a[i][j].first == 1)
//				cnt++;
//		}
//		a[i][m].second = cnt;
//	}
//	int start;
//	cin >> start;
//	int ans = 0;
//	for (int i = 0; i<n; i++)
//	{
//		ans = (ans + a[i][start].second) % 20123;
//		//cout<<ans;
//		int k = 0;
//		for (int j = start;; j++)
//		{
//			if (j == m) j = 0;
//			if (a[i][j].first == 1) k++;
//			//取模运算取值范围是0-a[i][m].second   但是k遇到一扇门就要++  范围从1开始取的  所以要调整取值范围
//			//先-1  再+1相当于  将等于0的数 变成了等于 a[i][m].second
//			if (k == (a[i][start].second - 1) % a[i][m].second + 1)
//			{
//				start = j;
//				break;
//			}
//			//最关键的停止条件，循环找对，取模，都靠它。
//		}
//
//	}
//	cout << ans;
//	return 0;
//
//}


//寻宝 自己写
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//struct Room
//{
//	int num;
//	int has;
//};
//Room r[10010][110];
//int main() {
//	int n, m;
//	cin >> n >> m;
//	for (int i = 0; i < n; i++) {
//		int cnt = 0;
//		for (int j = 0; j < m; j++) {
//			//cin >> r[i][j].has >> r[i][j].num;
//			scanf("%d%d", &r[i][j].has, &r[i][j].num);
//			if (r[i][j].has == 1) {
//				cnt++;
//			}
//		}
//		r[i][m].num = cnt;
//	}
//	int start;
//	cin >> start;
//	//scanf_s("%d", start);
//	int ans = 0;
//	for (int i = 0; i < n; i++) {
//		ans = (ans + r[i][start].num) % 20123;
//		int step = 0;
//		int index;
//		for (index = start;; index++) {
//			if (index == m) {
//				index = 0;
//			}
//			if (r[i][index].has == 1) {
//				step++;
//			}
//			//取模运算取值范围是0-a[i][m].second   但是k遇到一扇门就要++  范围从1开始取的  所以要调整取值范围
//			//先-1  再+1相当于  将等于0的数 变成了等于 a[i][m].second
//			if (step == (r[i][start].num - 1) % r[i][m].num + 1) {
//				start = index;
//				break;
//			}
//		}
//	}
//	cout << ans << endl;
//	//system("pause");
//	return 0;
//}


//机器翻译
//#include<iostream>
//#include<queue>
//#include<set>
//using namespace std;
//int main() {
//	int m, n;
//	cin >> m >> n;
//	int tp;
//	queue<int> q;
//	set<int> s;
//	int ans = 0;
//	for (int i = 0; i < n; i++) {
//		cin >> tp;
//		if (s.find(tp) == s.end()) {
//			if (s.size() < m) {
//				q.push(tp);
//				s.insert(tp);
//				ans++;
//				//cout << tp << " " << ans << endl;
//			}
//			else {
//				int del = q.front();
//				q.pop();
//				s.erase(del);
//				q.push(tp);
//				s.insert(tp);
//				ans++;
//				//cout << tp<<" "<<ans<<endl;
//			}
//		}
//		
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//Vigenère密码  超时
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int main() {
//	string k;
//	string c;
//
//	cin >> k >> c;
//
//	int lenk = k.length();
//	int lenc = c.length();
//	int t = ceil(double(lenc) / double(lenk));
//	for (int i = 0; i < t - 1; i++) {
//		k += k;
//	}
//	char tp;
//	//cout << k;
//	for (int i = 0; i < lenc; i++) {
//		if (c[i] >= 'a'&&c[i] <= 'z') {
//			k[i] = tolower(k[i]);
//			//cout << "hhh	"<<i<<" " << k[i] << " " << int(k[i] - 'a') << " " << c[i] << " " << c[i] - 'a' << endl;
//			tp = char((c[i] + 26 - k[i]) % 26 + 'a');
//		}
//		else {
//			k[i] = toupper(k[i]);
//			tp = char((c[i] + 26 - k[i]) % 26 + 'A');
//		}
//		cout << tp;
//	}
//	system("pause");
//	return 0;
//}

//Vigenère密码 网友答案  思路和我的差不多
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//string k, c;//密钥，密文 
//int main()
//{
//	cin >> k >> c;
//	string s = k;
//	int lenk = k.length(), lenc = c.length();
//	int	i, j = lenc / lenk + 1;
//	for (i = 1; i < j; i++) {
//		k += s;
//
//	}
//	transform(k.begin(), k.end(), k.begin(), ::toupper);
//	for (i = 0; i < lenc; i++) {
//		c[i] = c[i] >= 'A'&&c[i] <= 'Z' ? (26 - k[i] + c[i]) % 26 + 65 : (-6 - k[i] + c[i]) % 26 + 97;
//	}
//	cout << c;
//	system("pause");
//	return 0;
//}

//图像旋转翻转变换
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int main() {
//	int r, c;
//	cin >> r >> c;
//	int rr = r;
//	int cc = c;
//	int mx = max(r, c);
//	for (int i = 0; i < r; i++) {
//		for (int j = 0; j < c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	char ch;
//	int cnta = 0;
//	int cntb = 0;
//	while (cin >> ch) {
//		if (abs(cntb - cnta) % 2 != 0) {
//			rr = c;
//			cc = r;
//		}
//		else {
//			rr = r;
//			cc = c;
//		}
//		//cout << cnta << " " << cntb << " " << rr << " " << cc << endl;
//		if (ch == 'A') {
//			cnta++;
//			int temp[maxn][maxn];
//
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					temp[i][j] = m[i][j];
//				}
//			}
//			/*for (int i = 0; i < 3; i++) {
//				for (int j = 0; j < 3; j++) {
//					cout << temp[i][j] << " ";
//				}
//				cout << endl;
//			}*/
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					m[j][rr - i - 1] = temp[i][j];
//				}
//			}
//		}
//		if (ch == 'B') {
//			cntb++;
//			int temp[maxn][maxn];
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					temp[i][j] = m[i][j];
//				}
//			}
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					m[cc - j - 1][i] = temp[i][j];
//				}
//			}
//		}
//		if (ch == 'C') {
//			//cout << "xx" << endl;
//			int temp[maxn][maxn];
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					temp[i][j] = m[i][j];
//				}
//			}
//			/*for (int i = 0; i < 3; i++) {
//				for (int j = 0; j < 3; j++) {
//					cout << temp[i][j] << " ";
//				}
//				cout << endl;
//			}*/
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					m[i][cc - j - 1] = temp[i][j];
//				}
//			}
//		}
//		if (ch == 'D') {
//			int temp[maxn][maxn];
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					temp[i][j] = m[i][j];
//				}
//			}
//			for (int i = 0; i < rr; i++) {
//				for (int j = 0; j < cc; j++) {
//					m[rr - i - 1][j] = temp[i][j];
//				}
//			}
//		}
//		/*cout << "hhh" << endl;
//
//		for (int i = 0; i < 3; i++) {
//			for (int j = 0; j < 3; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//
//
//	}
//	if (cnta < cntb) {
//		swap(cnta, cntb);
//	}
//	cnta = cnta - cntb;
//	if (cnta % 2 == 0) {
//		for (int i = 0; i < r; i++) {
//			for (int j = 0; j < c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}
//	}
//	else {
//		for (int i = 0; i < c; i++) {
//			for (int j = 0; j < r; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}
//	}
//
//
//	system("pause");
//	return 0;
//}


//素数对
//#include<iostream>
//#include<vector>
//using namespace std;
//vector<int> v;
//int main() {
//	for (int i = 3; i < 10010; i = i + 2) {
//		int flag = 1;
//		for (int j = 2; j*j <= i; j++) {//等号不能忘
//			if (i%j == 0) {
//				flag = 0;
//				break;
//			}
//		}
//		if (flag) {
//			//cout << i << endl;
//			v.push_back(i);
//		}
//	}
//
//	int n;
//	cin >> n;
//	int suc = 0;
//	for (int i = 0; v[i + 1] <= n; i++) {
//		if (v[i + 1] - v[i] == 2) {
//			cout << v[i] << " " << v[i + 1] << endl;
//			suc = 1;
//		}
//	}
//	if (!suc) {
//		cout << "empty";
//	}
//	system("pause");
//	return 0;
//}

//1.13编程基础之综合应用
//数制转换  8分-n有可能为0 9分-大于10的数字转化成了错误的字母
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//const int maxn = 10000000;
//int temp[maxn];
//int main() {
//	long long a, b;
//	string n;
//	cin >> a >> n >> b;
//	int len = n.length();
//	long long ten = 0;
//	for (int i = 0; i <len; i++) {
//		if (isdigit(n[i])) {
//			temp[i] = n[i] - '0';
//		}
//		else {
//			temp[i] = toupper(n[i]) - 'A' + 10;
//		}
//		ten = temp[i] + ten * a;
//		//cout << ten << endl;
//	}
//	//cout << ten << endl;
//	string res = "";
//	if (ten == 0) {
//		res = "0";
//	}
//	while (ten!= 0) {
//		long long yu = ten % b;
//		ten = ten / b;
//		if (yu > 9) {
//			char ch =  char(yu - 10 + 'A');//要先减去10
//			//cout << "hhhh " << ch << endl;
//			res += ch;
//		}
//		else {
//			char ch = yu+'0';
//			//cout << "hhhh " << ch << endl;
//
//			res += ch;
//		}
//		//res += yu;
//		//cout << yu <<" "<<res<<" "<<ten<< endl;
//	}
//	reverse(res.begin(), res.end());
//	cout << res << endl;
//	system("pause");
//	return 0;
//}


//不吉利日期  网上标答  方法很巧妙
//#include <iostream>
//using namespace std;
//const int DAYS = 7;
//const int N = 13;
//enum DAY { MON = 1, TUE, WED, THU, FRI, SAT, SUN };
//int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
//
//int main()
//{
//	int w, day;
//
//	cin >> w;
//
//	for (int i = 1; i <= 12; i++) {
//		day = (w - 1 + N) % DAYS;
//		if (day == FRI)
//			cout << i << endl;
//
//		w = (w + days[i - 1]) % DAYS;
//	}
//	system("pause");
//	return 0;
//}

//不吉利日期
//#include<iostream>
//using namespace std;
//int month[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
//int main() {
//	int w;
//	cin >> w;
//	for (int i = 1; i <= 12; i++) {
//		int now = (w - 1 + 13) % 7;
//		if (now == 5) {
//			cout << i << endl;
//		}
//		w = (w + month[i - 1]) % 7;//这里w不用-1
//	}
//	system("pause");
//	return 0;
//}


//八进制小数
//#include<iostream>
//#include<stdio.h>
//#include<string>
//using namespace std;
//int main() {
//	char nonsense;
//	cin >> nonsense >> nonsense;
//	string str;
//	cin >> str;
//	int len = str.length();
//	//cout << str << endl;
//	double ans = 0.0;
//	for (int i = len - 1; i >= 0; i--) {
//		ans = ans * 0.125 + (str[i] - '0')*0.125;
//		//cout << str[i] << " " << ans * 0.125 << " " << ans << endl;
//	}
//	cout << "0." << str << " [8] = ";
//	printf("%.45g", ans);//3*15 = 45位  g表示去掉末尾多余的0
//	cout << " [10]" << endl;
//	//system("pause");//必须注释掉 不然过不了
//	return 0;
//}

//垂直直方图
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<cstring>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//const int maxn = 350;
//char res[maxn][26];
//int m[26];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(res, 0, sizeof(res));
//	string line;
//	int mx = 0;
//	for (int k = 0; k < 4; k++) {
//		getline(cin, line);
//		stringstream ss(line);
//		char temp;
//		while (ss >> temp) {
//			//cout << temp << endl;
//			if (temp >= 'A'&&temp <= 'Z') {
//				m[temp - 'A'] = m[temp - 'A'] + 1;
//				mx = max(mx, m[temp - 'A']);
//			}
//		}
//	}
//	//cout << mx << endl;
//	for (int i = 0; i < 26; i++) {
//
//		for (int j = 0; j < mx - m[i]; j++) {
//			res[j][i] = ' ';
//		}
//		for (int j = mx - m[i]; j <= mx; j++) {
//			res[j][i] = '*';
//		}
//	}
//
//
//	int flag = 1;
//	for (int i = 0; i < mx; i++) {
//		flag = 1;
//		for (int j = 0; j < 26; j++) {
//			if (flag) {
//				cout << res[i][j];
//				flag = 0;
//			}
//			else {
//				cout << " " << res[i][j];
//			}
//		}
//		cout << endl;
//	}
//	cout << 'A';
//	for (int i = 1; i < 26; i++) {
//		cout << " " << char('A' + i);
//	}
//	cout << endl;
//	system("pause");
//	return 0;
//}

//素数回文数的个数
//#include<iostream>
//#include<string>
//#include<sstream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int res = 0;
//	for (int cnt = 11; cnt <= n; cnt = cnt + 2) {
//		int suc = 1;
//		for (int i = 3; i*i <= cnt; i = i+2) {
//			if (cnt%i == 0) {
//				suc = 0;
//				break;
//			}
//		}
//		if (suc) {
//			
//			stringstream ss;
//			string str;
//			ss << cnt;
//			ss >> str;
//
//			int len = str.length();
//			int flag = 1;
//			for (int i = 0, j = len - 1; i <= j; i++, j--) {
//				if (str[i] != str[j]) {
//					flag = 0;
//					break;
//
//				}
//			}
//			if (flag) res++;
//			//cout << str << " " << res << endl;
//
//		}
//		
//	}
//	cout << res << endl;
//	system("pause");
//	return 0;
//}

//循环数
//#include<cstdio>
//#include<iostream>
//#include<set>
//#include<cstring>
//#include<string>
//using namespace std;
//const int maxn = 70;
//int res[maxn];
//int main()
//{
//	memset(res, 0, sizeof(res));
//	string str;
//	cin >> str;
//	int len = str.length();
//	int flag = 1;
//	for (int i = 0; i < len / 2; i++) {
//		//cout << str[i] << " " << str[len / 2 + i] << endl;
//		if (str[i] + str[len / 2 + i] - 2 * '0' != 9) {
//			flag = 0;
//			break;
//		}
//	}
//	if (flag == 0) {
//		cout << 0 << endl;
//		system("pause");
//		return 0;
//	}
//	int index = 0;
//	for (int i = len - 1; i >= 0; i--) {
//		res[index] = res[index] + ((str[i] - '0') * (len + 1));
//		//cout << index << " " << res[index] << endl;
//		res[index + 1] = res[index] / 10;
//		res[index] = res[index] % 10;
//		//cout << index << " " << res[index] << endl;
//
//		index++;
//	}
//	res[index ] = res[index-1] / 10;
//	res[index-1] = res[index-1] % 10;
//	if (res[index] != 0) {
//		cout << 0 << endl;
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < len; i++) {
//		if (res[i] != 9) {
//			cout << 0 << endl;
//			system("pause");
//			return 0;
//		}
//	}
//	cout << 1 << endl;
//	system("pause");
//	return 0;
//}


//玛雅历 网上答案
//#include<iostream>
//#include<string>
//using namespace std;
//string Haab_Month[] = { "pop", "no", "zip", "zotz", "tzec", "xul", "yoxkin", "mol", "chen", "yax", "zac", "ceh", "mac", "kankin", "muan", "pax", "koyab", "cumhu", "uayet" };
//string Holly_Month[] = { "imix", "ik", "akbal", "kan", "chicchan", "cimi", "manik", "lamat", "muluk", "ok", "chuen", "eb", "ben", "ix", "mem", "cib", "caban", "eznab", "canac", "ahau" };
//int main()
//{
//	int n, day, year;
//	string month;
//	cin >> n;特殊日历计算特殊日历计算特殊日历计算
//	cout << n << endl;
//	while (n--)
//	{
//		scanf_s("%d.", &day);
//		cin >> month >> year;
//		int i, sum = 0;
//		for (i = 0; i < 19; i++)
//		{
//			if (Haab_Month[i] == month)
//				break;
//		}
//		sum = (year * 365) + (i * 20) + day;
//		//cout << "hhh " << sum << endl;
//
//		year = sum / 260;
//		//数字和单词各自独立循环使用
//		//数字周期是13 时期的周期是20 
//		month = Holly_Month[sum % 20];
//		day = sum % 13 + 1;
//		cout << day << " " << month << " " << year << endl;
//	}
//	system("pause");
//	return 0;
//}


//玛雅历  自己写的
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//string Haab_Month[19] = { "pop", "no", "zip", "zotz", "tzec", "xul", "yoxkin", "mol", "chen", "yax", "zac", "ceh", "mac", "kankin", "muan", "pax", "koyab", "cumhu", "uayet" };
//string Holly_Month[20] = { "imix", "ik", "akbal", "kan", "chicchan", "cimi", "manik", "lamat", "muluk", "ok", "chuen", "eb", "ben", "ix", "mem", "cib", "caban", "eznab", "canac", "ahau" };
//int main() {
//	int n;
//	cin >> n;
//	cout << n << endl;
//	for (int cnt = 0; cnt < n; cnt++) {
//		int day, year;
//		string month;
//		char nonsense;
//		cin >> day >> nonsense >> month >> year;
//		int i;
//		for (i = 0; i < 19; i++) {
//			if (month == Haab_Month[i]) {
//				break;
//			}
//		}
//		int sum = year * 365 + i * 20 + day;//i要比正常的下标少1
//		//cout << sum << endl;
//		year = sum / 260;
//		month = Holly_Month[sum % 20];//月份的下标范围是0-19 刚好对应
//		day = sum % 13 + 1;
//		cout << day << " " << month << " " << year << endl;
//	}
//	system("pause");
//	return 0;
//}

//特殊日历计算 网上答案
//#include <stdio.h>
//int mon[2][13] = { 0,0,31,59,90,120,151,181,212,243,273,304,334,
//0,0,31,60,91,121,152,182,213,244,274,305,335 };
//int year_day(int year)
//{
//	if ((!(year % 4) && (year % 100)) || (!(year % 400))) return 1;
//	return 0;
//}
//int main()
//{
//	int n, hour, minute, second, day, month, year, mhour, mmin, msec, mday, mmonth, myear, i;
//	scanf("%d", &n);
//	while (n--)
//	{
//		scanf("%d:%d:%d %d.%d.%d", &hour, &minute, &second, &day, &month, &year);
//		int lun = (year - 2000) / 400;
//		for (i = 0; i < lun; i++)
//			day += 146097;//400年里有97个闰年  97+365*400
//		year = (year - 2000) % 400;
//		for (i = 0; i < year; i++)
//			day += year_day(i) + 365;
//		day += mon[year_day(year)][month];//只加month之前的整月的天数
//		day--;
//		second += minute * 60 + hour * 3600;
//		//有一种特殊的日历法，它的一天和我们现在用的日历法的一天是一样长的
//		second *= 1000;
//		second /= 864;
//
//		myear = day / 1000;
//		day %= 1000;
//		mmonth = day / 100 + 1;
//		mday = (day % 100) + 1;
//		mhour = second / 10000;
//		second %= 10000;
//		mmin = second / 100;
//		msec = second % 100;
//		printf("%d:%d:%d %d.%d.%d\n", mhour, mmin, msec, mday, mmonth, myear);
//	}
//	return 0;
//}

//特殊日历计算 自己写
//#include<iostream>
//using namespace std;
//int mon_day[2][13] = {
//	0,0,31,59,90,120,151,181,212,243,273,304,334,
//	0,0,31,60,91,121,152,182,213,244,274,305,335
//};
//int isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || x % 400 == 0) {
//		return 1;
//	}
//	return 0;
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int cnt = 0; cnt < n; cnt++) {
//		int h, m, s, year, month, day;
//		char nonsense;
//		cin >> h >> nonsense >> m >> nonsense >> s >> day >> nonsense >> month >> nonsense >> year;
//		year = year - 2000;
//		int sum = 0;
//		for (int i = 0; i < year; i++) {
//			sum = sum + isRun(i) + 365;
//		}
//		//cout << sum << endl;
//
//		sum = sum + mon_day[isRun(year)][month] + day;
//		sum--;//这里要减1 因为起始天数为1 但是实际上过了0天
//		//cout << "sum " << sum << endl;
//		int sec = h * 3600 + m * 60 + s;
//		sec = sec * 1000 / 864;
//
//		int myyear = sum / 1000;
//		sum = sum % 1000;
//		int mymonth = sum / 100 + 1;//从1开始计数
//		int myday = sum % 100 + 1;//从1开始计数
//
//		int myhour = sec / 10000;
//		sec = sec % 10000;
//		int mymin = sec / 100;
//		sec = sec % 100;
//		int mysec = sec;
//		cout << myhour << ":" << mymin << ":" << mysec << " " << myday << "." << mymonth << "." << myyear << endl;
//	}
//	system("pause");
//	return 0;
//}

//大整数乘法 网上答案
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int main() {
//	string a;
//	string b;
//	int aa[201];
//	int bb[201];
//	int mul[410];
//	memset(aa, 0, sizeof(aa));
//	memset(bb, 0, sizeof(bb));
//	memset(mul, 0, sizeof(mul));
//	cin >> a >> b;
//	int i, j;
//	int lena = a.length();
//	int lenb = b.length();
//
//	j = 0;
//	for (i = lena - 1; i >= 0; i--) {
//		aa[j++] = a[i] - '0';
//	}
//	j = 0;
//	for (i = lenb - 1; i >= 0; i--) {
//		bb[j++] = b[i] - '0';
//	}
//	for (i = 0; i < lena; i++) {
//		for (j = 0; j < lenb; j++) {
//			mul[i + j] += aa[i] * bb[j];//记住这里
//		}
//	}
//	for (i = 0; i < 410; i++) {
//		if (mul[i] >= 10) {
//			int re = mul[i] / 10;
//			mul[i] %= 10;
//			mul[i + 1] += re;
//		}
//	}
//	bool f = false;
//	for (i = 409; i >= 0; i--)
//	{
//		if (mul[i] != 0) {
//			f = true;
//		}
//		if (f) {
//			printf("%d", mul[i]);
//		}
//	}
//	if (!f) {
//		printf("0");
//	}
//	system("pause");
//	return 0;
//}

//大整数乘法
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 40010;
//long long res[maxn];//要改成longlong 
//int main() {
//	memset(res, 0, sizeof(res));
//	string a;
//	string b;
//	cin >> a >> b;
//	reverse(a.begin(), a.end());
//	reverse(b.begin(), b.end());
//	//cout << a << " " << b << endl;
//	int i, j;
//	for (i = 0; i < a.size(); i++) {
//		for (j = 0; j < b.size(); j++) {
//			res[i + j] += (a[i] - '0') * (b[j] - '0');
//			if (res[i + j] >= 10) {
//				res[i + j + 1] += res[i + j] / 10;
//				res[i + j] = res[i + j] % 10;
//			}
//			
//
//		}
//	}
//	
//	int flag = 0;
//	for (int k = i * j; k >= 0; k--) {
//		if (flag) {
//			cout << res[k];
//			continue;
//		}
//		if (res[k] != 0) {
//			flag = 1;
//			cout << res[k];
//		}
//	}
//	if (a == "0" || b == "0") {
//		cout << 0;
//	}
//	system("pause");
//	return 0;
//}

//判决素数个数  
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int solve(int x) {
//	if (x == 1) {
//		return 0;
//	}
//	for (int i = 2; i <= sqrt(x); i++) {
//		if (x%i == 0) {
//			return 0;
//		}
//	}
//	//cout << x << endl;
//	return 1;
//}
//int main() {
//	int x, y;
//	cin >> x >> y;
//	int cnt = 0;
//	if (x > y) {
//		swap(x, y);
//	}
//	for (int i = x; i <= y; i++) {
//		cnt += solve(i);
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//回文素数 网上答案
//#include <iostream>
//#include <cmath>
//#include <vector>
//#include <set>
//#include <time.h>
//#include<algorithm>
//#include <string>
//using namespace std;
//const int limits = 100000;
//vector<int>primenum(1, 2);
//
//bool PrimeJudge(int n);
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 3; i <= limits; i += 2) {//find the prime number which is less than limits
//		bool flag = true;
//		for (int j = 0; j < primenum.size() && primenum[j] <= sqrt(i); j++) {
//			//cout << primenum.size() << endl;
//			if (i%primenum[j] == 0) {
//				flag = false;
//				break;
//			}
//		}
//		if (flag) {
//			//cout << i << endl;
//			primenum.push_back(i);
//		}
//	}
//	set<int>dst;
//	if (n == 1) {
//		for (int i = 2; i < 10; i++) {
//			if (PrimeJudge(i))
//				dst.insert(i);
//		}
//	}
//	else
//		for (int i = pow(10, n / 2 - 1); i < pow(10, n / 2); i++) {
//			int palindrome;
//			if (n % 2 == 0) {
//				string temp = to_string(i);
//				reverse(temp.begin(), temp.end());
//				/*int l = 0, r = (int)temp.size() - 1;
//				while (l < r) {
//					swap(temp[l], temp[r]);
//					l++;
//					r--;
//				}*/
//				palindrome = stoi(to_string(i) + temp);
//				if (PrimeJudge(palindrome))
//					dst.insert(palindrome);
//			}
//			else {
//				for (int mid = 0; mid <= 9; mid++) {
//					string temp = to_string(i);
//					reverse(temp.begin(), temp.end());
//					/*int l = 0, r = (int)temp.size() - 1;
//					while (l < r) {
//						swap(temp[l], temp[r]);
//						l++;
//						r--;
//					}*/
//					palindrome = stoi(to_string(i) + to_string(mid) + temp);
//					if (PrimeJudge(palindrome))
//						dst.insert(palindrome);
//				}
//			}
//		}
//	cout << dst.size() << endl;
//	while (!dst.empty()) {
//		cout << *dst.begin();
//		dst.erase(dst.begin());
//		if (!dst.empty())cout << ' ';
//	}
//	system("pause");
//	return 0;
//}
//
//bool PrimeJudge(int n) {
//	bool resault = true;
//	for (int i = 0; i < primenum.size() && primenum[i] <= sqrt(n); i++) {
//		if (n%primenum[i] == 0) {
//			resault = false; break;
//		}
//	}
//	return resault;
//}


//回文素数  自己写的
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<cmath>
//#include<iterator>
//#include<vector>
//#include<algorithm>
//using namespace std;
//vector<int> v;
//bool isPrime(int x) {
//	if (x == 1) {
//		return false;
//	}
//	if (x == 2) {
//		return true;
//	}
//	else {
//		for (int i = 2; i*i <= x; i++) {
//			if (x%i == 0) {
//				return false;
//			}
//		}
//	}
//	return true;
//}
//int main() {
//	int n;
//	cin >> n;
//	if (n == 1) {
//		for (int i = 1; i <= 9; i++) {
//			if (isPrime(i)) {
//				v.push_back(i);
//			}
//		}
//	}
//	else {
//		if (n % 2 == 0) {
//			for (int i = pow(10, n / 2 - 1); i < pow(10, n / 2); i++) {
//				string temp = to_string(i);
//				reverse(temp.begin(), temp.end());
//				int pan = stoi(to_string(i) + temp);
//				if (isPrime(pan)) {
//					v.push_back(pan);
//				}
//			}
//		}
//		else {
//			for (int i = pow(10, n / 2 - 1); i < pow(10, n / 2); i++) {
//				string temp = to_string(i);
//				reverse(temp.begin(), temp.end());
//				for (char j = '0'; j <= '9'; j++) {
//					int pan = stoi(to_string(i) + j + temp);
//					if (isPrime(pan)) {
//						v.push_back(pan);
//					}
//				}
//
//			}
//		}
//
//	}
//	int cnt = v.size();
//	cout << cnt << endl;
//	for (auto itr = v.begin(); itr != v.end(); itr++) {
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}

//分数求和 网上答案
//#include<iostream>
//using namespace std;
//
//int main() {
//	int n;
//	cin >> n;
//	int sumn = 0, sumd = 1;//储存结果，sumn/sumd
//	while (n--) {
//		int num, deno;
//		char slash;//专门用来吃掉/的
//		cin >> num >> slash >> deno;
//		//先相加 a/b + c/d = (a*d+c*b)/(b*d)
//		sumn = sumn * deno + num * sumd;
//		sumd = sumd * deno;
//	}
//	//后约分
//	//先求最大公约数gcd，这里用的是欧几里得法
//	int a = sumd, b = sumn, c;
//	while (a != 0) {
//		c = a; a = b % a; b = c;
//	}
//	int gcd = b;
//	//分子分母同时除以gcd就可以完成约分
//	sumd /= gcd;
//	sumn /= gcd;
//	if (sumd > 1)
//		cout << sumn << '/' << sumd << endl;
//	else
//		cout << sumn << endl;
//	return 0;
//}

//分数求和 自己写的
//#include<iostream>
//using namespace std;
//int gcd(int x, int y) {
//	if (y == 0) {
//		//cout << x << endl;
//		return x;
//	}
//	else {
//		return gcd(y, x%y);
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	int sump = 0, sumq = 1;
//	int p, q;
//	char nonsense;
//	for (int cnt = 0; cnt < n; cnt++) {
//		cin >> p >> nonsense >> q;
//		sump = sump * q + sumq * p;
//		sumq = sumq * q;
//	}
//	int same = gcd(sump, sumq);
//	//cout << same << endl;
//	sump = sump / same;
//	sumq = sumq / same;
//	if (sumq == 1) {
//		cout << sump << endl;
//	}
//	else {
//		cout << sump << "/" << sumq << endl;
//	}
//	system("pause");
//	return 0;
//}


//求满足条件的3位数
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//#include<string>
//#include<vector>
//using namespace std;
//const int maxn = 34;
//int m[10];
//vector<int> v;
//int main() {
//	int n;
//	cin >> n;
//	long long sq;
//	for (int i = 10; i < maxn; i++) {
//		memset(m, 0, sizeof(m));//每次遍历都要刷新一下数组
//
//		sq = pow(i, 2);
//		string temp = to_string(sq);
//		int suc = 0;
//		//cout << temp << endl;
//		for (int j = 0; j < temp.size(); j++) {
//			m[temp[j] - '0'] += 1;
//
//			if (m[temp[j] - '0'] >= 2) {
//				suc = 1;
//				break;
//			}
//		}
//		for (int j = 0; j < 9; j++) {
//			//cout << sq << " " << j << " " << m[j] << endl;
//		}
//		if (suc) {
//			v.push_back(sq);
//		}
//	}
//	//for (int i = 0; i < v.size(); i++) {
//	//	cout << v[i] << " ";
//	//}
//	cout << v[n - 1] << endl;
//	system("pause");
//	return 0;
//}


//求序列中的众数  有问题 1分
//#include<iostream>
//#include<map>
//#include<string>
//#include<cstring>
//#include<iterator>
//#include<algorithm>
//#include<vector>
//using namespace std;
//map<string, int> mp;
//multimap<int, string, greater<int>> mm;
//vector<string> v;
//int main() {
//	int n;
//	cin >> n;
//	string nonsense;
//	getline(cin, nonsense);
//	string line;
//	for (int cnt = 0; cnt < n; cnt++) {
//		getline(cin, line);
//		string temp = "";
//		if (line[0] == '+' || line[0] == '-') {
//			temp = temp + line[0];
//			int flag = 0;
//			for (int i = 1; i < line.size(); i++) {
//				if (line[i] != '0') {
//					flag = 1;
//				}
//				if (flag) {
//					temp += line[i];
//				}
//			}
//			map<string, int>::iterator itr;
//			itr = mp.find(temp);
//			if (itr == mp.end()) {
//				mp.insert(pair<string, int>(temp, 1));
//			}
//			else {
//				mp[temp] = mp[temp] + 1;
//			}
//		}
//		else {
//			temp = temp + '+';
//			int flag = 0;
//			for (int i = 0; i < line.size(); i++) {
//				if (line[i] != '0') {
//					flag = 1;
//				}
//				if (flag) {
//					temp += line[i];
//				}
//				//cout << temp << endl;
//			}
//			map<string, int>::iterator itr;
//			itr = mp.find(temp);
//			if (itr == mp.end()) {
//				mp.insert(pair<string, int>(temp, 1));
//			}
//			else {
//				mp[temp] = mp[temp] + 1;
//			}
//		}
//		v.push_back(temp);
//		//cout << temp << endl;
//	}
//	int mx = 0;
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		mx = max(mx, itr->second);
//		//cout << itr->first << " " << itr->second << endl;
//	}
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		if (itr->second == mx) {
//			cout << itr->first;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}


//求序列中的众数  网上答案
//#include<iostream>
//#include<cstring>
//#include<cmath>
//#include<algorithm>
//#include<string>
//using namespace std;
//char w[10000];
//struct data {
//	int sum;
//	char c[10000];
//}p[130];
//
//void fun(int k, int f) {//化简有效数字 
//	if (w[0] == '+' || w[0] == '-')k++;
//	if (w[0] == '-')f = 0;
//	while (w[k] == '0')k++;
//
//	char t[1000];
//	int j = 0;
//	if (!f) {
//		t[0] = '-';
//		j++;
//	}
//	for (int i = k; w[i] != '\0'; i++) {
//		t[j] = w[i];
//		j++;
//	}
//	t[j] = '\0';
//
//	if (strcmp(t, "-") == 0)strcpy_s(t, "0");
//	else if (strcmp(t, "") == 0)strcpy_s(t, "0");
//	strcpy_s(w, t);
//}
//
//int main() {
//	int n, num = 0, maxsum = 1;
//	char c[1000];
//	cin>>n;
//
//	int len = 0;//记录有多少个不重复的数字
//	while (n != num) {
//		memset(w, 0, sizeof(w));
//		int f = 1;
//		cin>>w;
//		if (strcmp(w, "") == 0)continue;
//
//		int k = 0, j;
//		fun(k, f);
//		//cout << w << endl;
//		//cout << "len " << len << endl;
//		for (j = 0; j < len; j++) {
//			if (strcmp(p[j].c, w) == 0) {
//				p[j].sum++;
//				break;
//			}
//		}
//		if (j >= len) {
//			strcpy_s(p[len].c, w);
//			p[len].sum = 1;
//			len++;
//		}
//
//		num++;
//	}
//	if (len == 1 && n > len)printf("no\n");
//	else {
//		int k = 0;
//		for (int i = 0; i < len; i++) {
//			//			printf("-- %d\n",p[i].sum);
//			if (p[i].sum > p[k].sum)k = i;
//		}
//		printf("%s\n", p[k].c);
//	}
//	system("pause");
//	return 0;
//}


//求序列中的众数  自己写
//#include<iostream>
//#include<string>
//using namespace std;
//struct Data
//{
//	int cnt;
//	string data;
//};
//Data d[130];
//int main() {
//	int n;
//	cin >> n;
//	int tot = 0;
//	string str;
//	for (int k = 0; k < n; k++) {
//		cin >> str;
//		string temp = "";
//		if (str[0] == '-') {
//			temp += str[0];
//			int flag = 0;
//			for (int i = 1; i < str.length(); i++) {
//				if (str[i] != '0') {
//					flag = 1;
//				}
//				if (flag) {
//					temp += str[i];
//				}
//			}
//		}
//		else {
//			if (str[0] == '+') {
//				int flag = 0;
//				for (int i = 1; i < str.length(); i++) {
//					if (str[i] != '0') {
//						flag = 1;
//					}
//					if (flag) {
//						temp += str[i];
//					}
//				}
//			}
//			else {
//				int flag = 0;
//				for (int i = 0; i < str.length(); i++) {
//					if (str[i] != '0') {
//						flag = 1;
//					}
//					if (flag) {
//						temp += str[i];
//					}
//				}
//			}
//		}
//		//cout << temp << endl;
//		if (temp == "" ||temp == "-") {//特判为0的情况
//			temp = '0';
//		}
//		int has = 0;
//		for (int i = 0; i < tot; i++) {
//			if (temp== d[i].data) {
//				d[i].cnt += 1;
//				 has = 1;
//				break;
//			}
//		}
//		if (has == 0) {
//			d[tot].data = temp;
//			d[tot].cnt = 1;
//			tot++;
//			//cout<<temp<<" " << tot << endl;
//
//		}
//	}
//	if (tot == 1) {
//		cout << "no" << endl;
//		system("pause");
//		return 0;
//	}
//	int mx_index = 0;
//	for (int i = 0; i < tot; i++) {
//		if (d[i].cnt > d[mx_index].cnt) {
//			mx_index = i;
//		}
//	}
//	cout << d[mx_index].data << endl;
//	//cout << tot << endl;
//	system("pause");
//	return 0;
//}

//最长单词2
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<cstring>
//using namespace std;
//struct Data
//{
//	string data;
//	int len_d;
//};
//Data d[510];
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string token;
//	int cnt = 0;
//	while (ss >> token) {
//		int len = token.length();
//		if (token[len - 1] != '.') {
//			d[cnt].data = token;
//			d[cnt].len_d = len;
//		}
//		else{
//			len = len - 1;
//			for (int i = 0; i < len; i++) {
//				d[cnt].data += token[i];
//			}
//			d[cnt].len_d = len;
//		}
//		//cout << cnt << " " << d[cnt].data << " " << d[cnt].len_d << endl;
//		cnt++;
//	}
//	int mx_index = 0;
//	for (int i = 0; i < cnt; i++) {
//		if (d[mx_index].len_d < d[i].len_d) {
//			mx_index = i;
//			//break;
//		}
//	}
//	cout << d[mx_index].data << endl;
//	system("pause");
//	return 0;
//}

//文字排版 网上答案
//#include <iostream>
//#include <string.h>
//#include <cstdio>
//using namespace std;
//int main() {
//	int n, len = 0, maxlen = 80;//n为单词数， len记录当前读入的字符数， maxlen为每行允许输出的最大长度
//	cin >> n;
//	getchar();//跳过换行符
//	while (n > 0) {//读入n个单词
//		char s[40] = "";
//		for (int i = 0; i < 40; i++) {//读入一个单词
//			s[i] = getchar();
//			if (s[i] == ' ' || s[i] == '\n') {
//				n--; //单词数减一
//				break;
//			}
//		}
//		len += strlen(s);
//		if (len - 1 > maxlen) {//除掉最后一个空格达到80个字符就换行
//			len = strlen(s);//作为下一行的初始长度
//			cout << endl; 
//		}
//		cout << s;
//	}
//	system("pause");
//	return 0;
//}

//文字排版 自己写的
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<sstream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	string nonsense;
//	getline(cin, nonsense);
//	int tot = 0;
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		temp = temp + ' ';
//		if (temp.size() - 1 + tot > 80) {
//			tot = temp.size();
//			cout << endl;
//			cout << temp;
//		}
//		else {
//			tot += temp.size();
//			cout << temp;
//		}
//	}
//	system("pause");
//	return 0;
//}


//Tomorrow never knows？  所有条件之间的判断都是if else
//#include<iostream>
//#include<stdio.h>
//#include<string>
//using namespace std;
//int main() {
//	int y, m, d;
//	char c;
//	cin >> y >> c >> m >> c >> d;
//	//cout << y << " " << m << " " << d << endl;
//	if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {
//		if (d <= 30) {
//			d = d + 1;
//		}
//		else if (d == 31 && m != 12) {
//			d = 1;
//			m = m + 1;
//		}
//		else if (d == 31 && m == 12) {
//			d = 1;
//			m = 1;
//			y = y + 1;
//		}
//	}
//	else if (m == 4 || m == 6 || m == 9 || m == 11) {
//		if (d <= 29) {
//			d = d + 1;
//		}
//		else if (d == 30) {
//			d = 1;
//			m = m + 1;
//		}
//	}
//	else if (m == 2) {
//		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
//			if (d <= 28) {
//				d = d + 1;
//			}
//			else if (d == 29) {
//				d = 1;
//				m = m + 1;
//			}
//			//	cout << "hhh" << endl;
//		}
//		else {
//			if (d <= 27) {
//				d = d + 1;
//			}
//			else if (d == 28) {
//				d = 1;
//				m = m + 1;
//			}
//		}
//
//	}
//	printf("%d-%02d-%02d\n", y, m, d);//记住
//	system("pause");
//	return 0;
//}


//啤酒厂选址 网上答案
//#include<iostream>
//#include<cstdio>
//#include<algorithm>
//using namespace std;
//const int MAXN = 10000 + 1;
//int n, sum, pos, minn = 0x7fffffff;
//int a[MAXN], len[MAXN];
//
//inline int abs(int x) {
//	return x < 0 ? -x : x;
//}
//
//int main() {
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> a[i] >> len[i];
//		sum += len[i];
//		len[i] += len[i - 1];
//		cout << i << " " << len[i] << endl;
//	}
//	for (int i = 1; i <= n; i++) {
//		int tmp = 0;
//		for (int j = 1; j <= n; j++) {
//			//len[j]存的是j到j+1的长度 
//			//所以要从j-1开始算
//			//i、j大小关系不定，所以要加绝对值
//			cout << "hh " << j - 1 << " " << len[j - 1] << " " << i - 1 << " " << len[i - 1] << endl;
//			tmp += min(abs(len[j - 1] - len[i - 1]),
//				sum - abs(len[j - 1] - len[i - 1]))*a[j];
//		}
//
//		if (minn > tmp) {
//			minn = tmp;
//			pos = i - 1;
//		}
//	}
//	printf("%d,%d", pos, minn);
//	system("pause");
//	return 0;
//}

//啤酒厂选址
//#include<iostream>
//#include<algorithm>
//#include<climits>
//#include<cstring>
//using namespace std;
//const int maxn = 10010;
//int cost[maxn], need[maxn];
//int len[maxn];//len[i]	描述从第i个点到第0个点的距离
//int main() {
//	memset(cost, 0, sizeof(cost));
//	memset(need, 0, sizeof(need));
//	int n;
//	cin >> n;
//	int tot = 0;
//	for (int cnt = 0; cnt < n; cnt++) {
//		cin >> need[cnt] >> cost[cnt];
//		len[cnt + 1] = len[cnt] + cost[cnt];//cost[cnt]是第cnt个点到cnt+1个点的距离
//		tot = tot + cost[cnt];//整个环路的中长度
//	}
//	int minv = INT_MAX;
//	int pos = 0;
//	for (int i = 0; i < n; i++) {//遍历出发点
//		int c = 0;
//		for (int j = 0; j < n; j++) {//遍历到达点
//			int trace = min(abs(len[j] - len[i]), tot - abs(len[j] - len[i]));
//			c = c + trace * need[j];
//		}
//		//cout << i << " " << c << endl;
//		if (c < minv) {
//			minv = min(c, minv);
//			pos = i;
//		}
//	}
//	cout << pos << "," << minv << endl;
//	system("pause");
//	return 0;
//}

//话题焦点人物
//#include<iostream>
//#include<map>
//#include<set>
//#include<vector>
//#include<climits>
//using namespace std;
//map<int, multiset<int>>  mp;//int表示被at的人  multiset里面装at id为int的人的编号  一定是multiset
//int main() {
//	int n;
//	cin >> n;
//	int id, num, temp_id;
//	for (int cnt = 0; cnt < n; cnt++) {
//		cin >> id >> num;
//		for (int i = 0; i < num; i++) {
//			cin >> temp_id;
//			if (mp.count(temp_id) == 0) {
//				multiset<int> st;
//				st.insert(id);
//				mp.insert(pair<int, multiset<int>>(temp_id, st));
//			}
//			else {
//				mp[temp_id].insert(id);
//			}
//		}
//	}
//	int mx = INT_MIN;
//	int pos;
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		int cnt_set = (itr->second).size();//这一步必须要 不能放到判断条件里面 不然不行
//		//cout << cnt_set << " " << mx << endl;
//		if (cnt_set > mx) {
//			//cout << "HHH" << endl;
//			mx = itr->second.size();
//			pos = itr->first;
//			//cout << mx << " " << pos << endl;
//		}
//	}
//	cout << pos << endl;
//	set<int> st;
//	for (auto itr = mp[pos].begin(); itr != mp[pos].end(); itr++) {
//		st.insert(*itr);
//	}
//	for (auto itr = st.begin(); itr != st.end(); itr++) {
//		
//		cout << *itr << " ";
//	}
//	system("pause");
//	return 0;
//}


//最大质因子序列
//#include<iostream>
//using namespace std;
//bool isPrime(int x) {
//	if (x == 1 || x == 2) {
//		return true;
//	}
//	else {
//		for (int i = 2; i*i <= x; i++) {
//			if (x%i == 0) {
//				return false;
//			}
//		}
//	}
//	return true;
//}
//int main() {
//	int a, b;
//	cin >> a >> b;
//	int flag = 1;
//	for (int i = a; i <= b; i++) {
//		for (int j = i - 1; j >= 1; j--) {
//			if (i%j == 0 && isPrime(j)) {
//				int res = j;
//				if (j == 1) {
//					res = i;
//				}
//				if (flag) {
//					cout << res;
//					flag = 0;
//				}
//				else {
//					cout << "," << res;
//				}
//				break;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//因子分解 网上答案
//#include <iostream>
//using namespace std;
//int su[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97 };//25个
//int main()
//{
//	int n;
//	cin >> n;
//	int m = n;
//	int count = 0;
//	for (int i = 0; i<25; i++) {
//		count = 0;
//		while (m%su[i] == 0 && m != 1) {
//			m = m / su[i];
//			count++;
//		}
//		if (count == 1) {
//			cout << su[i];
//			if (m != 1)
//				cout << '*';
//			else break;
//		}
//		else {
//			if (count != 0) {
//				cout << su[i] << '^' << count;
//				if (m != 1)
//					cout << '*';
//				else break;
//			}
//		}
//	}
//	return 0;
//}

//因子分解
//#include<iostream>
//#include<vector>
//using namespace std;
//int m[100];
//int getPrime() {
//	m[0] = 2;
//	int pos = 1;
//	for (int i = 3; i < 100; i = i + 2) {
//		int flag = 1;
//		for (int j = 2; j*j <= i; j++) {
//			if (i%j == 0) {
//				flag = 0;
//				break;
//			}
//		}
//		if (flag) {
//			m[pos] = i;
//			pos++;
//		}
//	}
//	return pos;//这里不用减1  因为没有算0
//}
//int main() {
//	int x;
//	cin >> x;
//	int n = getPrime();
//	//cout << n;
//	for (int i = 0; i < n; i++) {
//		int cnt = 0;
//		while (x%m[i] == 0 && x != 1) {
//			x = x / m[i];
//			cnt++;
//		}
//		//cout << endl << x << " " << m[i] << " " << cnt << endl;
//
//		if (cnt > 1) {
//			cout << m[i] << "^" << cnt;
//			if (x != 1) {
//				cout << "*";
//			}
//		}
//		if (cnt == 1) {
//			cout << m[i];
//			if (x != 1) {
//				cout << "*";
//			}
//		}
//		if (x == 1) {
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}


//区间内的真素数
//#include<iostream>
//#include<vector>
//#include<string>
//#include<cstring>
//#include<set>
//#include<algorithm>
//using namespace std;
//const int maxn = 100010;
//set<int> s;
//void getPrime() {
//	s.insert(2);
//	int pos = 1;
//	for (int i = 3; i < maxn; i = i + 2) {
//		int flag = 1;
//		for (int j = 2; j*j <= i; j++) {
//			if (i%j == 0) {
//				flag = 0;
//				break;
//			}
//		}
//		if (flag) {
//			s.insert(i);
//		}
//	}
//}
//int main() {
//	int a, b;
//	cin >> a >> b;
//	getPrime();
//	int flag = 1;
//	int suc = 0;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		if (*itr >= a && *itr <= b) {
//			string temp = to_string(*itr);
//			reverse(temp.begin(), temp.end());
//			int rev = stoi(temp);
//			if (s.find(rev) != s.end()) {
//				suc = 1;
//				if (flag) {
//					cout << *itr;
//					flag = 0;
//				}
//				else {
//					cout << "," << *itr;
//				}
//			}
//		}
//
//	}
//	if (!suc) {//对没有的情况下进行特殊处理
//		cout << "No";
//	}
//	system("pause");
//	return 0;
//}

//打印月历 网上答案1
//#include <string.h>
//#include <math.h>
//#include <stdlib.h>
//#include <iostream>
//using namespace std;
//char head[] = "Sun Mon Tue Wed Thu Fri Sat";
//int dayOfMon[13] = { -1,31,28,31,30,31,30,31,31,30,31,30,31 };
//int getWeekDay(int y, int m, int d) {
//	if (m <= 2) {
//		m += 12;
//		y--;
//	}
//	return (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400 + 1) % 7;
//}
//int main() {
//	int y, m, d = 1;
//	cin>>y>>m;
//	if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0)) {
//		dayOfMon[2] = 29;
//	}
//	int W = getWeekDay(y, m, d);
//	cout << W << endl;
//	int satDay = d + 6 - W;
//	printf("%s\n", head);
//	for (int i = 0; i < W; i++) {
//		printf("    ");
//	}
//	int day = 1;
//	while (day <= dayOfMon[m]) {
//		printf("%3d ", day);
//		if ((satDay - day) % 7 == 0) {
//			printf("\n");
//		}
//		day++;
//	}
//	system("pause");
//	return 0;
//}


//打印月历 网上答案2
//#include <iostream>
//using namespace std;
//int month[13][2] = {
//	{ 0, 0 },{ 31, 31 },{ 28, 29 },{ 31, 31 },{ 30, 30 },{ 31, 31 },{ 30, 30 },{ 31, 31 },{ 31, 31 },{ 30, 30 },{ 31, 31 },{ 30, 30 },{ 31, 31 } };
//bool isLeap(int year)
//{
//	return (year % 100 != 0 && year % 4 == 0) || (year % 400 == 0);
//}
//
//string WeekName[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
//
//int main()
//{
//	int y1, m1, d1;
//	cin >> y1 >> m1;
//	d1 = 1;
//	int y2 = 1900;
//	int m2 = 1;
//	int d2 = 1;
//	int ans = 0;
//	while (y2 < y1 || m2 < m1 || d2 < d1)
//	{
//		d2++;
//		if (d2 == month[m2][isLeap(y2)] + 1)
//		{
//			m2++;
//			d2 = 1;
//		}
//		if (m2 == 13)
//		{
//			y2++;
//			m2 = 1;
//		}
//		ans++;
//	}
//	int result = (ans % 7 + 1) % 7;
//	int t = 0;
//	cout << "Sun Mon Tue Wed Thu Fri Sat" << endl;
//	for (int i = 0; i < result; i++)
//	{
//		cout << "    ";
//		t++;
//	}
//	for (int i = 1; i <= month[m2][isLeap(y2)]; i++)
//	{
//		if (i < 10)
//		{
//			cout << "  " << i << " ";
//			t++;
//		}
//		else
//		{
//			cout << " " << i << " ";
//			t++;
//		}
//		if (t % 7 == 0)
//		{
//			cout << endl;
//		}
//	}
//	return 0;
//}


//打印月历 自己写
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//int mday[13][2] = {
//	0,0,
//	31,31,
//	28,29,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31
//};
//int isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || x % 400 == 0) {
//		return 1;
//	}
//	return 0;
//}
//int main() {
//	int y1, m1, d1, y2, m2, d2;
//	cin >> y1 >> m1;
//	y2 = 1900;
//	m2 = 1;
//	d2 = 1;
//	d1 = 1;
//	int cnt = 0;
//	while (y2 < y1 || m2 < m1 || d2 < d1) {
//		d2++;
//		if (d2 == mday[m2][isRun(y2)] + 1) {
//			m2++;
//			d2 = 1;
//		}
//		if (m2 == 13) {
//			y2++;
//			m2 = 1;
//		}
//		cnt++;
//	}
//	//cout << cnt << endl;
//	int start = (cnt % 7 + 1) % 7;//范围是0-6  加1是因为开始是周一
//	cout << "Sun Mon Tue Wed Thu Fri Sat" << endl;
//	int tot = start;//用来判断是否是7的倍数 控制换行
//	for (int i = 0; i < start; i++) {
//		cout << "    ";
//
//	}
//	for (int i = 1; i <= mday[m1][isRun(y1)]; i++) {
//		printf("%3d ", i);
//		tot++;
//		if (tot % 7 == 0) {
//			cout << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//计算两个日期之间的天数
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//int mday[13][2] = {
//	0,0,
//	31,31,
//	28,29,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31
//};
//int isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || x % 400 == 0) {
//		return 1;
//	}
//	return 0;
//}
//int main() {
//	int y1, m1, d1, y2, m2, d2;//2是开始 1是结束
//	cin >> y2 >> m2>>d2>>y1>>m1>>d1;
//	int cnt = 0;
//	while (y2 < y1 || m2 < m1 || d2 < d1) {
//		d2++;
//		if (d2 == mday[m2][isRun(y2)] + 1) {
//			m2++;
//			d2 = 1;
//		}
//		if (m2 == 13) {
//			y2++;
//			m2 = 1;
//		}
//		cnt++;
//	}
//	cout << cnt << endl;
//	
//	system("pause");
//	return 0;
//}


//n-gram串频统计
//#include<iostream>
//#include<string>
//#include<cstring>	
//#include<climits>
//#include<vector>
//using namespace std;
//struct Word
//{
//	string data;
//	int cnt;
//};
//Word wd[550];
//int main() {
//	int n;
//	cin >> n;
//	string str;
//	cin >> str;
//	int len = str.length();
//	int tot = 0;
//	for (int i = 0; i <= len - n; i++) {
//		string temp = "";
//		for (int j = i; j < i + n; j++) {
//			temp += str[j];
//		}
//		int flag = 0;
//		for (int j = 0; j < tot; j++) {
//			if (wd[j].data == temp) {
//				flag = 1;
//				wd[j].cnt++;
//				break;
//			}
//		}
//		if (!flag) {
//			wd[tot].data = temp;
//			wd[tot].cnt = 1;
//			tot++;
//		}
//	}
//	int pos = -1;
//	int mx = INT_MIN;
//	for (int i = 0; i < tot; i++) {
//		if (wd[i].cnt > mx) {
//			mx = wd[i].cnt;
//			pos = i;
//		}
//	}
//	if (mx <= 1) {
//		cout << "NO";
//		system("pause");
//		return 0;
//	}
//	vector<string> v;
//	for (int i = 0; i < tot; i++) {
//		if (wd[i].cnt == mx) {
//			v.push_back(wd[i].data);
//		}
//	}
//	cout << mx << endl;
//	for (int i = 0; i < v.size(); i++) {
//		cout << v[i] << endl;
//	}
//	system("pause");
//	return 0;
//}

//除以13 网上答案1  不好
//#include <stdio.h>
//#include <iostream>
//#include <string>
//using namespace std;
//int main() {
//	int a[105];
//	string s;
//	cin >> s;
//	int tmp[105];
//	int y = 0;
//	for (int i = 0; i<s.size(); i++) {
//		a[i] = s[i] - '0';
//	}
//	bool flag = false;
//	for (int i = 0; i<s.size(); i++) {
//		int t = y * 10 + a[i];
//		//cout << endl<<"hhh " << i << " " << t << endl;
//		while (t<13 && i + 1<s.size()) {//不够13的时候商0，并加上下一位
//			i++;
//			t = t * 10 + a[i];
//			if (flag)cout << 0;
//		}
//		y = t % 13;
//		//cout << "y " << y << endl;
//		tmp[i] = t / 13;
//		cout << t / 13;
//		flag = true;
//	}
//	cout << endl;
//	cout << y << endl;//得到余数
//	system("pause");
//	return 0;
//}

//除以13 网上答案2  只有8分
//#include <iostream>
//#include<cstdio>
//#include<cstring>
//#include<string>
//using namespace std;
//
//int main()
//{
//	int t, len, shang[300], yu = 0, b[150] = { 0 };    //yu表示余数，shang[300]表示商
//	string a;
//	cin >> a;
//	len = a.length();
//	for (int i = 0; i < len; i++)//从开头到尾 和乘法不一样
//	{
//		b[i] = a[i] - 48;
//		b[i] = b[i] + yu * 10;
//		yu = b[i] % 13;        //得到余数
//		shang[i] = b[i] / 13;  //得到商
//		//cout << i << " " << yu << " " << shang[i] << endl;
//	}
//	for (int j = 0; j < len; j++)   //用于删除前导0
//	{
//		if (shang[j] != 0)
//		{
//			t = j;
//			break;
//		}
//	}
//	for (t; t < len; t++)    //此时t=j
//	{
//		cout << shang[t];
//	}
//	cout << endl;
//	cout << yu << endl;
//	system("pause");
//	return 0;
//}


//除以13
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int shang[maxn];
//int yu = 0;
//int main() {
//	string str;
//	cin >> str;
//	
//	int len = str.length();
//	for (int i = 0; i < len; i++) {
//		m[i] = str[i] - '0';
//	}
//	int temp = 0;
//	int cnt = 0;
//	for (int i = 0; i < len; i++) {
//		temp = yu * 10 + m[i];
//		yu = temp % 13;
//		shang[i] = temp / 13;
//		//cout << i << " " << shang[i] << endl;
//		cnt++;
//	}
//	//cout << cnt << " " << str[1] << endl;
//	/*if (cnt == 1 || (cnt == 2 && (str[1] == '0' || str[1] == '1' || str[1] == '2'))) {
//		cout << 0;
//	}*/
//	
//		int k;
//		for (k = 0; k < cnt; k++) {
//			if (shang[k] != 0) {
//				break;
//			}
//		}
//		if (k == cnt) {//特判商为0  还有可能存在前导0
//			cout << 0;
//			
//		}
//		else {
//			for (; k < cnt; k++) {
//				cout << shang[k];
//			}
//		}
//		
//	
//	cout << endl << yu << endl;
//	system("pause");
//	return 0;
//}

//出现次数超过一半的数
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<map>
//using namespace std;
//map<string, int> mp;
//int main() {
//	int n;
//	cin >> n;
//	for (int cnt = 0; cnt < n; cnt++) {
//		string str;
//		cin >> str;
//		if (mp.find(str) == mp.end()) {
//			mp.insert(pair<string, int>(str, 1));
//		}
//		else {
//			mp[str] += 1;
//		}
//	}
//	int suc = 0;
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		if (itr->second > n / 2) {
//			cout << itr->first;
//			suc = 1;
//		}
//	}
//	if (!suc) {
//		cout << "no";
//	}
//	system("pause");
//	return 0;
//}

//统计字符数
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<map>
//#include<climits>
//#include<set>
//using namespace std;
//map<char, int> mp;
//int main() {
//	string str;
//	cin >> str;
//	for (int i = 0; i < str.length(); i++) {
//		char c = str[i];
//		if (mp.find(c) == mp.end()) {
//			mp.insert(pair<char, int>(c, 1));
//		}
//		else {
//			mp[c] += 1;
//		}
//	}
//
//	int mx = INT_MIN;
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		if (itr->second > mx) {
//			mx = itr->second;
//		}
//		//cout << itr->first << " " << itr->second << endl;
//	}
//	//cout << mx << endl;
//	set<char> s;
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		if (itr->second == mx) {
//			//cout << itr->first << " " << itr->second << endl;
//
//			s.insert(itr->first);
//		}
//	}
//	cout << *s.begin() << " " << mx << endl;
//	system("pause");
//	return 0;
//}


//1的个数
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 1000000;
//int m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//	int i = 0;
//	while (n != 0) {
//		m[i] = n % 2;
//		n = n / 2;
//		i++;
//	}
//	int cnt = 0;
//	for (int j = 0; j <= i; j++) {
//		if (m[j] == 1) {
//			cnt++;
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//字符串中最长的连续出现的字符
//#include<iostream>
//#include<string>
//using namespace std;
//struct Data
//{
//	char ch;
//	int num;
//};
//Data d[26];
//int main() {
//	string str;
//	cin >> str;
//	int mx = 0;
//	char res;
//	int tot = 0;
//	for (int i = 0; i < str.length(); i++) {
//		char temp = str[i];
//		int cnt =1;
//		while (temp == str[i + 1]) {
//			i++;
//			cnt++;
//		}
//		if (cnt > mx) {
//			mx = cnt;
//			d[tot].num = cnt;
//			d[tot].ch = temp;
//			tot++;
//		}
//	}
//	for (int i = 0; i < tot;i++) {
//		if (d[i].num == mx) {
//			cout << d[i].ch << " " << mx << endl;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}


//日历问题
//#include<iostream>
//#include<string>
//#include<stdio.h>
//using namespace std;
//int monthday[13][2] = {
//	0,0,
//	31,31,
//	28,29,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31
//};
//string xingqiji[7] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday","Saturday" };
//int isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || x % 400 == 0) {
//		return 1;
//	}
//	return 0;
//}
//int main() {
//	int n;
//	cin >> n;
//	int y = 2000;
//	int m = 1;
//	int d = 1;
//	d = d + n;
//	while (m > 12 || d > monthday[m][isRun(y)]) {
//		d = d - monthday[m][isRun(y)];
//		m = m + 1;
//
//		if (m > 12) {
//			y++;
//			m = 1;
//		}
//		//cout << y << " " << m << " " << d << endl;
//	}
//
//	int index = (n % 7 + 6) % 7;
//	printf("%d-%02d-%02d ", y, m, d);
//	cout << xingqiji[index] << endl;
//
//	system("pause");
//	return 0;
//}


//实数加法  自己写只有9分  未处理结果末尾多余的0  现在是10分了
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int restot[maxn];
//int respart[maxn];
//int main() {
//	memset(restot, 0, sizeof(restot));
//	memset(respart, 0, sizeof(respart));
//
//	string a, b, c, d;
//	string str1, str2;
//	getline(cin, a, '.');
//	cin >> b;
//	string nonsense;//读取换行符
//	getline(cin, nonsense);
//	getline(cin, c, '.');
//	cin >> d;
//	//cout << a << " " << b << " " << c << " " << d << endl;
//
//	int lena = a.length();
//	int lenb = b.length();
//	int lenc = c.length();
//	int lend = d.length();
//
//	int lentot = max(lena, lenc);
//	int lenpart = max(lenb, lend);
//
//	reverse(a.begin(), a.end());
//	reverse(c.begin(), c.end());
//
//	//cout << lentot << " " << lena << " " << lenc << endl;
//
//	if (lenb < lenpart) {
//		for (int i = 0; i < lenpart - lenb; i++) {
//			b += '0';
//		}
//	}
//	if (lend < lenpart) {
//		for (int i = 0; i < lenpart - lend; i++) {
//			d += '0';
//		}
//	}
//	reverse(b.begin(), b.end());
//	reverse(d.begin(), d.end());
//	//cout << b << " " << d << endl;
//	int i;
//	for (i = 0; i < lenpart; i++) {
//		respart[i] += b[i] + d[i] - 2 * '0';
//		respart[i + 1] = respart[i] / 10;
//		respart[i] = respart[i] % 10;
//
//	}
//
//	restot[0] = respart[i];//小数部分最高位进位要算到整数部分
//	i--;
//
//	if (lena < lentot) {
//		for (int i = 0; i < lentot - lena; i++) {
//			a += '0';
//		}
//	}
//	if (lenc < lentot) {
//		for (int i = 0; i < lentot - lenc; i++) {
//			c += '0';
//		}
//	}
//	//cout << a << " " << c << endl;
//
//	int j;
//	for (j = 0; j < lentot; j++) {
//		restot[j] += a[j] + c[j] - 2 * '0';
//		restot[j + 1] = restot[j] / 10;
//		restot[j] = restot[j] % 10;
//	}
//
//	int flag = 0;
//	int suc = 0;//用于判断是否全为0
//	for (int k = j; k >= 0; k--) {
//		if (restot[k] != 0) {
//			flag = 1;
//		}
//		if (flag) {
//			suc = 1;
//			cout << restot[k];
//		}
//	}
//	if (!suc) {
//		cout << 0;
//	}
//	cout << ".";
//
//	int w;//用于处理结尾多余的0；
//	for (w = 0; w < i; w++) {
//		if (respart[w] != 0) {
//			//cout << endl<<"w " << w << endl;
//			break;
//		}
//	}
//	//cout << "w " << w << endl;
//	for (int k = i; k >= w; k--) {
//
//		cout << respart[k];
//
//	}
//	system("pause");
//	return 0;
//}


//确定进制 网友答案
//#include<iostream>
//using namespace std;
//int judge(int x, int B)
//{
//	int value = 1, num = 0;
//	while (x != 0)//将一个数化为B进制数
//	{
//		if ((x % 10) >= B)//B进制下不可能出现大于等于B的数位
//			return -1;
//		num += ((x % 10)*value);//value是每位的权值
//		value *= B;//通过每次乘以B，移动B进制的数位
//		x /= 10;//通过除10找出每一位
//	}
//	return num;
//}
//int main()
//{
//	int a, b, c;
//	int i;
//	cin >> a >> b >> c;
//	for (i = 2; i <= 16; i++)//枚举2-16进制
//		if (judge(a, i)*judge(b, i) == judge(c, i))//找到使a*b=c成立的最小进制B
//		{
//			cout << i << endl;
//			system("pause");
//			return 0;
//		}
//	cout << 0 << endl;
//	system("pause");
//	return 0;
//}


//确定进制 自己写的
//#include<iostream>
//using namespace std;
//int fun(int x, int B) {
//
//	int ans = 0;
//	int weight = 1;
//	while (x != 0) {
//		if (x % 10 >= B) {//每位数字不能大于B
//			return -1;
//		}
//		ans = ans + (x % 10) * weight;
//		x = x / 10;
//		weight = weight * B;
//	}
//	return ans;
//}
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//
//	for (int i = 2; i <= 16; i++) {
//		//cout << i << " " << fun(a, i) << " " << fun(b, i) << " " << fun(c, i) << endl;
//		if (fun(a, i)*fun(b, i) == fun(c, i)) {
//			cout << i;
//			system("pause");
//			return 0;
//		}
//
//	}
//	cout << 0;
//	system("pause");
//	return 0;
//}


//输出二进制补码  9分 不知道为啥
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//
//int main() {
//	long long x;
//	cin >> x;
//	if (x == 0) {
//		for (int i = 0; i < 32; i++) {
//			cout << 0;
//		}
//		system("pause");
//		return 0;
//	}
//	int flag = 1;//正数
//	if (x < 0) {
//		x = 0 - x;
//		flag = 0;
//	}
//	string str = "";
//	int cnt = 0;
//	while (x != 0) {
//		str += x % 2 + '0';
//		x = x / 2;
//		cnt++;
//	}
//	if (flag) {
//		for (int i = 0; i < 32 - cnt; i++) {
//			cout << 0;
//		}
//		for (int i = cnt - 1; i >= 0; i--) {
//			cout << str[i];
//		}
//	}
//	else {
//
//		cout << 1;
//		string res = "";
//		for (int i = 0; i < 32 - cnt - 1; i++) {
//			res += '0';
//		}
//		for (int i = cnt - 1; i >= 0; i--) {
//			res += str[i];
//		}
//		//cout << endl << "hhh " << res << endl;
//		for (int i = 0; i < 31; i++) {
//			if (res[i] == '0') {
//				res[i] = '1';
//			}
//			else {
//				res[i] = '0';
//			}
//		}
//		//cout << res << endl;
//		reverse(res.begin(), res.end());
//		//cout << res << endl;
//
//
//
//		for (int i = 0; i < 31; i++) {
//			if (res[i] == '0') {
//				res[i] = '1';
//				break;
//			}
//			else {
//				res[i] = '0';
//			}
//		}
//		//int ans[32];
//		//memset(ans, 0, sizeof(ans));
//		//ans[0] = res[0] - '0' + 1;
//		////cout << ans[0] << endl;
//		//for (int i = 0; i < 31; i++) {
//		//	if (i != 0) {
//		//		ans[i] += res[i] - '0';
//		//	}
//		//	ans[i + 1] = ans[i]/2;
//		//	ans[i] = ans[i] % 2;
//		//	//cout << i << " " << ans[i] << endl;
//		//}
//		for (int i = 30; i >= 0; i--) {
//			cout << res[i];
//		}
//	}
//	system("pause");
//	return 0;
//}


//输出二进制补码 网上答案
//#include<iostream>
//#include<stdio.h>
//#include<string.h>
//using namespace std;
//int ans[32];
//int two[32];
//int main() {
//	memset(ans, 0, sizeof(ans));
//	memset(two, 0, sizeof(two));
//	int a;
//	cin >> a;
//	if (a == 0) {
//		for (int i = 0; i < 32; i++) {
//			printf("%d", ans[i]);
//		}
//	}
//	else if (a > 0) {
//		int size = 0;
//		do {
//			two[size++] = a % 2;
//			a /= 2;
//		} while (a != 0);
//		for (int i = 0; i < size; i++) {
//			ans[31 - i] = two[i];
//		}
//		for (int i = 0; i < 32; i++) {
//			printf("%d", ans[i]);
//		}
//	}
//	else {
//		a = a * (-1);
//		int size = 0;
//		do {
//			two[size++] = a % 2;
//			a /= 2;
//		} while (a != 0);
//		for (int i = 0; i < size; i++) {
//			ans[31 - i] = two[i];
//		}
//		for (int i = 0; i < 32; i++) {
//			cout << ans[i];
//		}
//		cout << endl;
//		for (int i = 1; i < 32; i++) {
//			ans[i] = 1 - ans[i];
//		}
//		for (int i = 0; i < 32; i++) {
//			cout << ans[i];
//		}
//		cout << endl;
//		ans[0] = 1;
//		for (int i = 31; i > 0; i--) {
//			if (ans[i] == 1) {
//				ans[i] = 0;
//			}
//			else {
//				ans[i] = 1;
//				break;
//			}
//		}
//		for (int i = 0; i < 32; i++) {
//			printf("%d", ans[i]);
//		}
//
//
//	}
//	system("pause");
//	return  0;
//}

//输出二进制补码  网友答案2  简单的
//#include<iostream>
//#include<cstdio>
//using namespace std;
//int a[10001];
//int now;
//int main()
//{
//	int n;
//	cin >> n;
//	for (int i = 31; i >= 0; i--)
//	{
//		cout << ((n >> i) & 1);
//	}
//	system("pause");
//	return 0;
//}

//输出二进制补码  自己写
//#include<iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 31; i >= 0; i--) {
//		cout << ((n >> i) & 1);
//	}
//	system("pause");
//	return 0;
//}


//二进制分类
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<cstring>
//using namespace std;
//int main() {
//	int cnt_a = 0;
//	int cnt_b = 0;
//	for (int i = 1; i <= 1000; i++) {
//		int n = i;
//		int cnt_1 = 0;
//		int cnt_0 = 0;
//		while (n) {
//			if (n % 2 == 1) {
//				cnt_1++;
//			}
//			else {
//				cnt_0++;
//			}
//			n /= 2;
//		}
//		if (cnt_1 > cnt_0) {
//			cnt_a++;
//		}
//		else {
//			cnt_b++;
//		}
//	}
//	cout << cnt_a << " " << cnt_b << endl;
//	system("pause");
//	return 0;
//}

//乒乓球  每一局中，领先一方达到一定得分（11分制为11分，21分制为21分），且净胜对手至少2分，才能够获得胜利；
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int main() {
//	char c;
//	int cnt_11 = 0, cnt_21 = 0;
//	int a_11 = 0, b_11 = 0, a_21 = 0, b_21 = 0;
//	string str = "";
//	while (cin >> c) {
//		str += c;
//		if (c == 'E') {
//			cout << a_11 << ":" << b_11 << endl;
//
//			break;
//		}
//		if (c == 'W') {
//			a_11++;
//		}
//		else {
//			b_11++;
//		}
//		cnt_11++;
//		if ((a_11 >= 11&&a_11 - b_11 >=2) || (b_11 >= 11 && b_11 - a_11 >= 2)) {
//			cout << a_11 << ":" << b_11 << endl;
//			a_11 = 0;
//			b_11 = 0;
//		}
//	}
//	cout << endl;
//	for (int i = 0; i < str.length(); i++) {
//		if (str[i] == 'E') {
//			cout << a_21 << ":" << b_21 << endl;
//			break;
//		}
//		if (str[i] == 'W') {
//			a_21++;
//		}
//		else {
//			b_21++;
//		}
//		cnt_21++;
//		if ((a_21 >= 21&&a_21 - b_21>=2) || (b_21 >= 21 && b_21 - a_21 >= 2)) {
//			cout << a_21 << ":" << b_21 << endl;
//			a_21 = 0;
//			b_21 = 0;
//		}
//	}
//	system("pause");
//	return 0;
//}

//花生采摘
//#include<iostream>
//#include<queue>
//using namespace std;
//const int maxn = 25;
//int m[maxn][maxn];
//struct Point
//{
//	int row, col;
//	int cnt;
//	bool operator< (const Point &a)const {
//		return cnt < a.cnt;
//	}
//	Point() {};
//	Point(int _row, int _col, int _cnt) :row(_row), col(_col), cnt(_cnt) {};
//};
//priority_queue<Point> q;
//int main() {
//	int r, c, p;
//	cin >> r >> c >> p;
//	int num;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> num;
//			if (num > 0) {
//				q.push(Point(i, j, num));
//			}
//		}
//	}
//	Point first = q.top();
//	//q.pop();
//	if (first.row * 2 + 1 > p) {//判断能否跨出第一步  这里要+1  摘花生也要时间
//		cout << 0;
//		system("pause");
//		return 0;
//	}
//	int step = first.row + 1;
//	int tot = first.cnt;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		if (!q.empty()) {//这一步不能少呀  因为可能队列为空了！！！！！
//			Point next = q.top();
//			int ad = 1 + abs(now.row - next.row) + abs(now.col - next.col);
//			int back = next.row;
//			//cout << now.row << " " << now.col << " " << next.row << " " << next.col << " " << step << " " << ad << " " << back << " " << step + ad + back << " " << tot << endl;
//			if (step + ad + back <= p) {
//				step += ad;
//				tot += next.cnt;
//			}
//			else {
//				/*ad = now.row + 1;
//				step += ad;
//				tot += next.cnt;*/
//				break;
//			}
//		}
//		
//	}
//	cout << tot << endl;
//	system("pause");
//	return 0;
//}

//多项式输出
//#include<iostream>
//#include<string>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int t;
//	for (int i = 0; i <= n; i++) {
//		cin >> t;
//		if (i == 0) {
//			if (t == 1) {
//				
//			}
//			else if (t == -1) {
//				cout << "-";
//			}
//			else {
//				cout << t;
//			}
//			if (n - i == 1) {
//				cout << "x";
//			}
//			else if (n - i == 0) {
//
//			}
//			else {
//				cout << "x^" << n - i;
//			}
//		}
//		else if ( i == n) {
//			if (t >0) {
//				cout <<"+"<< t;
//			}
//			if (t < 0) {
//				cout << t;
//			}
//		}
//		
//		else {
//			if (t > 0) {
//				if (t != 1) {
//					cout << "+" << t;
//				}
//				else {
//					cout << "+";
//				}
//				
//				if (n - i == 1) {
//					cout << "x";
//				}
//				else if (n - i == 0) {
//
//				}
//				else {
//					cout << "x^" << n - i;
//				}
//			}
//			if (t < 0) {
//				if (t != -1) {
//					cout << "-"<<abs(t);
//				}
//				else {
//					cout << "-"; 
//				}
//				if (n - i == 1) {
//					cout << "x";
//				}
//				else if (n - i == 0) {
//
//				}
//				else {
//					cout << "x^" << n - i;
//				}
//			}
//		}
//
//		
//	}
//	system("pause");
//	return 0;
//}

//提取数字串按数值排序
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<sstream>
//#include<set>
//#include<algorithm>
//using namespace std;
//int main() {
//	multiset<long long> s;
//	string line;
//	getline(cin, line);
//	int len = line.size();
//	string str;
//	for (int i = 0; i < len; i++) {
//		if (isdigit(line[i])) {
//			str = "";
//			//str += line[i];
//			for (int j = i; j < len; j++) {
//				if (isdigit(line[j])) {
//					str += line[j];
//					//cout << str << endl;
//					i= j;//随时赋值  因为在最后一位的时候返回  i还是原来的值 没有变
//				}
//				else {
//					stringstream ss;
//					ss << str;
//					long long num;
//					ss >> num;
//					s.insert(num);
//					//cout << "hh " << num << endl;
//					i = j - 1;
//					str = "";
//					break;
//				}
//			}
//		}
//
//	}
//	if (!str.empty()) {
//		stringstream ss;
//		ss << str;
//		long long num;
//		ss >> num;
//		s.insert(num);
//	}
//	int flag = 1;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		if (flag) {
//			cout << *itr;
//			flag = 0;
//		}
//		else {
//			cout << "," << *itr;
//		}
//	}
//	if (s.empty()) {
//		cout << 0;
//	}
//	system("pause");
//	return 0;
//}

//判断元素是否存在
//#include<iostream>
//#include<set>
//#include<queue>
//using namespace std;
//const int maxn = 200000;
//int main() {
//	int x, y;
//	char c;
//	cin >> x >> c >> y;
//	set<int> res;
//	queue < int> q;
//	q.push(x);
//	res.insert(x);
//	while (!q.empty()) {
//		int now = q.front();
//		//cout << now << endl;
//		q.pop();
//		int n1 = 2 * now + 1;
//		int n2 = 3 * now + 1;
//		if (n1 <= maxn) {
//			res.insert(n1);
//			q.push(n1);
//		}
//		if (n2 <= maxn) {
//			res.insert(n2);
//			q.push(n2);
//		}
//		//cout << n1 << " " << n2 << endl;
//	}
//	if (res.count(y) != 0) {
//		cout << "YES";
//	}
//	else {
//		cout << "NO";
//	}
//	system("pause");
//	return 0;
//	
//}


//出书最多
//#include<iostream>
//#include<vector>
//#include<algorithm>
//#include<map>
//#include<climits>
//#include<string>
//using namespace std;
//const int maxn = 26;
//map<int, vector<int>> mp;
//int main() {
//	int n;
//	cin >> n;
//	int id;
//	string str;
//	for (int k = 0; k < n; k++) {
//		cin >> id >> str;
//		for (int i = 0; i < str.length(); i++) {
//			if (mp.find(str[i] - 'A') == mp.end()) {
//				vector<int> v;
//				v.push_back(id);
//				mp.insert(pair<int, vector<int>>(str[i] - 'A', v));
//			}
//			else {
//				mp[str[i] - 'A'].push_back(id);
//				//cout << str[i]-'A'<< " " << id << endl;
//			}
//		}
//	}
//	//cout << "hhh" << endl;
//	int mx = INT_MIN;
//	for (int i = 0; i < 26; i++) {
//		int len = mp[i].size();//这里不能放到if里面比
//		if (len > mx) {
//			mx = mp[i].size();
//		}
//	}
//	//cout << mx << endl;
//	for (int i = 0; i < 26; i++) {
//		if (mp[i].size() == mx) {
//			cout << char(i + 'A') << endl << mx<<endl;
//			for (int j = 0; j < mp[i].size(); j++) {
//				cout << mp[i][j] << endl;
//			}
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}


//相关月
//#include<iostream>
//using namespace std;
//const int mon_day[13][2] = {
//	0,0,
//	31,31,
//	28,29,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31
//};
//bool isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || x % 400 == 0) {
//		return true;
//	}
//	return false;
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		int y1, y2, m1, m2, d1, d2;
//		cin >> y1 >> m1 >> m2;
//		if (m1 < m2) {
//			y2 = y1;
//		}
//		else {
//			y2 = y1;
//			swap(m1, m2);
//		}
//		d1 = 1;
//		d2 = 1;
//		int cnt = 0;
//		while (y1 < y2 || d1 < d2 || m1 < m2) {
//			d1++;
//			if (d1 > mon_day[m1][isRun(y1)]) {
//				m1++;
//				d1 = 1;
//			}
//			if (m1 > 12) {
//				y1++;
//				m1 = 1;
//			}
//			cnt++;
//			//cout << y1 << " " << m1 << " " << d1 << " " << cnt << endl;
//		}
//		//cout << cnt << endl;
//
//		if (cnt % 7 == 0) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}


//正整数的任意进制转换 网上答案1  没看懂
//#include <iostream>
//#include <stdio.h>
//#include <algorithm>
//#include <string>
//#include <cmath>
//using namespace std;
//char x[10000];
//int y[10000], res[10000];
//int p, q, len, cnt, flag, n;
//int chu()//除法
//{
//	int yu1 = 0, yu2 = 0;
//	for (int i = 0; i<len; i++) {
//		yu1 = (y[i] + yu2 * p) % q;
//		y[i] = (y[i] + yu2 * p) / q;
//		yu2 = yu1;
//		cout << i << " " << y[i] << endl;
//	}
//	return yu1;
//}
//int main()
//{
//	cin >> n;;
//	while (n) {
//		n--;
//		memset(x, 0, sizeof(x));
//		memset(y, 0, sizeof(y));
//		memset(res, 0, sizeof(res));
//		char nonsense;
//		cin >> p >> nonsense;//p进制
//		for (int i = 0;; i++) {
//			cin>>x[i];
//			if (x[i] == ',')
//			{
//				x[i] = 0; break;
//			}
//			if (x[i] >= '0'&&x[i] <= '9')//转换成int存入y
//				y[i] = x[i] - '0';
//			else
//				y[i] = x[i] - 'A' + 10;
//			//cout << i << " " << y[i] << endl;
//		}
//		cin>>q;//q进制
//		len = strlen(x);
//		for (cnt = 0, flag = 1;; cnt++, flag = 1) {
//			res[cnt] = chu();
//			for (int i = 0; i<len; i++) {//y全为0终止
//				if (y[i] != 0)
//				{
//					flag = 0; break;
//				}
//			}
//			if (flag == 1)
//				break;
//		}
//		while (cnt >= 0) {//逆序输出
//			if (res[cnt] >= 0 && res[cnt] <= 9)
//				printf("%d", res[cnt]);
//			else
//				printf("%c", res[cnt] - 10 + 'A');
//			cnt--;
//		}
//		printf("\n");
//	}
//	system("pause");
//	return 0;
//}

//正整数的任意进制转换
//#include "stdlib.h"
//#include <iostream>
//#include<cstring>
//#include <stdio.h>
//using namespace std;
//int main()
//{
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++)
//	{
//		char num[800];//设置一个数组储存q进制数
//		int p, q;
//		cin >> p;
//		cin.ignore();
//		cin.getline(num, 800, ',');
//		cin >> q;
//		char res[800]; int count = 0;
//		while (1)
//		{
//			int x = 0; //归零
//			int len = 0;
//			for (int i = 0; i < strlen(num);)//对当前数字进行除q法
//			{
//				while (x < q&&i<strlen(num))//x小于q的时候，直接将它作为余数*p给下一个位数  当i达到最后时直接将其作为余数存进另一个数组
//				{
//					if (num[i] >= 'A'&&num[i] <= 'Z')
//						x = x * p + num[i] + 10 - 'A';
//					else x = x * p + num[i] - '0';
//					cout << i << " " << x << endl;;
//					num[i] = '0';
//					i++;
//				}
//				if (x >= q)//x比q大的时候，进行除法
//				{
//					if (x / q > 9) num[i - 1] = x / q + 'A' - 10;
//					else num[i - 1] = x / q + '0';
//					x %= q;
//					cout << "hhh " << x << endl;
//				}
//			}
//			if (x > 9)//余数进行转换以后存入数组res
//				res[count++] = x - 10 + 'A';
//			else
//				res[count++] = x + '0';
//			cout <<"res "<< count - 1 << " " << res[count - 1] << endl;
//			len = -1;
//			for (int i = 0; i<strlen(num) && num[i] == '0'; i++)
//			{
//				len = i;
//			}
//			if (strlen(num) - len < 2)
//				break;
//		}
//		for (int i = count - 1; i >= 0; i--)
//			cout << res[i];
//		cout << endl;
//	}
//}

//十进制到八进制
//#include<iostream>
//#include<string>
//using namespace std;
//const int maxn = 100000000;
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	int cnt = 0;
//	while (n) {
//		m[cnt] = n % 8;
//		n /= 8;
//		cnt++;
//	}
//	for (int i = cnt - 1; i >= 0; i--) {
//		cout << m[i];
//	}
//	system("pause");
//	return 0;
//}

//八进制到十进制
//#include<iostream>
//#include<string>
//using namespace std;
//const int maxn = 100000000;
//int m[maxn];
//int main() {
//	string str;
//	cin >>str;
//	int res = 0;
//	for (int i = 0; i < str.length(); i++) {
//		res = res * 8 + str[i] - '0';
//	}
//	cout << res << endl;
//	system("pause");
//	return 0;
//}



//计算对数  网上答案  double可以表示300多位
//#include<cstdio>
//#include<cmath>
//
//int main() {
//	double a, b;
//	scanf("%lf%lf", &a, &b);
//	printf("%d\n", int(log10(b) / log10(a)));
//	return 0;
//}

//数根
//#include<iostream>
//#include<string>
//#include<cstring>		
//#include<sstream>
//using namespace std;
//int main() {
//	string str;
//	cin >> str;
//	double fst = 0.0;
//	for (int i = 0; i < str.length(); i++) {
//		fst = fst + str[i] - '0';
//	}
//	while (fst >= 10) {
//		stringstream ss;
//		ss << fst;
//		string temp;
//		ss >> temp;
//		fst = 0;
//		for (int i = 0; i < temp.length(); i++) {
//			fst += temp[i] - '0';
//		}
//	}
//	cout << fst << endl;
//	system("pause");
//	return  0;
//}


//古代密码
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int m1[30];
//int m2[30];
//int main() {
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	string sec;
//	string orin;
//	cin >> sec >> orin;
//	if (sec.length() != orin.length()) {
//		cout << "NO" << endl;
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < sec.length(); i++) {
//		m1[sec[i] - 'A'] += 1;
//		m2[orin[i] - 'A'] += 1;
//	}
//	sort(m1, m1 + 26);
//	sort(m2, m2 + 26);
//	for (int i = 0; i < 25; i++) {
//		if (m1[i] != m2[i]) {
//			cout << "NO" << endl;
//			system("pause");
//			return 0;
//		}
//	}
//
//	//下面的代码不对 因为a不一定被替换成b  题目只是举了一个例子
//	//for (int i = 0; i < 26; i++) {
//	//	//cout << i << " " << m1[i] << " " << m2[i] << endl;
//	//	if (i == 0) {
//	//		if (m1[0] != m2[25]) {
//	//			cout << "NO" << endl;
//	//			system("pause");
//	//			return 0;
//	//		}
//	//	}
//	//	else {
//	//		if (m1[i] != m2[i - 1]) {
//	//			cout << "NO" << endl;
//	//			system("pause");
//	//			return 0;
//	//		}
//	//	}
//	//}
//	cout << "YES" << endl;
//	system("pause");
//	return 0;
//}

//2.1基本算法之枚举
//1661:Bomb Game
//#include <cstdio>
//#include <cstring>
//#include <algorithm>
//#include <iostream>
//using namespace std;
//const int N = 100 + 5;
//int r, c, k;
//int cnt[N][N];
//int inbound(int _r, int _c, int lr, int rr, int lc, int rc) {
//	if (_r < lr) {
//		return 0;
//	}
//	if (_r > rr) {
//		return 0;
//	}
//	if (_c < lc) {
//		return 0;
//	}
//	if (_c > rc) {
//		return 0;
//	}
//	return 1;
//}
//
//int main() {
//	while (cin >> r >> c >> k) {
//		memset(cnt, 0, sizeof(cnt));
//		int x, y, p, t;
//		for (int _ = 0; _ < k; _++) {
//			cin >> x >> y >> p >> t;
//			for (int i = 1; i <= r; i++) {
//				for (int j = 1; j <= c; j++) {
//					//如果在边界内
//					if (inbound(i, j, x - p / 2, x + p / 2, y - p / 2, y + p / 2)) {
//						//并且边界内有炸弹
//						if (t == 1) {
//							cnt[i][j]++;
//						}
//					}
//					else {
//						//如果边界外 且边界内没有炸弹 说明边界外有炸弹
//						if (t == 0) {
//							cnt[i][j]++;
//						}
//					}
//					//cout << _ << " " << i << " " << j << " " << cnt[i][j] << endl;
//				}
//			}
//		}
//		int ans = 0;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				if (cnt[i][j] == k) {
//					ans++;
//				}
//			}
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}


//完美立方
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	for (int a = 6; a <= n; a++) {
//		for (int b = 2; b <= n; b++) {
//			for (int c = b ; c <= n; c++) {
//				for (int d = c; d <= n; d++) {
//					if (a*a*a == b * b*b + c * c*c + d * d*d) {
//						cout << "Cube = " << a << ", Triple = (" << b << "," << c << "," << d << ")" << endl;
//					}
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//熄灯问题
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 10;
//int m[maxn][maxn];
//int ans[maxn][maxn];
//bool solve() {
//	for (int i = 2; i <= 6; i++) {
//		for (int j = 1; j <= 6; j++) {
//			ans[i][j] = m[i - 1][j] ^ ans[i - 1][j] ^ ans[i - 1][j - 1] ^ ans[i - 1][j + 1] ^ ans[i - 2][j];
//
//		}
//	}
//	for (int i = 1; i <= 6; i++) {
//		if (ans[6][i] == 1) {
//			return false;
//		}
//	}
//	return true;
//}
//int main() {
//	for (int i = 1; i <= 5; i++) {
//		for (int j = 1; j <= 6; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i < (1 << 6); i++) {
//		memset(ans, 0, sizeof(ans));
//		for (int j = 0; j <= 5; j++) {
//			ans[1][j+1] = 1 & (i >> j);
//			//cout << i << " " << j << " " << ans[1][j] << endl;
//		}
//		if (solve()) {
//			for (int i = 1; i <= 5; i++) {
//				for (int j = 1; j <= 6; j++) {
//					cout << ans[i][j] << " ";
//				}
//				cout << endl;
//			}
//			break;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//拨钟问题
//#include<iostream>
//#include<cstring>
//using namespace std;
//int m[10];
//int ans[10];
//int main() {
//	for (int i = 1; i < 10; i++) {
//		cin >> m[i];
//	}
//	memset(ans, 0, sizeof(ans));
//	for (ans[1] = 0; ans[1] < 4; ans[1]++) {
//		for (ans[2] = 0; ans[2] < 4; ans[2]++) {
//			for (ans[3] = 0; ans[3] < 4; ans[3]++) {
//				for (ans[4] = 0; ans[4] < 4; ans[4]++) {
//					for (ans[5] = 0; ans[5] < 4; ans[5]++) {
//						for (ans[6] = 0; ans[6] < 4; ans[6]++) {
//							for (ans[7] = 0; ans[7] < 4; ans[7]++) {
//								for (ans[8] = 0; ans[8] < 4; ans[8]++) {
//									for (ans[9] = 0; ans[9] < 4; ans[9]++) {
//
//										/*for (int i = 1; i <= 9; i++) {
//											cout << ans[i] << " ";
//
//										}
//										cout << endl;*/
//										if ((m[1] + ans[1] + ans[2] + ans[4]) % 4 != 0) {//a
//											continue;
//										}
//
//										if ((m[2] + ans[1] + ans[2] + ans[3] + ans[5]) % 4 != 0) {//b
//											continue;
//										}
//										if ((m[3] + ans[2] + ans[3] + ans[6]) % 4 != 0) {//c
//											continue;
//										}
//										if ((m[4] + ans[1] + ans[4] + ans[5] + ans[7]) % 4 != 0) {//d
//											continue;
//										}
//										if ((m[5] + ans[1] + ans[3] + ans[5] + ans[7] + ans[9]) % 4 != 0) {//e
//											continue;
//										}
//										if ((m[6] + ans[3] + ans[5] + ans[6] + ans[9]) % 4 != 0) {//f
//											continue;
//										}
//										if ((m[7] + ans[4] + ans[7] + ans[8]) % 4 != 0) {//g
//											continue;
//										}
//										if ((m[8] + ans[5] + ans[7] + ans[8] + ans[9]) % 4 != 0) {//h
//											continue;
//										}
//										if ((m[9] + ans[6] + ans[8] + ans[9]) % 4 != 0) {//i
//											continue;
//										}
//										for (int i = 1; i <= 9; i++) {
//											//cout <<  " " << ans[i] << endl;
//											if (ans[i] != 0) {
//												for (int j = 0; j < ans[i]; j++) {
//													cout << i << " ";
//												}
//											}
//										}
//										system("pause");
//										return 0;
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//满足条件的整数
//#include<iostream>
//using namespace std;
//int main() {
//	for (int a = 2; a <= 100; a++) {
//		for (int b = a; b <= 100; b++) {
//			for (int c = b; c <= 100; c++) {
//				if (a*a + b * b == c * c) {
//					cout << a << "*" << a << " + " << b << "*" << b << " = " << c << "*" << c << endl;
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//确定进制
//#include<iostream>
//#include<string>
//#include<sstream>
//using namespace std;
//int check(int x, int b) {
//	int ans = 0;
//	int B =1;
//	int backup = x;
//	while (backup) {
//		int tmp = backup % 10;
//		if (tmp >= b) {//这句不能少
//			return 100000000;
//		}
//		ans += tmp * B;
//		backup = backup / 10;
//		B = B * b;
//	}
//	//cout << x << " " << b << " " << ans << endl;
//	return ans;
//}
//int main() {
//	int p, q, r;
//	cin >> p >> q >> r;
//	int suc = 0;
//	for (int i = 2; i <= 16; i++) {
//		if (check(p, i)*check(q, i) == check(r, i)) {
//			cout << i << endl;
//			suc = 1;
//			break;
//		}
//	}
//	if (!suc) {
//		cout << 0 << endl;
//	}
//	system("pause");
//	return 0;
//}


//子串计算
//#include<iostream>
//#include<string>
//#include<map>
//using namespace std;
//
//int main() {
//	string str;
//	cin >> str;
//	map<string, int> mp;
//	for (int i = 1; i < str.length(); i++) {
//		for (int j = 0; j <= str.length() - i; j++) {
//			string sub = str.substr(j, i);
//			mp[sub]++;
//		}
//	}
//	for (auto itr = mp.begin(); itr != mp.end(); itr++) {
//		if (itr->second > 1) {
//			cout << itr->first << " " << itr->second << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//Safecracker
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<set>
//#include<algorithm>
//using namespace std;
//int m[20];
//int main() {
//	int tar;
//	string str;
//	while (cin >> tar >> str) {
//		if (tar == 0 && str == "END")break;
//		set<int> s;
//		for (int i = 0; i < str.length(); i++) {
//			s.insert(str[i] - 'A' + 1);
//		}
//		memset(m, 0, sizeof(m));
//		int index = 0;
//		for (auto itr = s.begin(); itr != s.end(); itr++) {
//
//			m[index] = *itr;
//			//cout << index << " " << m[index] << endl;
//			index++;
//		}
//		reverse(m, m + str.length());
//		/*for (int i = 0; i < str.length(); i++) {
//			cout << "r " << i << " " << m[i] << endl;
//		}*/
//		int suc = 0;
//		for (int v = 0; v < str.length(); v++) {
//			for (int w = 0; w < str.length(); w++) {
//				if (v == w)continue;
//				for (int x = 0; x < str.length(); x++) {
//					if (x == w)continue;
//					for (int y = 0; y < str.length(); y++) {
//						if (x == y)continue;
//						for (int z = 0; z < str.length(); z++) {
//							if (z == y)continue;
//							//cout << m[v] << " " << m[w] << " " << m[x] << " " << m[y] << " " << m[z] << endl;
//							if (m[v] - m[w] * m[w] + m[x] * m[x] * m[x] - m[y] * m[y] * m[y] * m[y] + m[z] * m[z] * m[z] * m[z] * m[z] == tar) {
//								cout << char(m[v] + 'A' - 1) << char(m[w] + 'A' - 1) << char(m[x] + 'A' - 1) << char(m[y] + 'A' - 1) << char(m[z] + 'A' - 1) << endl;
//								suc = 1;
//								goto END;
//							}
//						}
//					}
//				}
//			}
//
//		}
//	END:
//
//		if (!suc) {
//			cout << "no solution" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//和数   加数相同不累加，和数相同累加
//例如
//1 1 2 1 1  ans:1
//1 1 2 2 1 1   ans:2
//#include<iostream>	
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	sort(m, m + n);
//	int cnt = 0;
//	for (int i = n - 1; i >= 0; i--) {//遍历和数
//
//		for (int j = 0; j < i; j++) {
//			for (int k = 0; k < j; k++) {
//				if (m[i] == m[j] + m[k]) {
//					//cout << i << " " << j << " " << k << " " << m[i] << " " << m[j] << " " << m[k] << endl;
//					cnt++;
//					goto
//						END;
//				}
//			}
//		}
//	END:
//		continue;
//	}
//	cout << cnt << endl;
//	system("pause");
//	return 0;
//}

//谁是你的潜在朋友
//#include<iostream>
//#include<cstring>	
//#include<algorithm>
//#include<map>	
//using namespace std;
//int mp[210];
//int main() {
//	int n, m;
//	cin >> n >> m;
//	int id;
//	for (int i = 1; i <= n; i++) {
//		cin >> id;
//		mp[i] = id;
//	}
//	for (int i = 1; i <= n; i++) {
//		int cnt = 0;
//		for (int j = 1; j <= n; j++) {
//			if (i == j)continue;
//			if (mp[i] == mp[j]) {
//				cnt++;
//			}
//		}
//		if (cnt == 0) {
//			cout << "BeiJu" << endl;
//		}
//		else {
//			cout << cnt << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}


//最简真分数
//#include<iostream>
//using namespace std;
//const int maxn = 610;
//int m[maxn];
//int gcd(int a, int b) {
//	if (a == 0)return b;
//	return gcd(b%a, a);
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	int cnt = 0;
//	for (int i = 0; i < n; i++) {
//		for (int j = i + 1; j < n; j++) {
//			if (gcd(m[i], m[j]) == 1) {
//				cnt++;
//			}
//		}
//	}
//	cout << cnt << endl;
//	system("pause");
//	return 0;
//}

//找和为K的两个元素
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int main() {
//	int n, k;
//	cin >> n >> k;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	int suc = 0;
//	for (int i = 0; i < n; i++) {
//		for (int j = i + 1; j < n; j++) {
//			if (m[i] + m[j] == k) {
//				suc = 1;
//				goto END;
//			}
//		}
//	}
//END:
//	if (suc)cout << "yes" << endl;
//	else cout << "no" << endl;
//	system("pause");
//	return 0;
//}

//称体重
//#include<iostream>
//using namespace std;
//int main() {
//	cout << "s " << 10 << endl <<
//		"z " << 20 << endl <<
//		"q " << 40 << endl <<
//		"l " << 50 << endl;
//	system("pause");
//	return 0;
//}


//比饭量
//#include<iostream>
//using namespace std;
//int main() {
//	cout << "BCA" << endl;
//	system("pause");
//	return 0;
//}

//Minecraft
//#include<iostream>
//#include<algorithm>
//#include<climits>
//using namespace std;
//int main() {
//	int n;
//	cin >> n; 
//	int k;
//	int area = INT_MAX;
//	for (int i = 1; i <= n; i++) {
//		for (int j = i; j <= n; j++) {
//			if (n % (i*j) == 0) {
//				k = n / i / j;
//				area = min(area, (i*j + i * k + j * k) * 2);
//
//			}
//			
//
//		}
//	}
//	cout << area << endl;
//	system("pause");
//	return 0;
//}


//猴子吃桃  超时  遍历总桃树  应该遍历最后一个猴子分的桃子数
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	/*if (n == 3) {
//		cout << 25 << endl;
//		system("pause");
//		return 0;
//	}*/
//	for (int i = pow(10,n-2);; i++) {
//		int flag = 1;
//		int tmp = i;
//		for (int j = 1; j <= n; j++) {
//			if (tmp == 1 || (tmp - 1) % n != 0) {
//				flag = 0;
//				break;
//			}
//			tmp = (tmp - 1) / n;
//			tmp = tmp * (n - 1);
//		}
//		if (flag == 1) {
//			cout << i << endl;
//			break;
//		}
//
//	}
//
//	//cout << ans << endl;
//	system("pause");
//	return 0;
//}


//猴子吃桃  枚举最后一个猴子分的每一份的个数
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	
//	for (int i = 1;; i++) {
//		int tmp = i * n + 1;
//		int j = 2;
//		for (; j <= n; j++) {
//			if (tmp % (n - 1) == 0) {
//				//cout << i << " " << j << " " << tmp << endl;
//				tmp = tmp / (n - 1)*n + 1;
//			}
//			else {
//				break;
//			}
//		}
//		//cout << "hhh " << j << endl;
//		if (j == n+1) {//这里判等要加一  因为退出的时候多加了一
//			cout << tmp << endl;
//			break;
//		}
//	}
//
//	//cout << ans << endl;
//	system("pause");
//	return 0;
//}

//Flip Game
//#include<iostream>
//#include<cstring>
//#include<climits>
//#include<algorithm>
//using namespace std;
//const int maxn = 10;
//int m[maxn][maxn];
//int ans[maxn][maxn];
//bool solve() {
//	for (int i = 2; i <= 5; i++) {
//		for (int j = 1; j <= 4; j++) {
//			ans[i][j] = m[i - 1][j] ^ ans[i - 1][j] ^ ans[i - 1][j - 1] ^ ans[i - 1][j + 1] ^ ans[i - 2][j];
//
//		}
//	}
//	for (int i = 1; i <= 4; i++) {
//		if (ans[5][i] == 1) {
//			return false;
//		}
//	}
//	return true;
//}
//int main() {
//	char ch;
//	int res = INT_MAX;
//	for (int i = 1; i <= 4; i++) {
//		for (int j = 1; j <= 4; j++) {
//			cin >> ch;
//			if (ch == 'b') {
//				m[i][j] = 1;
//			}
//			else
//			{
//				m[i][j] = 0;
//			}
//		}
//	}
//	for (int i = 0; i < (1 << 4); i++) {
//		memset(ans, 0, sizeof(ans));
//		for (int j = 0; j <= 4; j++) {
//			ans[1][j + 1] = 1 & (i >> j);
//			//cout << i << " " << j << " " << ans[1][j] << endl;
//		}
//		if (solve()) {
//			int cnt = 0;
//			for (int i = 1; i <= 4; i++) {
//				for (int j = 1; j <= 4; j++) {
//					if (ans[i][j]) {
//						cnt++;
//					}
//				}
//				//cout << endl;
//			}
//			res = min(res, cnt);
//			//cout << cnt << " " << res << endl;
//		}
//	}
//	for (int i = 1; i <= 4; i++) {
//		for (int j = 1; j <= 4; j++) {
//			m[i][j] = 1 - m[i][j];
//		}
//	}
//	for (int i = 0; i < (1 << 4); i++) {
//		memset(ans, 0, sizeof(ans));
//		for (int j = 0; j <= 4; j++) {
//			ans[1][j + 1] = 1 & (i >> j);
//			//cout << i << " " << j << " " << ans[1][j] << endl;
//		}
//		if (solve()) {
//			int cnt = 0;
//			for (int i = 1; i <= 4; i++) {
//				for (int j = 1; j <= 4; j++) {
//					if (ans[i][j]) {
//						cnt++;
//					}
//				}
//				//cout << endl;
//			}
//			res = min(res, cnt);
//		}
//	}
//	if (res == INT_MAX) {
//		cout << "Impossible" << endl;
//	}
//	else {
//		cout << res << endl;
//
//	}
//	system("pause");
//	return 0;
//}


//我家的门牌号
//#include<iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1;; i++) {
//		int sum = (1 + i)*i / 2;
//		for (int j = 1; j <= i;j++) {
//			if (sum - 2 * j == n) {
//				cout << j << " " << i << endl;
//				goto END;
//			}
//		}
//	}
//END:
//	system("pause");
//	return 0;
//}

//三个三位数
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int main() {
//	int m[9] = { 1,2,3,4,5,6,7,8,9 };
//	int x, y, z;
//	do {
//		x = m[0] * 100 + m[1] * 10 + m[2];
//		y = m[3] * 100 + m[4] * 10 + m[5];
//		z = m[6] * 100 + m[7] * 10 + m[8];
//		if (x * 2 == y && x * 3 == z) {
//			cout << x << " " << y << " " << z << endl;
//		}
//	} while (next_permutation(m, m + 9));
//	system("pause");
//	return 0;
//}


//火车上的人数
//#include<iostream>
//#include<cstring>
//using namespace std;
//int ans[21], down[21], up[21];
//int main()
//{
//	int a, n, m, x, b, i;
//	cin >> a >> n >> m >> x;
//	memset(ans, 0, sizeof(ans));
//	up[1] = a; down[1] = 0; ans[1] = a;
//	b = 1;//枚举第二站上车人数
//	n--;
//	do {
//		up[2] = b; down[2] = b; ans[2] = ans[1];//枚举第2站的上车人数、下车人数和车上人数
//		for (i = 3; i <= n; i++)
//		{
//			up[i] = up[i - 1] + up[i - 2]; down[i] = up[i - 1];
//			ans[i] = ans[i - 1] + up[i - 2];
//		}
//		if (ans[n] == m)//若n站下车的人数为m，则输出从x站开出时车上的人数，并退出
//		{
//			cout << ans[x] << endl;
//			return 0;
//		}
//		b++;//第2站上车人数增加1
//	} while (ans[n] < m);//直至无法满足此规律为止
//	cout << "No Answer." << endl;
//	return 0;
//}


//Cantor表
//#include<iostream>
//using namespace std;
//const int maxn = 10000010;
//int fenzi[maxn];
//int fenmu[maxn];
//int main() {
//	int n;
//	cin >> n;
//	int c = 1;
//	int pos = 1;
//	do {
//		for (int i = 1; i <= c; i++) {
//			if (c % 2 == 0) {
//				fenzi[pos] = i;
//				fenmu[pos] = c - i + 1;
//			}
//			else {
//				fenmu[pos] = i;
//				fenzi[pos] = c - i + 1;
//			}
//			//cout << pos << " " << c << " " << i << " " << fenzi[pos] << " " << fenmu[pos] << endl;
//			pos++;
//		}
//		c++;
//	} while (pos<= n);
//	cout << fenzi[n] << "/" << fenmu[n] << endl;
//	system("pause");
//	return 0;
//}


// 2.5基本算法之搜索
//maze 网友答案
//#include<iostream>
//#include<cstring>
//using namespace std;
//char a[30][30]; //原数组
//int vis_key[30][30], vis_door[30][30];
//int key[5], hasKey[5], dir_r[4] = { 1,-1,0,0}, dir_c[4] = { 0,0,1,-1 }; // b数组纪录每种钥匙的数目，bb数组纪录有没有出现这种钥匙，0下标代表a, 依此类推
//int m, n, startx, starty, flag;//flag表示是否找到
//
//void find_key(int x, int y)
//{
//	if (flag)return;
//	for (int i = 0; i<4; i++)
//	{
//		int x2 = x + dir_r[i], y2 = y + dir_c[i];
//		if (a[x2][y2] == 'G')//如果找钥匙时找到宝藏，做标记，然后直接结束所有过程。 
//		{
//			flag = 1;
//			return;
//		}
//		if (a[x2][y2] >= 'a'&&a[x2][y2] <= 'e')
//		{
//			key[a[x2][y2] - 'a']--;//每找到一个钥匙，对应的b数组自减，值为0时代表全部集齐 
//			a[x2][y2] = '.';//将被找到的钥匙标记为空地 
//		}
//		if (a[x2][y2] == '.' && !vis_key[x2][y2])
//		{
//			vis_key[x2][y2] = 1; //标记找钥匙时走过的路 
//			find_key(x2, y2);
//		}//由于找钥匙时只要把所有路径走一遍，所以不需要回溯。
//	}
//}
//void find_door(int x, int y)
//{
//	if (flag)return;//找到宝藏后直接结束 
//	for (int i = 0; i<4; i++)
//	{
//		int x2 = x + dir_r[i], y2 = y + dir_c[i];
//		if (a[x2][y2] >= 'A'&&a[x2][y2] <= 'E' && !key[a[x2][y2] - 'A'] && hasKey[a[x2][y2] - 'A'])
//		{ //找到门后，如果已经集齐全部钥匙，则把门打开 
//			a[x2][y2] = '.';//将被打开的门标记为空地 
//			memset(vis_door, 0, sizeof(vis_door));/*vis_door数组纪录找门时走过的路，由于会找到新的钥匙，可能原来没打
//									开的门可以打开，所以将vis_door数组清零。*/
//			find_key(x2, y2);//每打开一个门，从被打开门的位置开始找钥匙。 
//		}
//
//		if (a[x2][y2] == '.' && !vis_door[x2][y2])
//		{
//			vis_door[x2][y2] = 1;
//			find_door(x2, y2);
//		}//同上 ，不需要回溯。 
//	}
//}
//int main()
//{
//	cin >> m >> n;
//	while (m)
//	{
//		flag = 0;
//		memset(a, 0, sizeof(a));
//		memset(vis_key, 0, sizeof(vis_key));
//		memset(vis_door, 0, sizeof(vis_door));
//		memset(key, 0, sizeof(key));
//		memset(hasKey, 0, sizeof(hasKey));
//		for (int i = 1; i <= m; i++)
//			for (int j = 1; j <= n; j++)
//			{
//				cin >> a[i][j];
//				if (a[i][j] == 'S')
//				{
//					startx = i; starty = j;
//					a[i][j] = '.';
//				}
//				if (a[i][j] >= 'a'&&a[i][j] <= 'e')
//				{
//					key[a[i][j] - 'a']++;
//					hasKey[a[i][j] - 'a'] = 1;
//				}
//
//			}
//		find_key(startx, starty);
//		find_door(startx, starty);
//		if (flag)cout << "YES" << endl;
//		else cout << "NO" << endl;
//		cin >> m >> n;
//	}
//}

//maze 自己默写 ？？思路很重要 这里要把起点设置为通路
//#include<iostream>
//#include<cstring>
//using namespace std;
//int r, c,start[2],keycnt[5],haskey[5],flag = 0;
//
//const int maxn = 25;
//int viskey[maxn][maxn], visdoor[maxn][maxn];
//char m[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//void findkey(int x, int y) {
//	if (flag) {
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] == 'G') {
//			flag = 1;
//			return;
//		}
//		if (m[nx][ny] >= 'a'&&m[nx][ny] <= 'e') {
//			keycnt[m[nx][ny] - 'a']--;
//			m[nx][ny] = '.';
//		}
//		if (m[nx][ny] == '.' && !viskey[nx][ny]) {
//			viskey[nx][ny] = 1;
//			findkey(nx, ny);
//		}
//	}
//}
//void finddoor(int x, int y) {
//	if (flag) {
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] == 'G') {
//			flag = 1;
//			return;
//		}
//		if (m[nx][ny] >= 'A'&&m[nx][ny] <= 'E'&&!keycnt[m[nx][ny]-'A']) {
//			m[nx][ny] = '.';
//			memset(visdoor, 0, sizeof(visdoor));
//			findkey(nx, ny);
//		}
//		if (m[nx][ny] == '.' && !visdoor[nx][ny]) {
//			visdoor[nx][ny] = 1;
//			finddoor(nx, ny);
//		}
//	}
//}
//int main() {
//	while (cin >> r >> c && r != 0 && c != 0) {
//		memset(keycnt, 0, sizeof(keycnt));
//		memset(haskey, 0, sizeof(haskey));
//		memset(visdoor, 0, sizeof(visdoor));
//		memset(viskey, 0, sizeof(viskey));
//		memset(m, 0, sizeof(m));
//		for (int i = 0; i < r; i++) {
//			for (int j = 0; j < c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'S') {
//					start[0] = i;
//					start[1] = j;
//					m[i][j] = '.';//这里要把起点设置为通路
//				}
//				if (m[i][j] >= 'a'&&m[i][j] <= 'e') {
//					keycnt[m[i][j] - 'a']++;
//					haskey[m[i][j] - 'a'] = 1;
//				}
//			}
//		}
//		findkey(start[0], start[1]);
//		finddoor(start[0], start[1]);
//		if (flag) {
//			cout << "YES"<<endl;
//		}
//		else {
//			cout << "NO" << endl;;
//		}
//		flag = 0;
//	}
//}

//Dungeon Master
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int l, r, c, v[31][31][31];
//int posx[] = { 0,0,0,0,1,-1 }, posy[] = { 0,0,1,-1,0,0 }, posz[] = { 1,-1,0,0,0,0 };
//bool maze[31][31][31], uva = true;
//char tmp;
//struct point {
//	int x;
//	int y;
//	int z;
//	int step;
//};
//bool legal(point _) {
//	return _.x>0 && _.y>0 && _.z>0 && _.x <= l && _.y <= r && _.z <= c;
//}
//int bfs(point start, point des) {
//	memset(v, 0, sizeof(v));
//	queue<point> Q;
//	Q.push(start);
//	while (!Q.empty()) {
//		point now = Q.front();
//		Q.pop();
//		for (int i = 0; i<6; ++i) {
//			point next = now;
//			next.x += posx[i];
//			next.y += posy[i];
//			next.z += posz[i];
//			if (next.x == des.x&&next.y == des.y&&next.z == des.z) {
//				next.step = now.step + 1;
//				return next.step;
//			}
//			if (legal(next) && !v[next.x][next.y][next.z] && !maze[next.x][next.y][next.z]) {
//				v[next.x][next.y][next.z] = 1;
//				next.step = now.step + 1;
//				Q.push(next);
//			}
//		}
//	}
//	return -1;
//}
//int main() {
//	while ((cin >> l >> r >> c) && l&&r&&c) {
//		point start, des;
//		for (int i = 1; i <= l; ++i)
//			for (int j = 1; j <= r; ++j)
//				for (int k = 1; k <= c; ++k) {
//					cin >> tmp;
//					if (tmp == '.') maze[i][j][k] = 0;
//					if (tmp == '#') maze[i][j][k] = 1;
//					if (tmp == 'S') start.x = i, start.y = j, start.z = k, maze[i][j][k] = 1;//起始位置要置为通路
//					if (tmp == 'E') des.x = i, des.y = j, des.z = k, maze[i][j][k] = 0;//终点置为障碍
//				}
//		start.step = 0;
//		int ans = bfs(start, des);
//		if (ans == -1) cout << "Trapped!";
//		else cout << "Escaped in " << ans << " minute(s).";
//		cout << endl;
//	}
//	return 0;
//}


//自己默写 ？？ 注意要把cout注释掉 不然报Output Limit Exceeded 
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//const int maxn = 35;
//char temp;
//int h, r, c;
//int m[maxn][maxn][maxn], vis[maxn][maxn][maxn];
//int dirx[6] = { 0,0,0,0,1,-1 };
//int diry[6] = { 0,0,1,-1,0,0 };
//int dirz[6] = { 1,-1,0,0,0,0 };
//int flag = 0;
//
//struct Point
//{
//	int x, y, z, step;
//};
//int bfs(Point start, Point end) {
//	memset(vis, 0, sizeof(vis));
//	queue<Point> q;
//	q.push(start);
//	while (!q.empty()) {
//		Point oldp = q.front();
//		q.pop();
//		for (int i = 0; i < 6; i++) {
//			Point newp = oldp;//在这里开新的 因为每个方向都要是新的
//			newp.x += dirx[i];
//			newp.y += diry[i];
//			newp.z += dirz[i];
//
//			if (newp.x == end.x &&newp.y == end.y &&newp.z == end.z) {
//				flag = 1;
//				newp.step = oldp.step + 1;
//				return newp.step;
//			}
//			if (newp.x >= 0 && newp.x < h&& newp.y >= 0 && newp.y < r&&newp.z >= 0 && newp.z < c) {
//				if (m[newp.x][newp.y][newp.z] == 1 && vis[newp.x][newp.y][newp.z] == 0) {
//					//cout << newp.x << " " << newp.y << " " << newp.z << " " << newp.step << " " << flag << endl;
//					newp.step = oldp.step + 1;
//					vis[newp.x][newp.y][newp.z] = 1;
//					q.push(newp);
//				}
//			}
//
//		}
//	}
//	return -1;
//}
//int main() {
//	while (cin >> h >> r >> c && h&& r  && c) {
//		Point start, des;
//		for (int i = 0; i < h; i++) {
//			for (int j = 0; j < r; j++) {
//				for (int k = 0; k < c; k++) {
//					cin >> temp;
//					if (temp == 'S') {
//						start.x = i;
//						start.y = j;
//						start.z = k;
//						start.step = 0;
//						m[i][j][k] = 1;
//					}
//					if (temp == 'E') {
//						des.x = i;
//						des.y = j;
//						des.z = k;
//						m[i][j][k] = 0;
//					}
//					if (temp == '.') m[i][j][k] = 1;
//					if (temp == '#') m[i][j][k] = 0;
//				}
//			}
//		}
//		int ans = bfs(start, des);
//		if (flag) {
//			cout << "Escaped in " << ans << " minute(s)." << endl;
//		}
//		else {
//			cout << "Trapped!" << endl;
//		}
//		flag = 0;
//	}
//	//system("pause");
//	return 0;
//}

//Channel Allocation  ？？转化为填色问题 dfs  注意颜色和节点的下标起始
//#include<iostream>
//#include<cstring>
//#include<string>
//using namespace std;
//int n;
//const int maxn = 30;
//int m[maxn][maxn], color[maxn];
//int flag = 0;
//int cnt, ans;
//bool check(int nd, int colr) {
//	for (int i = 0; i < n; i++) {//m下标从0开始
//		if (m[nd][i] && color[i] == colr) {
//			return false;
//		}
//	}
//	return true;
//}
//void dfs(int nd, int tot) {
//	if (flag) {
//		return;
//	}
//	if (nd >= n) {//下标从0开始 取等号
//		flag = 1;
//		return;
//	}
//	for (int i = 1; i <= tot; i++) {//颜色下标从1开始
//		if (check(nd, i)) {
//			//cout << nd << " " << i <<" "<<tot<< endl;
//			color[nd] = i;
//			dfs(nd + 1, tot);
//			color[nd] = 0;
//		}
//	}
//	if (!flag) {
//		ans++;
//		dfs(nd, tot + 1);
//	}
//}
//int main() {
//	string s;
//	int a, b;
//	while (cin >> n && n) {
//		cnt = 0;
//		ans = 1;
//		flag = 0;
//		memset(m, 0, sizeof(m));
//		memset(color, 0, sizeof(color));
//		for (int i = 1; i <= n; i++) {
//			cin >> s;
//			a = s[0] - 'A';
//			for (int j = 2; j < s.length(); j++) {
//				b = s[j] - 'A';
//				m[a][b] = 1;
//				m[b][a] = 1;//相当于无向图
//			}
//		}
//		dfs(0, 1);//m下标从0开始 所以从0~n-1  颜色下标从1开始
//		if (ans == 1) {
//			cout << ans << " channel needed." << endl;
//		}
//		else {
//			cout << ans << " channels needed." << endl;
//		}
//
//	}
//	system("pause");
//	return 0;
//}


//Lake Counting ??bfs
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c;
//const int maxn = 110;
//char m[maxn][maxn];
//int dirx[8] = { 0,0,1,-1,1,1,-1,-1 };
//int diry[8] = { 1,-1,0,0,1,-1,1,-1 };
//int cnt = 0;
//struct Point
//{
//	int x, y;
//};
//
//void bfs(Point p) {
//
//	queue<Point> q;
//	q.push(p);
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();//不要忘记把队首元素去掉
//		for (int i = 0; i < 8; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (m[next.x][next.y] == 'W') {
//				m[next.x][next.y] = '.';
//				q.push(next);
//			}
//		}
//	}
//	cnt++;
//}
//int main() {
//	memset(m, 0, sizeof(m));
//
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (m[i][j] == 'W') {
//				Point start;
//				start.x = i;
//				start.y = j;
//				
//				//cout << i << " " << j << endl;
//				bfs(start);
//			}
//		}
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//A Knight's Journey  朝一个方向走两步在拐弯走一步  没用vector
//#include<iostream>
//#include<cstring>
//#include<vector>
//using namespace std;
//int r, c;
//const int maxn = 30;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int flag = 0;
//int cnt = 1, step;
////字典序
//int dirx[8] = { -1,1,-2,2,-2,2,-1,1 };
//int diry[8] = { -2,-2,-1,-1,1,1,2,2 };
//
//
//int ans[maxn][2];//dfs不适合用结构体 
//void dfs(int x, int y, int step) {
//
//	if (flag) {
//		return;
//	}
//	ans[step][0] = x;//对ans的理解：step用作记录第step层选择的坐标 也可以放在if判断语句里 不过要提前记录其实step = 1的情况 
//	ans[step][1] = y;
//	if (step == r * c) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 8; i++) {
//
//		int nextx = x + dirx[i];
//		int nexty = y + diry[i];
//		if (nextx >= 1 && nextx <= r && nexty >= 1 && nexty <= c && !vis[nextx][nexty] && !flag) {//这里要判断flag 因为孩子节点返回了之后可能就已经走完了
//			vis[nextx][nexty] = 1;
//			//cout << nextx << " " << nexty<<" "<<step<<" "<<flag<<" "<<ans[step][0]<<" "<<ans[step][1] << endl;
//
//			dfs(nextx, nexty, step + 1);
//			vis[nextx][nexty] = 0;//回溯 恢复现场
//			//v.pop_back();
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	int cnt = 1;
//	for (int i = 0; i < n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//
//		flag = 0;
//		cin >> r >> c;
//
//		vis[1][1] = 1;//一定要记得初始化起点
//		//step = 1;
//		dfs(1, 1, 1);
//
//		cout << "Scenario #" << cnt << ":" << endl;
//		if (flag) {
//			//cout << "step " << step << endl;
//			for (auto i = 1; i <= r * c; i++) {
//				cout << char(ans[i][1] + 'A' - 1) << ans[i][0];
//			}
//			cout << endl;
//		}
//		else {
//			cout << "impossible" << endl;
//		}
//		if (cnt != n) {
//			cout<< endl;
//		}
//		cnt++;
//	}
//	system("pause");
//	return 0;
//}

//A Knight's Journey 自己再写一次
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 26;
//int r, c;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int flag = 0;
//int ans[maxn][2];
//int dirx[8] = {-1,1,-2,2,-2,2,-1,1};
//int cnt = 1;
//int diry[8] = {-2,-2,-1,-1,1,1,2,2};
//void dfs(int x, int  y, int step) {
//	if (flag) {
//		return;
//	}
//	ans[step][0] = x;
//	ans[step][1] = y;
//	if (step == r * c) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 8; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !vis[nx][ny] && !flag) {
//			vis[nx][ny] = 1;
//			dfs(nx, ny, step + 1);
//			vis[nx][ny] = 0;
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> r >> c;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		
//		flag = 0;
//		vis[1][1] = 1;//一定记得初始化起点！！！
//		dfs(1, 1, 1);
//		cout << "Scenario #" << cnt << ":" << endl;
//		if (flag) {
//			for (int j = 1; j <= r * c; j++) {
//				cout << char(ans[j][1] + 'A' - 1) << ans[j][0];
//			}
//			cout << endl;
//		}
//		else {
//			cout << "impossible" << endl;;
//		}
//		if (cnt != n) {
//			cout << endl;
//		}
//		cnt++;
//	}
//	system("pause");
//	return 0;
//}


//LETTERS ?? 用dfs 不用开vis
//#include<iostream>
//#include<queue>
//#include<cstring>
//#include<algorithm>
//#include<math.h>
//using namespace std;
//const int maxn = 25;
//int m[maxn][maxn];
//int r, c;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
////int vis[maxn][maxn];
//int letter[30];
//int ans = 0;
//void dfs(int x, int y, int step) {
//
//	ans = max(ans, step);
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (m[nx][ny] &&  !letter[m[nx][ny]]) {
//			//cout << nx << " " << ny << " " << endl;
//			//vis[nx][ny] = 1;
//			letter[m[nx][ny]]= 1;
//			dfs(nx, ny, step + 1);
//			//vis[nx][ny] = 0;
//			letter[m[nx][ny]] = 0;
//		}
//	}
//}
//int main() {
//	//memset(vis, 0, sizeof(vis));
//	memset(m, 0, sizeof(m));
//	cin >> r >> c;
//	char temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			m[i][j] = temp - 'A' + 1;//从1开始编号
//		}
//	}
//	//vis[1][1] = 1;
//	letter[m[1][1]] = 1;
//	dfs(1, 1, 1); 
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//The Castle  ？？ 类似于最长路径 用dfs 但是不能直接用dfs中的step来表示s  注意技巧 &
//#include<iostream>
//#include<cstring>
//#include<math.h>
//#include<algorithm>
//using namespace std;
//int r, c;
//int s, cnt,maxs;
//const int maxn = 55;
//int m[maxn][maxn][4], vis[maxn][maxn];
//int dirx[4] = { 0,-1,0,1 };
//int diry[4] = { -1,0,1,0 };
//void dfs(int x, int y) {//这里不能直接在dfs记录步数，因为dfs只能找最长通路，而我们要求的是最大面积，只要是走过的都要算进去，不要求一定是在一条路径上
//	maxs = max(s, maxs);
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		//cout << nx << " " << ny << " " << step+1 << " "<< m[x][y][i] <<" "<< vis[nx][ny] <<endl;
//
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !m[x][y][i] && !vis[nx][ny]) {//这里是判断前一步的m[x][y][i]而不是判断走了一步之后的障碍物
//			//cout << "hh" << endl;
//			s++;
//			//cout << nx << " " << ny << " " << s<< endl;
//			vis[nx][ny] = 1;
//			dfs(nx, ny);
//		}
//	}
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	memset(m, 0, sizeof(m));
//	cin >> r >> c;
//	int temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp & 1) {
//				
//				m[i][j][0] = 1;//西边有墙
//				//cout << m[i][j][0] << endl;
//			}
//			if (temp & 2) {
//				
//				m[i][j][1] = 1;//北边有墙
//				//cout << m[i][j][1] << endl;
//			}
//			if (temp & 4) {
//				
//				m[i][j][2] = 1;//东边有墙
//				//cout << m[i][j][2] << endl;
//			}
//			if (temp & 8) {
//				
//				m[i][j][3] = 1;//南边有墙
//				//cout << m[i][j][3] << endl;
//			}
//			//system("pause");
//		}
//	}
//	cnt = 0;
//	
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (!vis[i][j]) {
//				vis[i][j] = 1;
//				s = 1;
//				cnt++;
//				//cout << "start: " << i << " " << j << endl;
//				dfs(i, j);
//				maxs = max(maxs, s);
//			}
//		}
//	}
//	cout << cnt << endl << maxs;
//	system("pause");
//	return 0;
//}

//八皇后问题 ？？思路 把主对角线 次对角线 行 各开一个数组 用作标志位
//#include<iostream>
//#include<cstring>
//using namespace std;
//int flag = 0;
//const int maxn = 20;//这里数组要开大一点 因为 i-j共有16种值
//int m[maxn][maxn];
//int path[maxn];
//int zdjx[maxn], cdjx[maxn], col[maxn];
//int sum = 0;
//
//void out() {//输出的时候行列交换 满足题意要求
//	sum++;
//	cout << "No. " << sum << endl;
//	for (int i = 1; i <= 8; i++) {//原来的列
//		for (int j = 1; j <= 8; j++) {
//			if (i == path[j]) {
//				cout << 1 << " ";
//			}
//			else {
//				cout << 0 << " ";
//			}
//		}
//		cout << endl;
//	}
//}
//void dfs(int i) {
//	if (i > 8) {//这里是>8 因为==8 第8行还没判断
//		//cout << "hh" << endl;
//		out();
//		//return;
//	}
//	for (int j = 1; j <= 8; j++) {
//		//cout << step << " " << path[step] << " " << check(i, step) << endl;
//		if (!col[j] && !zdjx[i - j + 7] && !cdjx[i + j]) {
//			path[i] = j;
//			col[j] = 1;
//			zdjx[i - j + 7] = 1;
//			cdjx[i + j] = 1;
//			//cout << i << endl;
//			dfs(i + 1);
//			col[j] = 0;
//			zdjx[i - j + 7] = 0;
//			cdjx[i + j] = 0;
//		}
//	}
//}
//int main() {
//	dfs(1);
//	system("pause");
//	return 0;
//}


//八皇后
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100;
//int num[maxn];
//int path[maxn], col[maxn], zdjx[maxn], cdjx[maxn];
//int cnt = 0;
//void out() {
//	for (int i = 1; i <= 8; i++) {
//		cout << path[i];
//	}
//	cout << endl;
//}
//void dfs(int i) {
//	if (i > 8) {
//		cnt++;
//		for (int k = 0; k <= 92; k++) {
//			if (num[k] == cnt) {
//				out();
//				break;
//			}
//		}
//		/*cout << cnt << endl;
//		out();*/
//	}
//	for (int j = 1; j <= 8; j++) {
//		if (!col[j] && !zdjx[i - j + 7] && !cdjx[i + j]) {
//		//	cout << i << " " << j << " " << endl;
//			col[j] = 1;
//			zdjx[i - j + 7] = 1;//这里下标对应的是i - j + 7  不是j
//			cdjx[i + j] = 1;
//
//			path[i] = j;
//			dfs(i + 1);
//
//			col[j] = 0;
//			zdjx[i - j + 7] = 0;
//			cdjx[i + j] = 0;
//		}
//	}
//}
//int main() {
//	memset(path, 0, sizeof(path));
//	memset(col, 0, sizeof(col));
//	memset(zdjx, 0, sizeof(zdjx));
//	memset(cdjx, 0, sizeof(cdjx));
//
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> num[i];
//	}
//	dfs(1);
//	system("pause");
//	return 0;
//}

//算24 网上标答
//#include<cstdio>
//#include<algorithm>
//#include<cmath>
//#include<string.h>
//using namespace std;
//int visit[5];
//double a[5];
//int dfs(int step)
//{
//	if (step == 4) {
//		for (int i = 1; i <= 4; i++)
//			if (!visit[i]) {
//				if (fabs(a[i] - 24.0) < 0.0000001) {
//					return 1;
//
//				}
//
//			}
//		return 0;
//
//	}
//	for (int i = 1; i <= 4; i++) //枚举第一个数
//		if (!visit[i])
//			for (int j = i + 1; j <= 4; j++)//枚举第二个数
//				if (!visit[j])
//				{
//					visit[j] = 1;
//					double tmp1 = a[i], tmp2 = a[j];
//					a[i] = tmp1 + tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 - tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp2 - tmp1;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 * tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp2 / tmp1;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1 / tmp2;
//					if (dfs(step + 1))return 1;
//					a[i] = tmp1;//回溯法
//					visit[j] = 0;
//				}
//	return 0;
//
//}
//int main()
//{
//	while (1)
//	{
//		scanf("%lf%lf%lf%lf", &a[1], &a[2], &a[3], &a[4]);
//		if (a[1] || a[2] || a[3] || a[4]) {
//			memset(visit, 0, sizeof(visit));
//			if (dfs(1))printf("YES\n");
//			else printf("NO\n");
//
//		}
//		else break;
//	}
//	return 0;
//
//}

//算24 ?? 思路 网上答案的方法
//#include <iostream>
//#include<cstring>
//#include<math.h>
//using namespace std;
//const int maxn = 10;
//double m[maxn];
//int vis[maxn];
//int flag = 0;
//int dfs(int step) {
//	/*if (flag) {
//		return 1;
//	}*/
//	if (step == 4) {//4个数进行3次运算 所以在step等于4的时候就已经进行完运算了 并且只有一个数是没有访问过的 那个数就是最后的结果
//		for (int i = 1; i <= 4; i++) {
//			if (!vis[i]&&fabs(m[i] - 24.0) < 1e-8) {
//				//flag = 1;
//				return 1;
//			}
//		}
//		return 0;
//
//	}
//	for (int i = 1; i <= 4; i++) {
//		if (!vis[i]) {
//			for (int j = i+1; j <= 4; j++) {//排列组合 j起始是i+1不是1
//				if (!vis[j]) {
//					vis[j] = 1;
//					//cout << step << " " << m[i] << " " << m[j] << " " << m[i] + m[j] << endl;
//					double temp1 = m[i];
//					double temp2 = m[j];
//					m[i] = temp1 + temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 - temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 * temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1 / temp2;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp2 - temp1;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp2 / temp1;
//					if (dfs(step + 1)) return 1;
//
//					m[i] = temp1;//回溯
//					vis[j] = 0;
//				}
//			}
//		}
//	}
//	return 0;//这里一定要返回0
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	
//	while (cin >> m[1] >> m[2] >> m[3] >> m[4] && m[1] != 0 && m[2] != 0 && m[3] != 0 && m[4] != 0) {
//		
//		memset(vis, 0, sizeof(vis));
//		/*for (int i = 1; i <= 4; i++) {
//			cout << m[i] << " ";
//		}*/
//		if (dfs(1)) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}

//算24 自己的方法
//#include <iostream>
//#include<cstring>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//const int maxn = 10;
//double m[maxn];
//int vis[maxn];
//int flag = 0;
//void dfs(int step) {
//	if (flag) {//作用 找到一个就可以结束了 不用遍历完全部
//		return;
//	}
//	if (step == 4) {//4个数进行3次运算 所以在step等于4的时候就已经进行完运算了 并且只有一个数是没有访问过的 那个数就是最后的结果
//		for (int i = 1; i <= 4; i++) {
//			if (!vis[i] && fabs(m[i] - 24.0) < 1e-8) {
//				flag = 1;
//				return;
//			}
//		}
//	}
//	for (int i = 1; i <= 4; i++) {
//		if (!vis[i]) {
//			for (int j = i + 1; j <= 4; j++) {//排列组合 j起始是i+1不是1
//				if (!vis[j]) {
//					vis[j] = 1;
//					//cout << step << " " << m[i] << " " << m[j] << " " << m[i] + m[j] << endl;
//					double temp1 = m[i];
//					double temp2 = m[j];
//					m[i] = temp1 + temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 - temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 * temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1 / temp2;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp2 - temp1;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp2 / temp1;
//					dfs(step + 1);
//					if (flag) {
//						return;
//					}
//
//					m[i] = temp1;//回溯
//					vis[j] = 0;
//				}
//			}
//		}
//	}
//
//}
//int main() {
//	memset(m, 0, sizeof(m));
//
//	while (cin >> m[1] >> m[2] >> m[3] >> m[4] && m[1] != 0 && m[2] != 0 && m[3] != 0 && m[4] != 0) {
//
//		memset(vis, 0, sizeof(vis));
//		/*for (int i = 1; i <= 4; i++) {
//		cout << m[i] << " ";
//		}*/
//		dfs(1);
//		if (flag) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//		flag = 0;
//	}
//	system("pause");
//	return 0;
//}

//迷宫  使用回溯 超时 去掉回溯 满分
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n;
//const int maxn = 110;
//int m[maxn][maxn], vis[maxn][maxn];
//int sx, sy, ex, ey;
//int flag = 0;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//void dfs(int x, int y) {
//	if (flag) {
//		return;
//	}
//	if (x == ex && y == ey) {
//		flag = 1;
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		if (nx >= 0 && nx < n&&ny >= 0 && ny < n && !vis[nx][ny]&&m[nx][ny]) {
//			//cout << nx << " " << ny << endl;
//			vis[nx][ny] = 1;
//			dfs(nx, ny);
//			//vis[nx][ny] = 0;
//		}
//	}
//}
//int main() {
//	int cnt;
//	char temp;
//	cin >> cnt;
//	for (int i = 0; i < cnt; i++) {
//		flag = 0;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cin >> n;
//		for (int j = 0; j < n; j++) {
//			for (int k = 0; k < n; k++) {
//				cin >> temp;
//				if (temp == '.') {
//					m[j][k] = 1;//通路
//				}
//				else {
//					m[j][k] = 0;//障碍
//				}
//			}
//		}
//
//		cin >> sx >> sy >> ex >> ey;
//		vis[sx][sy] = 1;
//		if (m[sx][sy] == 0|| m[ex][ey] == 0) {//判断起点和终点是不是通路
//			cout << "NO" << endl;
//			//system("pause");
//			continue;//这里不能直接返回 因为还有剩下的测试用例
//		}
//		dfs(sx, sy);
//		if (flag) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//小游戏 ？？bfs vis记录路径 如果遇到更短的 也可以走
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<sstream>
//#include<limits.h>
//#include<queue>
//using namespace std;
//int r, c, sx, sy, ex, ey;
//const int maxn = 80;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int cnt = 0, tot = 1;
//int ans = 99999999;
//struct Point
//{
//	int x, y, step, dir;
//	Point() {};
//	Point(int xx, int yy, int ss, int dd) :x(xx), y(yy), step(ss), dir(dd) {};
//};
//
//
//int bfs() {
//	queue<Point> q;
//	q.push(Point(sx, sy, 0, -1));
//	vis[sx][sy] = 1;
//	while (!q.empty()) {
//		//Point now = q.front();
//		int x = q.front().x, y = q.front().y, sp = q.front().step, dir = q.front().dir;
//		cout << "now: " << x << " " <<y << " " << sp << " " <<dir << endl;
//		q.pop();
//		if (x == ex && y == ey) {
//			ans = min(sp, ans);
//		}
//		for (int i = 0; i < 4; i++) {
//
//			int nx = x + dirx[i];
//			int ny = y + diry[i];
//			if (nx >= 0 && nx <= r + 1 && ny >= 0 && ny <= c + 1 && (m[nx][ny] != 'X' || (nx == ex && ny == ey))) {
//				int nsp = dir == i ? sp : sp + 1;
//				if (vis[nx][ny] == -1 || vis[nx][ny] > nsp) {//是没有被访问过的节点或者说现在这种走法更近
//					vis[nx][ny] = nsp;
//					q.push(Point(nx, ny, nsp, i));
//
//				}
//			}
//		}
//	}
//	return ans == 99999999 ? -1 : ans;
//}
//
//int main() {
//
//
//	while (cin >> c >> r) {//r和c顺序是反的
//		if (c + r == 0) {//r和c不同时为0
//			break;
//		}
//		tot = 0;//
//		memset(m, 0, sizeof(m));
//		//cout << "Board #" << ++cnt << ":" << endl;
//		printf("Board #%d:\n", ++cnt);
//		getchar();//读取换行符
//		//cout << "x" << endl;
//		for (int i = 1; i <= r; i++) {
//			string line;
//			getline(cin, line);
//			for (int j = 1; j <= c; j++) {
//				m[i][j] = line[j - 1];
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		while (cin >> sy >> sx >> ey >> ex) {//这里x和y都交换顺序读
//			if (sx + sy + ex + ey == 0)break;
//			memset(vis, -1, sizeof(vis));
//			ans = 99999999;
//
//			int res = bfs();
//			/*if (res == -1) {
//				cout << "Pair " << ++tot << ": impossible." << endl;
//
//			}
//			else {
//				cout << "Pair " << ++tot << ": " << res << " segments." << endl;
//
//			}*/
//			if (res == -1)printf("Pair %d: impossible.\n", ++tot);
//			else printf("Pair %d: %d segments.\n", ++tot, res);
//
//		}
//		cout << endl;
//	}
//	//system("pause");
//	return 0;
//}


//小游戏 自己写  bfs+vis存最短路径
//#include<iostream>
//#include<queue>
//#include<string>
//#include<cstring>
//#include<limits.h>
//#include<math.h>
//#include<sstream>
//using namespace std;
//int r, c, sx, sy, ex, ey;
//const int maxn = 80;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1, 0,0 };
//struct Point
//{
//	int x, y, step, dir;
//	Point() {};
//	Point(int xx, int yy, int ss, int dd) :x(xx), y(yy), step(ss), dir(dd) {};
//};
//int bfs() {
//	int ans = INT_MAX;
//	queue<Point> q;
//	q.push(Point(sx, sy, 0, -1));
//	vis[sx][sy] =1;
//	while (!q.empty()) {
//		Point now = q.front();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		q.pop();
//		if ((now.x == ex) && (now.y == ey)) {
//			ans = min(ans, now.step);
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x <= r + 1 && next.y >= 0 && next.y <= c + 1 && ((m[next.x][next.y] != 'X') || (next.x == ex) && (next.y == ey))) {
//				if (now.dir == i) {//可以走这一步再更新step
//					next.step = now.step;
//				}
//				else {
//					next.step = now.step + 1;
//				}
//				if (vis[next.x][next.y] == -1 || vis[next.x][next.y] > next.step) {//走了这一步才能判断是否比原来的小
//					vis[next.x][next.y] = next.step;
//					next.dir = i;
//				
//					q.push(next);
//				}
//			}
//
//		}
//	}
//	return ans == INT_MAX ? -1 : ans;
//}
//int main() {
//	int tot = 1;//在循环外初始化
//	while (cin >> c >> r) {
//		
//		if (r + c == 0) {
//			break;
//		}
//		cout << "Board #" << tot++ << ":" << endl;
//		memset(m, 0, sizeof(m));
//		getchar();
//		for (int i = 1; i <= r; i++) {
//			string line;
//			getline(cin, line);
//			for (int j = 1; j <= c; j++) {
//				m[i][j] = line[j - 1];
//			}
//		}
//		int cnt = 1;
//		while (cin >> sy >> sx >> ey >> ex) {
//			if (sx + sy + ex + ey == 0) {
//				break;
//			}
//			memset(vis, -1, sizeof(vis));
//
//			int sus = bfs();
//			if (sus == -1) {
//				cout << "Pair " << cnt++ << ": impossible." << endl;
//			}
//			else {
//				cout << "Pair " << cnt++ << ": " << sus << " segments." << endl;
//			}
//		}
//		cout << endl;//注意最后有一个空行
//	}
//	system("pause");
//	return 0;
//}


//碎纸机 网上 ？？思路
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<cstdio>
//using namespace std;
//int tar, str_len;
//int single_v[23333];
//int slide_v[23333];
//
//bool multi;
//
//int best_ans[23333];
//int best_tot;
//int best_ans_len;
//void dfs(int tot, int pos, int cnt)//初始0 1 1
//{
//	if (tot > tar)
//		return;
//	if (pos > str_len)
//	{
//		if (tot == best_tot)//和之前最佳答案重复
//		{
//			multi = 1;
//			return;
//		}
//		if (tot > best_tot)
//		{
//			multi = 0;
//			best_tot = tot;
//			for (int i = 1; i < cnt; i++)
//				best_ans[i] = slide_v[i];
//			best_ans_len = cnt - 1;
//		}
//		return;
//	}
//
//	int slide_temp = 0;
//	for (int i = pos; i <= str_len; i++)
//	{
//		slide_temp *= 10;
//		slide_temp += single_v[i];
//		slide_v[cnt] = slide_temp;
//		dfs(tot + slide_temp, i + 1, cnt + 1);
//	}
//}
//int main()
//{
//	while (1)
//	{
//		memset(single_v, 0, sizeof(single_v));
//		multi = 0;
//		best_tot = -1;
//
//		string str;
//		cin >> tar >> str;
//		int strv = 0;
//		str_len = str.size();
//		if (tar == 0)
//			break;
//		for (int i = 0; i < str_len; i++)
//		{
//			single_v[i + 1] = str[i] - '0';
//			strv *= 10;
//			strv += single_v[i + 1];
//		}
//
//		if (strv == tar)
//		{
//			printf("%d %d\n", tar, tar);
//			continue;
//		}
//		dfs(0, 1, 1);
//		if (multi)
//		{
//			puts("rejected");
//			continue;
//		}
//		if (best_tot == -1)
//			puts("error");
//		else
//		{
//			printf("%d ", best_tot);
//			for (int i = 1; i <= best_ans_len; i++)
//			{
//				printf("%d ", best_ans[i]);
//			}
//			puts("");
//		}
//	}
//	system("pause");
//	return 0;
//}

//碎纸机 自己默写
//#include <iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int tar;
//string s;
//const int maxn = 10;
//int single[maxn];
//int str_len;
//int str_v;
//int ans = -1,multi = 0,ans_slide;
//int temp_trace[maxn],ans_trace[maxn];
//void dfs(int tot, int pos, int slide_cnt) {//在未划分之前的总数为tot  当前正在进行第pos个位置及其以后的位置的数字的划分  cntslide表示当前进行的切割次数 初始是1
//	//cout << tot << " " << pos << " " << slide_cnt << endl;
//	if (tot > tar) {
//		return;
//	}
//	if (pos > str_len) {
//		if (tot == ans) {
//			multi = 1;
//		}
//		if (tot > ans) {
//			multi = 0;//如果之前被置1了 那么更新答案了之后要置0
//			ans = tot;
//			ans_slide = slide_cnt - 1;//注意cnt要减一  因为多走了一层
//			for (int i = 1; i <= slide_cnt; i++) {
//				ans_trace[i] = temp_trace[i];
//			}
//		}
//		return;
//	}
//	int temp = 0;
//	for (int i = pos; i <= str_len; i++) {
//		temp = temp * 10;
//		temp += single[i];
//		temp_trace[slide_cnt] = temp;
//		dfs(tot + temp, i+1, slide_cnt + 1);//注意这里  是i+1！
//	}
//}
//int main() {
//	while (cin >> tar >> s) {
//		if (tar == 0 && s == "0") {
//			break;
//		}
//		ans = -1;
//		multi = 0;
//		memset(ans_trace, 0, sizeof(ans_trace));
//		memset(temp_trace, 0, sizeof(temp_trace));
//		memset(single, 0, sizeof(single));
//
//		str_len = s.length();
//		str_v = 0;
//		for (int i = 1; i <= str_len; i++) {
//			single[i] = s[i - 1] - '0';//注意字符串和数字的转化
//			str_v = str_v * 10;
//			str_v = str_v + single[i];
//			//cout << s[i - 1] << " " << single[i] << " " << str_v << endl;
//
//		}
//		if (tar == str_v) {
//			//cout << "hhh" << endl;
//			cout << tar << " " << tar << endl;
//			continue;
//		}
//		dfs(0, 1, 1);
//		if (ans == -1) {
//			cout << "error" << endl;
//			continue;
//		}
//		if (multi == 1) {
//			cout << "rejected" << endl;
//			continue;
//		}
//		else {
//			cout << ans;
//			for (int i = 1; i <= ans_slide; i++) {
//				cout << " " << ans_trace[i];
//			}
//			cout << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}


//城堡问题
//#include <iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 55;
//int m[maxn][maxn][4];
//int vis[maxn][maxn];
//int dirx[4] = { 0,-1,0,1 };
//int diry[4] = { -1,0,1,0 };
//
//int r, c;
//int area = 0;
//int max_area = 0;
//int cnt = 0;
//void dfs(int x, int y) {
//	//cout << x << " " << y << " " << area << " " << cnt << endl;
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + diry[i];
//		//cout << x << " " << y << " " << nx << " " << ny << " " << m[x][y][i] << " " << !vis[nx][ny] << " " << area << " " << cnt << endl;
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && !m[x][y][i] && !vis[nx][ny]) {
//			//cout << x << " " << y << " " << nx << " " << ny << " " << m[x][y][i] << " " << vis[nx][ny] << " " << area << " " << cnt << endl;
//			vis[nx][ny] = 1;
//			area++;
//			dfs(nx, ny);
//			//vis[nx][ny] = 0;//不用回溯
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//
//	cin >> r >> c;
//	int temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp & 1) {
//				m[i][j][0] = 1;
//			}
//			if (temp & 2) {
//				m[i][j][1] = 1;
//			}
//			if (temp & 4) {
//				m[i][j][2] = 1;
//			}
//			if (temp & 8) {
//				m[i][j][3] = 1;
//			}
//
//		}
//
//	}
//	/*for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			for (int k = 0; k < 4; k++) {
//				cout << m[i][j][k] << " ";
//			}
//			cout << endl;
//		}
//
//	}*/
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (!vis[i][j]) {
//				area = 0;
//				dfs(i, j);
//				cnt++;
//				if (area > max_area) {
//					max_area = area;
//				}
//			}
//		}
//
//	}
//	cout << cnt << endl << max_area;
//	system("pause");
//	return 0;
//}

//1818:红与黑
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int r, c, startx, starty;
//const int maxn = 25;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int cnt = 1;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y;
//};
//void bfs() {
//	queue<Point> q;
//	Point p;
//	p.x = startx;
//	p.y = starty;
//	vis[startx][starty] = 1;//处理起点
//	q.push(p);
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << cnt << endl;
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0&&m[next.x][next.y] == 0) {
//				vis[next.x][next.y] = 1;
//				cnt++;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	int first = 1;
//	while (cin >> c >> r) {
//		if (c == 0 && r == 0) {
//			break;
//		}
//		
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cnt = 1;//第一个点算进去
//		
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				char temp;
//				cin >> temp;
//				if (temp == '.') {
//					m[i][j] = 0;//通路
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//				if (temp == '@') {
//					m[i][j] = 0;
//					startx = i;
//					starty = j;
//				}
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		bfs();
//		/*if (r == 1 && c == 1) {
//			cnt = 1;
//		}*/
//		if (first) {
//			cout << cnt ;
//			first = 0;
//		}
//		else {
//			cout << endl << cnt ;
//		}
//	}
//	system("pause");
//	return 0;
//}

//寻找Nemo ？？思路啊优先队列要在出队时标记vis
//#include<iostream>
//#include<queue>
//#include<cstring>
//#include<math.h>
//#include<algorithm>
//#include<limits.h>
//using namespace std;
//const int maxn = 220;
//int m[maxn][maxn][4];
//int vis[maxn][maxn];
//int tarx, tary, ans;
//int dirx[4] = { 0,1,0,-1 };//北 东 南 西
//int diry[4] = { 1,0,-1,0 };
//int minstep = INT_MAX;
//int maxx, maxy;
//struct  Point
//{
//	int x, y, dir, step = 0;
//	bool operator<(const Point &a)const
//	{
//		return step > a.step;
//	}
//
//};
//int bfs() {
//	priority_queue<Point> q;
//	Point p;
//	p.x = tarx;
//	p.y = tary;
//	p.step = 0;
//	q.push(p);
//	//vis[tarx][tary] = 1;//这里就不能处理起点了 
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();//函数用法是top不是front
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//
//		if (vis[now.x][now.y]) {//优先队列在出栈时标记 因为当2个位置步数相同时 排列顺序是随机的  不确定谁走了一步之后谁更小 所以要都加入
//			continue;
//			//cout << "hhh " << now.x << " " << now.y << endl;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		if (now.x < 1 || now.y >= 200 || now.y < 1 || now.y >= 200) {//一进来就判断 不要等到next再判断 因为可能起点就是终点
//			minstep = now.step;
//			flag = true;
//			//cout << "hhh " << now.x << " " << now.y << endl;
//			break;
//		}
//
//
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			next.dir = i;
//			//cout << next.x << " " << next.y << " " << next.step << endl;
//
//			if (next.x >= 0 && next.x < 200 && next.y >= 0 && next.y < 200 && vis[next.x][next.y] == 0 && m[now.x][now.y][next.dir] != 1) {
//				//cout<<"hhh "<< next.x << " " << next.y << " " << next.step << endl;
//				//vis[next.x][next.y] = 1;
//				if (m[now.x][now.y][next.dir] == 0) {
//					next.step = now.step;
//				}
//				if (m[now.x][now.y][next.dir] == 2) {
//					next.step = now.step + 1;
//				}
//				q.push(next);
//
//			}
//		}
//	}
//	if (flag) {
//		return minstep;
//	}
//	else {
//		return -1;
//
//	}
//}
//int main() {
//	int M, N;
//	int x, y, d, t;
//	while (cin >> M >> N) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		minstep = INT_MAX;
//		if (M == -1 && N == -1) {
//			break;
//		}
//		for (int i = 1; i <= M; i++) {
//			cin >> x >> y >> d >> t;
//			if (d == 0) {//这里方向要搞清楚呀！！！！
//				for (int j = 0; j < t; j++) {
//					m[x + j][y][2] = 1;//南
//					m[x + j][y - 1][0] = 1;//北
//					//cout << x + j << " " << y << " " << 2 << " " << m[x + j][y][2] << endl;
//				}
//			}
//			if (d == 1) {
//				for (int j = 0; j < t; j++) {
//					m[x][y + j][3] = 1;//西
//					m[x - 1][y + j][1] = 1;//东
//				}
//			}
//			maxx = max(maxx, x);//网上说要用这个判断儿子在没在墙内 但是我现在这种写法不用判断也行
//			maxy = max(maxy, y);
//		}
//		//cout << "hhh " << maxx << " " << maxy << endl;
//		for (int i = 1; i <= N; i++) {
//			cin >> x >> y >> d;
//			if (d == 0) {
//
//				m[x][y][2] = 2;//南
//				m[x][y - 1][0] = 2;//北
//
//			}
//			if (d == 1) {
//
//				m[x][y][3] = 2;
//				m[x - 1][y][1] = 2;
//
//			}
//		}
//		/*for (int i = 0; i <= 5; i++) {
//			for (int j = 0; j <= 5; j++) {
//				for (int k = 0; k < 4; k++) {
//					cout << i << " " << j << " :" << m[i][j][k] << " ";
//
//				}
//				cout << endl;
//			}
//			cout << endl;
//		}*/
//		double tarx_temp, tary_temp;
//		cin >> tarx_temp >> tary_temp;
//		tarx = floor(tarx_temp);
//		tary = floor(tary_temp);
//
//		//cout << tarx << " " << tary << endl;
//
//		if (N == 0) {
//			ans = -1;
//		}
//		if (tarx < 1 || tarx >= 200 || tary < 1 || tary >= 200) {
//			ans = 0;
//		}
//		else {
//			ans = bfs();
//		}
//		cout << ans << endl;
//
//
//	}
//	system("pause");
//	return 0;
//}

//Solitaire  双向bfs + 状态压缩
//#include <cstdio>
//#include <cstring>
//#include <algorithm>
//#include <queue>
//#include <map>
//#include <iostream>
//using namespace std;
//
//const int dx[4] = { -1, 1, 0, 0 };
//const int dy[4] = { 0, 0, -1, 1 };
//
//struct Point {
//	int x, y;
//	Point() {}
//	Point(int _x, int _y) {
//		x = _x;
//		y = _y;
//	}
//	bool operator < (const Point &rhs) const {
//		//从左到右，从上到下排序
//		if (x != rhs.x) {
//			return x < rhs.x;
//		}
//		else {
//			return y < rhs.y;
//		}
//	}
//};
//
//struct State {
//	Point p[4];
//	int step;   //记录走了几步
//	State() {
//		for (int i = 0; i < 4; i++) {
//			p[i] = Point();
//		}
//		step = 0;
//	}
//	int getHash() {
//		sort(p, p + 4);     //先排个序
//		int res = 0;
//		for (int i = 0; i < 4; i++) {
//			res |= (p[i].x << (6 * i));     //0.x->[0, 2] 1.x->[6,8] 2.x->[12,14] 3.x->[18,20]
//			res |= (p[i].y << (6 * i + 3)); //0.y->[3, 5] 1.y->[9,11] 2.y->[15,17] 3.y->[21,23]
//		}
//		return res; //这是一个hash值,把4个棋子的状态压缩成一个24bit的数字
//	}
//	int cango() {   //判断4个棋子是否都在棋盘内
//		for (int i = 0; i < 4; i++) {
//			if (p[i].x < 0 || p[i].x >= 8 || p[i].y < 0 || p[i].y >= 8) {
//				return 0;
//			}
//		}
//		return 1;
//	}
//	int cover(int d) {  //判断第d个棋子是否和剩下的3个棋子重合
//		for (int i = 0; i < 4; i++) {
//			if (i == d) continue;
//			if (p[i].x == p[d].x && p[i].y == p[d].y) {
//				return 1;
//			}
//		}
//		return 0;
//	}
//};
//
//int ans;
//
//map<int, int> vis;
//
//State start;
//State tar;
//
//int bfs() {
//	vis.clear();
//	queue<State> one;    //从开始结点出发
//	queue<State> two;    //从结束结点出发
//	one.push(start);
//	two.push(tar);
//	vis[start.getHash()] = 1; //开始状态为1
//	vis[tar.getHash()] = 2;  //结束状态为2
//	while (!one.empty() || !two.empty()) {
//		if (!one.empty()) { //开始队列不为空
//			State tmp = one.front();
//			one.pop();
//			if (tmp.step >= 4) {
//				break;
//			}
//			for (int i = 0; i < 4; i++) {   //移动第i个棋子
//				for (int j = 0; j < 4; j++) {   //朝着第j个方向移动
//					State nxt = tmp;
//					nxt.p[i].x += dx[j];
//					nxt.p[i].y += dy[j];
//					if (!nxt.cango()) {     //有棋子越界了
//						continue;
//					}
//					if (nxt.cover(i)) {     //移动第i个棋子后发现他和剩下的3个棋子重合了，那么需要再把第i个棋子按照第j个方向移动一步
//						nxt.p[i].x += dx[j];
//						nxt.p[i].y += dy[j];
//						if (nxt.cango() && !nxt.cover(i)) { //移动之后这个状态合法
//							int val = nxt.getHash();
//							if (vis[val] == 0) {    //这一种状态未曾到达
//								vis[val] = 1;   //有开始结点出发到达
//								nxt.step++;
//								one.push(nxt);
//							}
//							else if (vis[val] == 2) {   //这一种状态已由结束结点到达,那么可以在8步之内从开始状态到达结束状态
//								return 1;
//							}
//						}
//					}
//					else {  //移动第i个棋子后发现他和剩下的3个棋子不重合了，这个状态合法
//						int val = nxt.getHash();
//						if (vis[val] == 0) {    //这一种状态未曾到达
//							vis[val] = 1;       //有开始结点出发到达
//							nxt.step++;
//							one.push(nxt);
//						}
//						else if (vis[val] == 2) {   //这一种状态已由结束结点到达,那么可以在8步之内从开始状态到达结束状态
//							return 1;
//						}
//					}
//				}
//			}
//		}
//
//		//和上面的思路相同
//		if (!two.empty()) {
//			State tmp = two.front();
//			two.pop();
//			if (tmp.step >= 4) {
//				continue;
//			}
//			for (int i = 0; i < 4; i++) {
//				for (int j = 0; j < 4; j++) {
//					State nxt = tmp;
//					nxt.p[i].x += dx[j];
//					nxt.p[i].y += dy[j];
//					if (!nxt.cango()) {
//						continue;
//					}
//					if (nxt.cover(i)) {
//						nxt.p[i].x += dx[j];
//						nxt.p[i].y += dy[j];
//						if (nxt.cango() && !nxt.cover(i)) {
//							int val = nxt.getHash();
//							if (vis[val] == 0) {
//								vis[val] = 2;
//								nxt.step++;
//								two.push(nxt);
//							}
//							else if (vis[val] == 1) {
//								return 1;
//							}
//						}
//					}
//					else {
//						int val = nxt.getHash();
//						if (vis[val] == 0) {
//							vis[val] = 2;
//							nxt.step++;
//							two.push(nxt);
//						}
//						else if (vis[val] == 1) {
//							return 1;
//						}
//					}
//				}
//			}
//		}
//	}
//	return 0;
//}
//
//int main() {
//	//    freopen("in.txt", "r", stdin);
//	while (cin >> start.p[0].x >> start.p[0].y >> start.p[1].x >> start.p[1].y >> start.p[2].x >> start.p[2].y >> start.p[3].x >> start.p[3].y) {
//		cin >> tar.p[0].x >> tar.p[0].y >> tar.p[1].x >> tar.p[1].y >> tar.p[2].x >> tar.p[2].y >> tar.p[3].x >> tar.p[3].y;
//		start.step = 0;
//		tar.step = 0;
//		for (int i = 0; i < 4; i++) {
//			//把坐标从1~8改到0~7,这样0~7只需要3个bit就能表示了
//			start.p[i].x--;
//			start.p[i].y--;
//			tar.p[i].x--;
//			tar.p[i].y--;
//		}
//		int ans = bfs();
//		if (ans) {
//			printf("YES\n");
//		}
//		else {
//			printf("NO\n");
//		}
//	}
//	return 0;
//}

//Solitaire 自己默写 只有8分
//#include<iostream>
//#include<queue>
//#include<map>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//map<int, int > vis;//双向队列可以只用一个表示 因为不会重合
//struct Point {
//	int x, y;//一个状态下的每个点不用记录步数
//	Point() {}
//
//	bool operator<(const Point &a)const {
//		if (x == a.x) {
//			return y < a.y;
//		}
//		else {
//			return x < a.x;
//		}
//	}
//};
//struct State
//{
//	Point p[4];
//	int step;
//	State() {
//		for (int i = 0; i < 4; i++) {
//			p[i] = Point();//为啥要进行这步操作呢？
//		}
//		step = 0;
//	}
//	int getHash() {//每一位用3bit表示 8个坐标用24bit表示
//		sort(p, p + 4);
//		int res = 0;
//		for (int i = 0; i < 4; i++) {
//			res = res | (p[i].x << (6 * i));
//			res = res | (p[i].y << (6 * i + 3));
//		}
//		return res;
//	}
//	bool check() {
//		for (int i = 0; i < 4; i++) {
//			if (p[i].x < 0 || p[i].x >= 8 || p[i].y < 0 || p[i].y >= 8) {
//				return false;
//			}
//		}
//		return true;
//	}
//	bool cover(int pos) {//判断第i个棋子和其它棋子是否重合
//		for (int i = 0; i < 4; i++) {
//			if (i == pos)continue;
//			if (p[i].x == p[pos].x && p[i].y == p[pos].y) {
//				return true;
//			}
//		}
//		return false;
//	}
//};
//State start;
//State tar;
//int bfs() {
//	queue<State> q1;
//	queue<State> q2;
//	q1.push(start);
//	q2.push(tar);
//	vis[start.getHash()] = 1;
//	//cout << start.getHash() << endl;
//	vis[tar.getHash()] = 2;
//	while (!q1.empty() || !q2.empty()) {
//		if (!q1.empty()) {
//			State now = q1.front();
//			q1.pop();
//			//cout << "hhh" << endl;
//			//for (int i = 0; i < 4; i++) {//因为输入范围是1-8  转化成0-7  可以用3bit来状态压缩
//			//	
//			//	cout <<"q1  "<< now.p[i].x << " " << now.p[i].y <<" "<< now.step << " " << now.getHash() << endl;
//			//}
//			if (now.step >= 4) {
//				break;
//			}
//			for (int i = 0; i < 4; i++) {//遍历四个点
//				for (int j = 0; j < 4; j++) {//遍历四个方向
//					//State next;//这里不能直接这样写 因为没有初始化next的四个Point 后面只对一个Point赋了值 
//					//标准写法如下：
//					State next = now;
//					next.p[i].x += dirx[j];
//					next.p[i].y += diry[j];
//					//for (int i = 0; i < 4; i++) {//因为输入范围是1-8  转化成0-7  可以用3bit来状态压缩
//
//					//	cout << "q1  " << next.p[i].x << " " << next.p[i].y << " " << next.step << endl;
//					//}
//					if (next.check()) {//没有越界
//						//cout << "hhh" << endl;
//						if (!next.cover(i)) {
//							if (vis[next.getHash()] == 0) {
//								vis[next.getHash()] = 1;
//								next.step += 1;
//								q1.push(next);
//							}
//							else {
//								if (vis[next.getHash()] == 2) {
//									return 1;
//								}
//							}
//						}
//						else {
//							next.p[i].x += dirx[j];
//							next.p[i].y += diry[j];
//							if (!next.cover(i) && next.check()) {//走了一步又要check！！！
//								if (vis[next.getHash()] == 0) {
//									vis[next.getHash()] = 1;
//									next.step += 1;
//									q1.push(next);
//								}
//								else {
//									if (vis[next.getHash()] == 2) {
//										return 1;
//									}
//								}
//							}
//						}
//					}
//
//				}
//			}
//		}
//		if (!q2.empty()) {
//			//cout << "hhh" << endl;
//			State now = q2.front();
//			//for (int i = 0; i < 4; i++) {//因为输入范围是1-8  转化成0-7  可以用3bit来状态压缩
//
//			//	cout << "q2  " << now.p[i].x << " " << now.p[i].y << " " << now.step <<" "<<now.getHash()<< endl;
//			//}
//			q2.pop();
//			if (now.step >= 4) {
//				break;
//			}
//			for (int i = 0; i < 4; i++) {//遍历四个点
//				for (int j = 0; j < 4; j++) {//遍历四个方向
//					State next = now;
//					next.p[i].x += dirx[j];
//					next.p[i].y += diry[j];
//					if (next.check()) {//没有越界
//						if (!next.cover(i)) {
//							if (vis[next.getHash()] == 0) {
//								vis[next.getHash()] = 2;
//								next.step += 1;
//								q2.push(next);
//							}
//							else {
//								if (vis[next.getHash()] == 1) {
//									return 1;
//								}
//							}
//						}
//						else {
//							next.p[i].x += dirx[j];
//							next.p[i].y += diry[j];
//							if (!next.cover(i) && next.check()) {//走了一步只有又要check！！！
//								if (vis[next.getHash()] == 0) {
//									vis[next.getHash()] = 2;
//									next.step += 1;
//									q2.push(next);
//								}
//								else {
//									if (vis[next.getHash()] == 1) {
//										return 1;
//									}
//								}
//							}
//						}
//					}
//
//				}
//			}
//		}
//	}
//	return 0;
//}
//int main() {
//	while (cin >> start.p[0].x >> start.p[0].y >> start.p[1].x >> start.p[1].y >> start.p[2].x >> start.p[2].y >> start.p[3].x >> start.p[3].y) {
//		cin >> tar.p[0].x >> tar.p[0].y >> tar.p[1].x >> tar.p[1].y >> tar.p[2].x >> tar.p[2].y >> tar.p[3].x >> tar.p[3].y;
//		for (int i = 0; i < 4; i++) {//因为输入范围是1-8  转化成0-7  可以用3bit来状态压缩
//			start.p[i].x--;
//			start.p[i].y--;
//			tar.p[i].x--;
//			tar.p[i].y--;
//			//cout << tar.p[i].x << " " << tar.p[i].y << endl;
//		}
//		int ans = bfs();
//		if (ans) {
//			cout << "YES";
//		}
//		else {
//			cout << "NO";
//		}
//	}
//
//	system("pause");
//	return 0;
//}


//Pots
//#include<iostream>
//#include<queue>
//#include<vector>
//#include<cstring>	
//using namespace std;
//int a, b, tar;
//const int maxn = 105;
//int vis[maxn][maxn];
//struct Point
//{
//	int x, y;
//	vector<int> v;
//};
//void bfs() {
//	Point first;
//	first.x = 0;
//	first.y = 0;
//	queue<Point> q;
//	q.push(first);
//	vis[first.x][first.y] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		//cout << now.x << " " << now.y << " "<< endl;
//		q.pop();
//		if (now.x == tar || now.y == tar) {
//			cout << now.v.size() << endl;
//			for (auto itr = now.v.begin(); itr != now.v.end(); itr++) {
//				if (*itr == 0) {
//					cout << "FILL(1)" << endl;
//				}
//				if (*itr == 1) {
//					cout << "FILL(2)" << endl;
//				}
//				if (*itr == 2) {
//					cout << "DROP(1)" << endl;
//				}
//				if (*itr == 3) {
//					cout << "DROP(2)" << endl;
//				}
//				if (*itr == 4) {
//					cout << "POUR(1,2)" << endl;
//				}
//				if (*itr == 5) {
//					cout << "POUR(2,1)" << endl;
//				}
//			}
//			return;
//		}
//		for (int i = 0; i < 6; i++) {
//			Point next = now;
//			if (i == 0) {//装满第一个杯子
//				//if (next.x < a) {//注释掉的条件可要可不要
//					next.x = a;
//					if (vis[next.x][next.y] == 0) {
//						vis[next.x][next.y] = 1;
//						next.v.push_back(i);
//						q.push(next);
//					}
//				//}
//			}
//			if (i == 1) {//装满第二个杯子
//				//if (next.y < b) {
//					next.y = b;
//					if (vis[next.x][next.y] == 0) {
//						vis[next.x][next.y] = 1;
//						next.v.push_back(i);
//						q.push(next);
//					}
//				//}
//			}
//			if (i == 2) {//清空第一个杯子
//			//	if (next.x != 0) {
//					next.x = 0;
//					if (vis[next.x][next.y] == 0) {
//						vis[next.x][next.y] = 1;
//						next.v.push_back(i);
//						q.push(next);
//					}
//			//	}
//			}
//			if (i == 3) {//清空第2个杯子
//				//if (next.y != 0) {
//					next.y = 0;
//					if (vis[next.x][next.y] == 0) {
//						vis[next.x][next.y] = 1;
//						next.v.push_back(i);
//						q.push(next);
//					}
//				//}
//			}
//			if (i == 4) {//把第一个杯子的水倒进第二个杯子
//				//if (next.x > 0 && next.y < b) {
//					if (b - next.y >= next.x) {//把第一个杯子的水全部倒进第二个杯子
//						int temp = next.x;
//						next.x = 0;
//						next.y = next.y + temp;
//						if (vis[next.x][next.y] == 0) {
//							vis[next.x][next.y] = 1;
//							next.v.push_back(i);
//							q.push(next);
//						}
//					}
//					else {
//						int temp = next.y;
//						next.y = b;
//						next.x = next.x - (b - temp);
//						if (vis[next.x][next.y] == 0) {
//							vis[next.x][next.y] = 1;
//							next.v.push_back(i);
//							q.push(next);
//						}
//					}
//			//	}
//			}
//			if (i == 5) {//把第2个杯子的水倒进第1个杯子
//				//if (next.y > 0 && next.x < a) {
//					if (a - next.x >= next.y) {//把第2个杯子的水全部倒进第1个杯子
//						int temp = next.y;
//						next.y = 0;
//						next.x = next.x + temp;
//						if (vis[next.x][next.y] == 0) {
//							vis[next.x][next.y] = 1;
//							next.v.push_back(i);
//							q.push(next);
//						}
//					}
//					else {
//						int temp = next.x;
//						next.x = a;
//						next.y = next.y - (a - temp);
//						if (vis[next.x][next.y] == 0) {
//							vis[next.x][next.y] = 1;
//							next.v.push_back(i);
//							q.push(next);
//						}
//					}
//				//}
//
//			}
//		}
//	}
//	cout << "impossible" << endl;
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	cin >> a >> b >> tar;
//	bfs();
//	system("pause");
//	return 0;
//}

//仙岛求药
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int r, c,startx,starty,tarx,tary;
//const int maxn = 25;
//int m[maxn][maxn],vis[maxn][maxn];
//int ans;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, step;
//	bool operator < (const Point& a) const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = startx;
//	start.y = starty;
//	start.step = 0;//初始化为0
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		if (now.x == tarx && now.y == tary) {
//			flag = true;
//			 ans = now.step;
//			
//		}
//		for (int i = 0; i < 4; i++)
//		{
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//	while (cin >> r >> c) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		if (r == 0 && c == 0) {
//			break;
//		}
//		char temp;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> temp;
//				if (temp == '@') {
//					startx = i;
//					starty = j;
//					m[i][j] = 0;
//				}
//				if (temp == '*') {
//					tarx = i;
//					tary = j;
//					m[i][j] = 0;
//				}
//				if (temp == '.') {
//					m[i][j] = 0;
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//			}
//		}
//		bfs();
//	}
//	system("pause");
//	return 0;
//}

//走迷宫
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//const int maxn = 45;
//int m[maxn][maxn], vis[maxn][maxn];
//int r, c;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = 1;
//	start.y = 1;
//	start.step = 1;
//	priority_queue<Point> q;
//	q.push(start);
//	int ans;
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		if (now.x == r && now.y == c) {
//			flag = true;
//			ans = now.step;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++)
//		{
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	cin >> r >> c;
//	char temp;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> temp;
//			if (temp == '.') {
//				m[i][j] = 0;
//			}
//			if (temp == '#') {
//				m[i][j] = 1;
//			}
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}


//抓住那头牛
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//const int maxn = 200020;
//int vis[maxn];
//int beg, tar;
//struct Point
//{
//	int x, step;
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = beg;
//	start.step = 0;
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	int ans;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.step << endl;
//		if (now.x == tar) {
//			flag = true;
//			ans = now.step;
//			break;
//		}
//		if (vis[now.x]) {
//			continue;
//		}
//		else {
//			vis[now.x] = 1;
//		}
//		
//		Point next1;
//		next1.x = now.x + 1;
//		if (next1.x >= 0 && next1.x <= 100000 && vis[next1.x] == 0) {
//			next1.step = now.step + 1;
//			q.push(next1);
//		}
//		Point next2;
//		next2.x = now.x - 1;
//		if (next2.x >= 0 && next2.x <= 100000 && vis[next2.x] == 0) {
//			next2.step = now.step + 1;
//			q.push(next2);
//		}
//		Point next3;
//		next3.x = now.x * 2;
//		if (next3.x >= 0 && next3.x <= 100000 && vis[next3.x] == 0) {
//			next3.step = now.step + 1;
//			q.push(next3);
//		}
//
//	}
//	if (flag) {
//		cout << ans;
//	}
//}
//int main() {
//	memset(vis, 0, sizeof(vis));
//	
//	cin >> beg >> tar;
//	bfs();
//	system("pause");
//	return 0;
//}

//符号三角形  ？？思路 超时
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n;
//const int maxn = 30;
//int m[maxn][maxn],temp[maxn];//m记录第一行  temp记录后面几行
//int cnt;
//int sum;
//void func() {
//	cnt = 0;
//	for (int i = 1; i <= n; i++) {//遍历第一排行
//		cnt += m[1][i];//统计减号个数
//		//if (m[1][i] == 1) {
//		//	
//		//	cnt++;
//		//	//cout << "hh " << cnt << endl;
//		//}
//	}
//	for (int i = 2; i <= n; i++) {//遍历第3-n行
//		for (int j = 1; j <= n - i + 1; j++) {
//			m[i][j] = (m[i - 1][j] + m[i - 1][j + 1]) % 2;//这里用特殊值带入
//			/*if (m[i][j] == 1) {
//				cnt++;
//			}*/
//			cnt += m[i][j];
//		}
//		
//	}
//	if (cnt == n * (n + 1) / 2 / 2) {
//		sum++;
//	}
//}
//void dfs(int x) {
//	if (x > n) {
//		/*for (int i = 1; i <=n; i++)
//		{
//			cout << m[1][i] << " ";
//		}
//		cout << endl;*/
//		
//		func();
//		return;
//	}
//	for (int i = 0; i < 2; i++) {//0+ 1-
//		m[1][x] = i;
//		dfs(x + 1);//这里实际上是回溯了 因为不需要恢复现场 所以没有代码上的体现
//	}
//}
//int main() {
//	while (cin >> n) {
//		memset(m, 0, sizeof(m));
//		cnt = 0;
//		sum = 0;
//		if (n == 0) {
//			break;
//		}
//		if ((n*(n + 1) / 2) % 2 != 0) {//先判断总数是否是奇数
//			cout << n << " " << 0 << endl;;
//		}
//		else {
//			dfs(1);
//			cout << n << " " << sum << endl;;
//		}
//	}
//	
//	system("pause");
//	return 0;
//}

//棋盘问题 ？？ 思路同八皇后 
//#include<iostream>
//#include<cstring>
//using namespace std;
//int n, k;
//const int maxn = 20;
//char m[maxn][maxn];
//int vis[maxn];
//int cnt = 0;
//void dfs(int x, int y) {//在x及x之后的层中放第y枚棋子
//	if (y >= k) {//这里判断是否用完步数
//		cnt++;
//		return;
//	}
//	for (int i = x; i < n; i++) {//这里要从x开始找之后的层  而不是从1开始
//		for (int j = 0; j < n; j++) {
//
//			if (m[i][j] == '#' && vis[j] == 0) {
//				vis[j] = 1;
//				dfs(i + 1, y + 1);//这里传进去的参数是i+1  不是x+1
//				vis[j] = 0;
//			}
//		}
//	}
//	return;
//}
//int main() {
//
//	while (cin >> n >> k) {
//		
//		if (n == -1 && k == -1) {
//			break;
//		}
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		
//		//for (int i = 0; i < n; i++) {
//		//	for (int j = 0; j < n; j++) {
//		//		cin >> m[i][j];
//		//		/*if (temp == '.') {
//		//			m[i][j] = 1;
//		//		}
//		//		if (temp == '#') {
//		//			m[i][j] = 0;
//		//		}*/
//		//	}
//		//}
//		for (int i = 0; i<n; i++)
//			cin >> m[i];//这样写 默认是从0开始的
//		cnt = 0;
//		dfs(0, 0);
//		cout << cnt << endl;
//	}
//	//system("pause");
//	return 0;
//}

//拯救行动
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, startx, starty, tarx, tary;
//const int maxn = 220;
//char m[maxn][maxn];
//char vis[maxn][maxn];//这里vis开的是int
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//int first = 1;//用于控制输出endl
//struct Point
//{
//	int x, y, step;
//	Point(int _x, int _y, int _step) :x(_x), y(_y), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y] == 0) {//仔细检查这一行  1和0 是否取等不要搞错了
//				if (m[next.x][next.y] == '@') {
//					next.step = now.step + 1;
//				}
//				if (m[next.x][next.y] == 'a') {//这里要考虑公主呀！！！！
//					next.step = now.step + 1;
//				}
//				if (m[next.x][next.y] == 'x') {
//					next.step = now.step + 2;
//				}
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		if (first) {
//			cout << ans;
//			first = 0;
//		}
//		else {
//			cout << endl << ans;
//
//		}
//	}
//	else {
//		if (first) {
//			cout << "Impossible";
//			first = 0;
//		}
//		else {
//			cout << endl << "Impossible";
//
//		}
//	}
//}
//int main() {
//	int num;
//	cin >> num;
//
//	for (int i = 0; i < num; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'r') {
//					startx = i;
//					starty = j;
//				}
//				if (m[i][j] == 'a') {
//					tarx = i;
//					tary = j;
//				}
//			}
//		}
//		//cout << startx << " " << starty << " " << tarx << " " << tary << endl;
//		bfs();
//	}
//	system("pause");
//	return 0;
//}

//鸣人和佐助 之前vis数组判断除了问题 
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, t, startx, starty, tarx, tary;
//const int maxn = 220;
//char m[maxn][maxn];
//int vis[maxn][maxn][15];//用x,y,t唯一表示一种状态 因为相同的x,y可能拥有的钥匙不一样 不能因为前一种情况没有
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//struct Point
//{
//	int x, y, t_num, step;//这里把t_num加进去 由Point维护 因为下一步的t_num是有上一步的得到的 并且不同走法的t_num没有联系
//	Point(int _x, int _y, int _t_num, int _step) :x(_x), y(_y), t_num(_t_num), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, t, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " <<now.t_num<<" "<< now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y][now.t_num]) {//重点
//			continue;
//		}
//		else {
//			vis[now.x][now.y][now.t_num] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			//应该先判断是否是# 下面代码是错的
//			/*if (now.t_num == 0) {
//				if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y][now.t_num] == 0) {
//					next.step = now.step + 1;
//					next.t_num = now.t_num;
//					q.push(next);
//				}
//			}
//			else {
//
//				if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y][now.t_num] == 0) {
//					if (m[next.x][next.y] == '#') {
//						next.t_num = now.t_num - 1;//这里减了之后还要再判断是否这种状态走过  因为 vis数组都是判断更新之后的值是否有重复
//					}
//					else {
//						next.t_num = now.t_num;
//					}
//					next.step = now.step + 1;
//					q.push(next);
//				}
//			}*/
//			//此处应该判断走了之后的状态是否可以
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] == '#' &&now.t_num != 0 && vis[next.x][next.y][now.t_num - 1] == 0) {
//				next.step = now.step + 1;
//				next.t_num = now.t_num - 1;
//				q.push(next);
//			}
//			else if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#'&& vis[next.x][next.y][now.t_num] == 0) {
//				next.step = now.step + 1;
//				next.t_num = now.t_num;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << -1 << endl;
//	}
//}
//int main() {
//
//
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	ans = 0;
//	cin >> r >> c >> t;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//			if (m[i][j] == '@') {
//				startx = i;
//				starty = j;
//			}
//			if (m[i][j] == '+') {
//				tarx = i;
//				tary = j;
//			}
//		}
//	}
//	bfs();
//
//	system("pause");
//	return 0;
//}

//走出迷宫
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int r, c, startx, starty, tarx, tary;
//const int maxn = 110;
//char m[maxn][maxn];
//char vis[maxn][maxn];//这里vis开的是int
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans;
//int first = 1;//用于控制输出endl
//struct Point
//{
//	int x, y, step;
//	Point(int _x, int _y, int _step) :x(_x), y(_y), step(_step) {};
//	Point() {};
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start(startx, starty, 0);
//	priority_queue<Point> q;
//	q.push(start);
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && m[next.x][next.y] != '#' &&vis[next.x][next.y] == 0) {//仔细检查这一行  1和0 是否取等不要搞错了
//				next.step = now.step + 1;
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		if (first) {
//			cout << ans;
//			first = 0;
//		}
//		else {
//			cout << endl << ans;
//
//		}
//	}
//	else {
//		if (first) {
//			cout << "Impossible";
//			first = 0;
//		}
//		else {
//			cout << endl << "Impossible";
//
//		}
//	}
//}
//int main() {
//	
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> m[i][j];
//				if (m[i][j] == 'S') {
//					startx = i;
//					starty = j;
//				}
//				if (m[i][j] == 'T') {
//					tarx = i;
//					tary = j;
//				}
//			}
//		}
//		//cout << startx << " " << starty << " " << tarx << " " << tary << endl;
//		bfs();
//	
//	system("pause");
//	return 0;
//}

//放苹果 ??思路 dp
//#include<iostream>
//#include<cstring>
//using namespace std;
//int apple, plate;
//int dp(int a, int p) {
//	if (a == 1 || a == 0 || p == 1) {//这里要判断a==0的情况
//		return 1;
//	}
//	if (a < p) {
//		return dp(a, a);
//	}
//	else if (a >= p) {
//		return dp(a - p, p) + dp(a, p - 1);
//	}
//}
//int main() {
//	int t;
//	cin >> t;
//	for (int i = 0; i < t; i++) {
//		cin >> apple >> plate;
//		int ans = dp(apple, plate);
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//迷宫问题 bfs+记录路径  不用优先队列 并且在进队的时候置vis
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int m[10][10];
//int vis[10][10];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//const int maxn = 1000;
//
//struct Point {
//	int x, y, step;
//	//bool operator<(const Point &a)const {
//	//	return step > a.step;
//	//}
//};
//Point trace[maxn][maxn];
//Point ans[maxn];
//void track(int x, int y) {
//	//cout << "hhh" << "(" << trace[2][4].x << ", " << trace[2][4].y << ")" << endl;
//	int k = 0,a,b;
//	
//	while (x != 0 || y != 0) {//这里本来是当x == 0 && y == 0 停止  取逆
//		a = x;//这里要先记录x,y的值 因为后面更新是先更新x， 再更新y 
//		b = y;
//		ans[k].x = trace[x][y].x;
//		ans[k].y = trace[x][y].y;
//		k++;
//		x = trace[a][b].x;
//		y = trace[a][b].y;
//	}
//	for (int i = k-1; i >= 0; i--) {
//		cout << "(" << ans[i].x << ", " << ans[i].y << ")" << endl;
//	}
//	cout << "(4, 4)" << endl;
//}
//void bfs() {
//	
//	Point start;
//	start.x = 0;
//	start.y = 0;
//	start.step = 0;
//	queue<Point> q;
//	q.push(start);
//	vis[0][0] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == 4 && now.y == 4) {
//			//cout << now.step << endl;
//			track(4, 4);
//			return;
//		}
//
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x < 5 && next.y >= 0 && next.y < 5 && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				vis[next.x][next.y] = 1;
//				next.step = now.step + 1;
//				//cout << next.x << " " << next.y << " " << next.step << endl;
//
//				trace[next.x][next.y].x = now.x;
//				trace[next.x][next.y].y = now.y;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	memset(trace, 0, sizeof(trace));
//	memset(ans, 0, sizeof(ans));
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}

//迷宫问题 优先队列+记录路径 出队再置vis 也可以  因为数据保证有唯一解
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//int m[10][10];
//int vis[10][10];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//const int maxn = 1000;
//
//struct Point {
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//Point trace[maxn][maxn];
//Point ans[maxn];
//void track(int x, int y) {
//	//cout << "hhh" << "(" << trace[2][4].x << ", " << trace[2][4].y << ")" << endl;
//	int k = 0, a, b;
//
//	while (x != 0 || y != 0) {//这里本来是当x == 0 && y == 0 停止  取逆
//		a = x;//这里要先记录x,y的值 因为后面更新是先更新x， 再更新y 
//		b = y;
//		ans[k].x = trace[x][y].x;
//		ans[k].y = trace[x][y].y;
//		k++;
//		x = trace[a][b].x;
//		y = trace[a][b].y;
//	}
//	for (int i = k - 1; i >= 0; i--) {
//		cout << "(" << ans[i].x << ", " << ans[i].y << ")" << endl;
//	}
//	cout << "(4, 4)" << endl;
//}
//void bfs() {
//
//	Point start;
//	start.x = 0;
//	start.y = 0;
//	start.step = 0;
//	queue<Point> q;
//	q.push(start);
//	//vis[0][0] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == 4 && now.y == 4) {
//			//cout << now.step << endl;
//			track(4, 4);
//			return;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 0 && next.x < 5 && next.y >= 0 && next.y < 5 && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				//vis[next.x][next.y] = 1;
//				next.step = now.step + 1;
//				//cout << next.x << " " << next.y << " " << next.step << endl;
//
//				trace[next.x][next.y].x = now.x;
//				trace[next.x][next.y].y = now.y;
//				q.push(next);
//			}
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	memset(trace, 0, sizeof(trace));
//	memset(ans, 0, sizeof(ans));
//	for (int i = 0; i < 5; i++) {
//		for (int j = 0; j < 5; j++) {
//			cin >> m[i][j];
//		}
//	}
//	bfs();
//	system("pause");
//	return 0;
//}

//献给阿尔吉侬的花束
//#include<iostream>
//#include<queue>	
//#include<cstring>
//using namespace std;
//
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//
//const int maxn = 220;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int r, c, startx, starty, tarx, tary, ans;
//
//struct Point {
//	int x, y, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//
//void bfs() {
//
//	Point start;
//	start.x = startx;
//	start.y = starty;
//	start.step = 0;
//	priority_queue<Point> q;
//	q.push(start);
//	//vis[0][0] = 1;
//	bool flag = false;
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		if (now.x == tarx && now.y == tary) {
//			ans = now.step;
//			flag = true;
//			break;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next;
//			next.x = now.x + dirx[i];
//			next.y = now.y + diry[i];
//
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 0) {
//
//				next.step = now.step + 1;
//
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		cout << ans << endl;
//	}
//	else {
//		cout << "oop!" << endl;
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		ans = 0;
//		cin >> r >> c;
//		char temp;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cin >> temp;
//				if (temp == 'S') {
//					m[i][j] = 0;
//					startx = i;
//					starty = j;
//				}
//				if (temp == 'E') {
//					m[i][j] = 0;
//					tarx = i;
//					tary = j;
//				}
//				if (temp == '#') {
//					m[i][j] = 1;
//				}
//				if (temp == '.') {
//					m[i][j] = 0;
//				}
//			}
//		}
//		bfs();
//	}
//
//	system("pause");
//	return 0;
//}

//拯救公主 自己写的  注意要更新step
//#include<iostream>
//#include<queue>
//#include<cstring>
//#include<vector>
//using namespace std;
//const int maxn = 220;
//int m[maxn][maxn];
//int vis[maxn][maxn][100];//vis数组开多大？这个问题取决于有多少种状态 比如5种状态 就是2^6 - 1
//int r, c, k, sx, sy, ex, ey, ans = 0;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, step, state;
//	bool operator< (const Point &a)const {
//		return step > a.step;
//	}
//};
//struct Door
//{
//	int x, y;
//	Door(int _x, int _y) :x(_x), y(_y) {}
//};
//vector<Door> v;
//bool check(int n) {
//	//有k把钥匙相当于有k个1  即（1<<k)-1 最简单的判断方法如下：
//	if (n == (1 << k) - 1) {
//		return true;
//	}
//	else {
//		return false;
//	}
//	//for (int i = 0; i < k; i++) {//k比实际的钥匙编号最大值大一
//
//	//	if ((n & (1 << i)) == 0) {
//	//		return false;
//	//	}
//	//}
//	//return true;
//}
//void bfs() {
//	Point fir;
//	fir.x = sx;
//	fir.y = sy;
//	fir.step = 0;
//	fir.state = 0;
//	priority_queue<Point> q;
//	q.push(fir);
//	while (!q.empty()) {
//		Point now = q.top();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << now.step << " " << now.state << endl;
//		if (now.x == ex && now.y == ey && check(now.state)) {
//			ans = now.step;
//			cout << ans << endl;
//			return;
//		}
//		//cout << "hhh" << endl;
//
//		if (vis[now.x][now.y][now.state]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y][now.state] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			//如果是宝石
//			if (m[next.x][next.y] < k && m[next.x][next.y] >= 0) {//这里是小于k 不是小于4
//				next.state = next.state | (1 << (m[next.x][next.y]));
//				//cout << next.state << endl;
//			}
//			//cout << next.x << " " << next.y << " " << next.step << " " << next.state << endl;
//
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y][next.state] == 0 && m[next.x][next.y] != -2) {//因为这里vis[next.x][next.y][next.state]要判断更新后的state 所以更新钥匙要在这个判断之前
//				if (m[next.x][next.y] != -1) {
//					next.step += 1;
//					q.push(next);
//				}
//				else {
//					//q.push(next);
//					for (auto itr = v.begin(); itr != v.end(); itr++) {
//						//if (next.x != itr->x || next.y != itr->y) {//是不是这里有问题  不能从自己传送到自己 为啥去掉这个判断 就不行呢？
//						next = now;//这一步一定不能少！！！！
//						next.x = itr->x;
//						next.y = itr->y;
//						//cout << "hhh" << endl;
//
//						if (vis[next.x][next.y][next.state] == 0) {
//							next.step += 1;//
//							q.push(next);
//						}
//						//}
//					}
//				}
//			}
//		}
//	}
//	cout << "oop!" << endl;
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		ans = 0;
//		v.clear();
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cin >> r >> c >> k;
//		char temp;
//		for (int j = 1; j <= r; j++) {
//			for (int o = 1; o <= c; o++) {
//				cin >> temp;
//				//0-4 宝石
//				//5 通路
//				//-1 门
//				//-2 墙
//				if (temp == 'S') {
//					m[j][o] = 5;
//					sx = j;
//					sy = o;
//				}
//				if (temp == 'E') {
//					m[j][o] = 5;
//					ex = j;
//					ey = o;
//				}
//				if (temp == '.') {
//					m[j][o] = 5;
//				}
//				if (temp >= '0'&&temp <= '4') {
//					m[j][o] = temp - '0';
//				}
//				if (temp == '#') {
//					m[j][o] = -2;
//				}
//				if (temp == '$') {
//					m[j][o] = -1;
//					Door door(j, o);
//					v.push_back(door);
//				}
//			}
//		}
//		bfs();
//
//	}
//	system("pause");
//	return 0;
//}

//分成互质组  网上答案
//#include <iostream>
//using namespace std;
//
///* 分成互质组
//* 思路:对于每个数，要么把它放到之前的组里，要么单独列成组，dfs解决
//*/
//
//int m[15], s[15], f[15][15], n, result = 0x7f; //m[15]为元素，s[15]为元素属于的集合
//
//int gcd(int x, int y) //判断最大公约数
//{
//	if (y == 0) return x;
//	else return gcd(y, x % y);
//}
//
//void DFS(int pos, int ans) //pos表示当前取到的位置，ans表示有多少个组
//{
//	if (ans >= result) return; //剪枝
//	if (pos > n) {
//		result = ans;
//		return;
//	}
//	for (int i = 1; i <= ans; i++) //枚举每个集合
//	{
//		bool flag = true;
//		for (int j = 1; j < pos; j++) { //如果有m[pos]之前的数属于这个集合且不与m[pos]互质，这个集合不满足要求		
//			if (s[j] == i && f[pos][j] != 1) {
//				flag = false;
//				break;
//			}
//		}
//		if (flag) {//否则，把m[pos]归到这个集合里，搜索下一层
//			s[pos] = i;
//			DFS(pos + 1, ans);
//		}
//	}
//	s[pos] = ans + 1; //或者，m[pos]单独再成立一个集合，搜索下一层
//	DFS(pos + 1, ans + 1);
//}
//
//int main()
//{
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			f[i][j] = gcd(m[i], m[j]);
//			//cout << f[i][j] << " ";
//		}
//		//cout << endl;
//	}
//	s[1] = 1;//第一个元素属于第一个集合
//	DFS(2, 1);//判断2个元素 1个集合
//	cout << result;
//	system("pause");
//	return 0;
//}


//分成互质组 自己默写  代码风格有变化
//#include<iostream>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 15;
//int m[maxn];
//int state[maxn][maxn];
//int group[maxn];
//int n;
//int ans = INT_MAX;
//bool flag = false;
//int gcd(int x, int y) {
//	if (y == 0) {
//		return x;
//	}
//	else {
//		return gcd(y, x%y);
//	}
//}
//void dfs(int pos, int num) {
//	//if (num >= ans) {
//	//	return;//剪枝
//	//}
//	if (flag) {
//		return;
//	}
//	if (pos > n) {
//		//cout << "hhh" << num << endl;
//		flag = true;
//		if (num < ans) {//这里两种写法 第一种在走到底的时候判断谁更小 更新答案 第二种 不用走到底 直接剪枝
//			ans = num;
//		}
//		return;
//	}
//	bool suc;
//	for (int i = 1; i <= num; i++) {//遍历每一种颜色 判断每一种颜色
//		suc = true;//初始置为成功 因为只要有一个失败就是失败 不好判断是不是每个都是成功
//		for (int j = 1; j < pos; j++) {//遍历是否互质
//			if (group[j] == i && state[j][pos] != 1) {// 首先找到第i中颜色的元素j  判断在第i中颜色中 j元素是否和pos元素互质
//				suc = false;
//				break;
//			}
//		}
//		if (suc) {//如果成功
//			group[pos] = i;
//			dfs(pos + 1, num);//继续搜索下去 如果能一直走到底 就能走到pos>n 就不会走到下一段代码
//		}
//	}
//
//	if (!suc) {//如果没有成功
//		group[pos] = num + 1;
//		dfs(pos + 1, num + 1);
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(state, 0, sizeof(state));
//	memset(group, 0, sizeof(group));
//
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			state[i][j] = gcd(m[i], m[j]);//如果state[i][j]== 1 则说明m[i] m[j]互质
//		}
//	}
//	group[1] = 1;
//	dfs(2, 1);
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//	Saving Tang Monk  标答
//#include <cstdio>
//#include <cstring>
//#include <queue>
//#include <algorithm>
//#include <cctype>
//#include<iostream>
//using namespace std;
//
//const int N = 100 + 5;
//
//const int dx[4] = { 0, 0, -1, 1 };
//const int dy[4] = { -1, 1, 0, 0 };
//
//struct Node {
//	int x, y;
//	int step;//step
//	int s;
//	int key;//keys
//};
//
//int n, m;
//int sx, sy;
//int ex, ey;
//
//queue<Node> que;
//
//char mp[N][N];
//int dp[N][N][10][33];
//
//inline bool check(int x, int y) {
//	if (x < 0 || x >= n) return false;
//	if (y < 0 || y >= n) return false;
//	if (mp[y][x] == '#') return false;
//	return true;
//}
//
//int solve() {
//	Node tmp;
//	while (!que.empty()) que.pop();//清空队列
//	memset(dp, -1, sizeof(dp));
//	tmp.x = sx;
//	tmp.y = sy;
//	tmp.s = 0;
//	tmp.key = 0;
//	tmp.step = 0;
//	que.push(tmp);
//	dp[sx][sy][0][0] = 0;
//	while (!que.empty()) {
//		Node cur = que.front();
//		que.pop();
//		//        printf("x:%d y:%d k:%d s:%d v:%d\n", cur.x, cur.y, cur.k, cur.s, cur.v);
//		if (cur.x == ex && cur.y == ey && cur.key == m) {
//			return cur.step;
//		}
//		if (isalpha(mp[cur.y][cur.x])) {//如果是字母就意味着是蛇
//			int k = mp[cur.y][cur.x] - 'A';
//			if ((cur.s & (1 << k)) == 0) {
//				tmp = cur;
//				tmp.step++;
//				tmp.s |= (1 << k);
//				if (dp[tmp.x][tmp.y][tmp.key][tmp.s] == -1) {
//					dp[tmp.x][tmp.y][tmp.key][tmp.s] = tmp.step;
//					que.push(tmp);
//				}
//				continue;
//			}
//		}
//		for (int i = 0; i < 4; i++) {
//			tmp = cur;
//			tmp.x += dx[i];
//			tmp.y += dy[i];
//			if (check(tmp.x, tmp.y)) {
//				tmp.step++;
//				if (isdigit(mp[tmp.y][tmp.x])) {
//					int k = mp[tmp.y][tmp.x] - '0';
//					if (tmp.key == k - 1) {
//						tmp.key = k;
//					}
//				}
//				if (dp[tmp.x][tmp.y][tmp.key][tmp.s] == -1) {
//					dp[tmp.x][tmp.y][tmp.key][tmp.s] = tmp.step;
//					que.push(tmp);
//				}
//			}
//		}
//	}
//	return -1;
//}
//
//int main() {
//	while (cin>>n>>m) {
//		if (n == 0 && m == 0) {
//			break;
//		}
//		for (int i = 0; i < n; i++) {
//			cin>>mp[i];
//		}
//		int cnt = 0;
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//				if (mp[i][j] == 'T') {
//					ex = j;
//					ey = i;
//					mp[i][j] = '.';
//				}
//				if (mp[i][j] == 'K') {
//					sx = j;
//					sy = i;
//					mp[i][j] = '.';
//				}
//				if (mp[i][j] == 'S') {
//					mp[i][j] = 'A' + cnt;
//					cnt++;
//				}
//			}
//		}
//		/*for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//				cout << mp[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		int ans = solve();
//		if (ans == -1) {
//			printf("impossible\n");
//		}
//		else {
//			printf("%d\n", ans);
//		}
//	}
//
//	return 0;
//}


//Saving Tang Monk
//#include<iostream>
//#include<queue>
//#include<cstring>
//using namespace std;
//int r, key_num, sx, sy, ex, ey, ans = 0;
//int cnt = 0;//统计蛇的个数
//const int maxn = 110;
//char m[maxn][maxn];
//int vis[maxn][maxn][10][33];//为什么蛇的状态的33？
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y, key, state, step;
//	bool operator<(const Point &a)const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point first;
//	first.x = sx;
//	first.y = sy;
//	first.key = 0;//钥匙是从1开始计数
//	first.state = 0;//所有蛇都没有被杀掉
//	first.step = 0;
//	priority_queue<Point>q;
//	q.push(first);
//	while (!q.empty()) {
//		Point now = q.top();
//		cout << now.x << " " << now.y << " " << now.key << " " << now.state << " " << now.step << endl;
//		q.pop();
//		if (now.x == ex && now.y == ey&& now.key  == key_num) {
//			ans = now.step;
//			cout << ans << endl;
//			return;
//		}
//		if (vis[now.x][now.y][now.key][now.state]) {
//			continue;
//		}
//		else {
//			vis[now.x][now.y][now.key][now.state] = 1;
//		}
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= r && m[next.x][next.y] != '#'&&vis[next.x][next.y][next.key][next.state] == 0) {
//				//cout << m[next.x][next.y] << endl;
//				if (isalpha(m[next.x][next.y])) {//如果是蛇
//
//					int s_num = m[next.x][next.y] - 'A';
//					if ((next.state&(1 << s_num)) == 0) {//并且没有被杀死  这里一定要加括号 否则会出错
//						next.state = next.state | (1 << s_num);
//						next.step += 2;
//						q.push(next);
//					}
//					else {//蛇已死
//						next.step += 1;
//						q.push(next);
//					}
//				}
//				else if (isdigit(m[next.x][next.y])) {//如果是钥匙
//
//					int k_num = m[next.x][next.y] - '0';
//					//cout << k_num<<" "<<now.key+1<< endl;
//
//					if (next.key + 1 == k_num) {//可以捡起来
//						next.key += 1;
//						next.step += 1;
//						q.push(next);
//					}
//				}
//				else if(m[next.x][next.y] == '.'){
//
//					next.step += 1;
//					q.push(next);
//				}
//			}
//		}
//	}
//	cout << "impossible" << endl;
//}
//int main() {
//	while (cin >> r >> key_num) {
//		if (r == 0 && key_num == 0) {
//			break;
//		}
//		char temp;
//		memset(vis, 0, sizeof(vis));
//		cnt = 0;
//		ans = 0;
//		for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= r; j++) {
//				cin >> temp;
//				//通路 -1
//				if (temp == 'K') {
//					sx = i;
//					sy = j;
//					m[i][j] = '.';
//				}
//				if (temp == 'T') {
//					ex = i;
//					ey = j;
//					m[i][j] = '.';
//				}
//				if (temp == 'S') {
//					m[i][j] = cnt + 'A';
//					cnt++;
//				}
//				else {
//					m[i][j] = temp;//这一步不能少
//				}
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= r; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		bfs();
//	}
//}

//Saving Tang Monk  标答
//#include <cstdio>
//#include <cstring>
//#include <queue>
//#include <algorithm>
//#include <cctype>
//using namespace std;
//
//const int N = 100 + 5;
//
//const int dx[4] = { 0, 0, -1, 1 };
//const int dy[4] = { -1, 1, 0, 0 };
//
//struct Node {
//	int x, y;
//	int v;
//	int s;
//	int k;
//};
//
//int n, m;
//int sx, sy;
//int ex, ey;
//
//queue<Node> que;
//
//char mp[N][N];
//int dp[N][N][10][33];
//
//inline bool check(int x, int y) {
//	if (x < 0 || x >= n) return false;
//	if (y < 0 || y >= n) return false;
//	if (mp[y][x] == '#') return false;
//	return true;
//}
//
//int solve() {
//	Node tmp;
//	while (!que.empty()) que.pop();
//	memset(dp, -1, sizeof(dp));//初始化成-1
//	tmp.x = sx;
//	tmp.y = sy;
//	tmp.s = 0;
//	tmp.k = 0;
//	tmp.v = 0;
//	que.push(tmp);
//	dp[sx][sy][0][0] = 0;//四维状态是指：横坐标 纵坐标 目前取得的钥匙最大号码数  维护蛇的状态 （比如有5条蛇 则00000表示蛇都是活着 11111表示5条蛇都被杀死）
//	while (!que.empty()) {
//		Node cur = que.front();
//		que.pop();
//		//        printf("x:%d y:%d k:%d s:%d v:%d\n", cur.x, cur.y, cur.k, cur.s, cur.v);
//		if (cur.x == ex && cur.y == ey && cur.k == m) {
//			return cur.v;
//		}
//		//没懂为什么要把是蛇单独拿出来判断？  这里是相当于没走之前就判断当前的
//		if (isalpha(mp[cur.y][cur.x])) {//如果是蛇
//			int k = mp[cur.y][cur.x] - 'A';//得到蛇的标号 0-4
//			/*判断第一条是否被杀死
//			00000
//			&
//			00001
//			=
//			00000*/
//			if ((cur.s & (1 << k)) == 0) {//第k条蛇没被杀死
//				tmp = cur;
//				tmp.v++;
//				tmp.s |= (1 << k);//把第k条蛇杀死
//				if (dp[tmp.x][tmp.y][tmp.k][tmp.s] == -1) {//每次更新状态之后都要检查是否被走过
//					dp[tmp.x][tmp.y][tmp.k][tmp.s] = tmp.v;
//					que.push(tmp);
//				}
//				continue;//因为这是普通队列 所以每次只能更新一步才能保证出栈顺序正确  也可以用优先队列
//			}
//		}
//		for (int i = 0; i < 4; i++) {//朝四个方向走
//			tmp = cur;
//			tmp.x += dx[i];
//			tmp.y += dy[i];
//			if (check(tmp.x, tmp.y)) {
//				tmp.v++;
//				if (isdigit(mp[tmp.y][tmp.x])) {//如果是钥匙
//					int k = mp[tmp.y][tmp.x] - '0';
//					if (tmp.k == k - 1) {//判断前面k-1把钥匙是否集齐
//						tmp.k = k;
//					}
//				}
//				if (dp[tmp.x][tmp.y][tmp.k][tmp.s] == -1) {//更新状态后都要再判断是否重新走过！！！！！！
//					dp[tmp.x][tmp.y][tmp.k][tmp.s] = tmp.v;
//					que.push(tmp);
//				}
//			}
//		}
//	}
//	return -1;
//}
//
//int main() {
//	while (~scanf("%d %d", &n, &m) && n + m) {
//		for (int i = 0; i < n; i++) {
//			scanf("%s", mp[i]);
//		}
//		int cnt = 0;
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//
//				if (mp[i][j] == 'T') {
//					ex = j;
//					ey = i;
//					mp[i][j] = '.';
//				}
//				if (mp[i][j] == 'K') {
//					sx = j;
//					sy = i;
//					mp[i][j] = '.';
//				}
//				if (mp[i][j] == 'S') {//如果是蛇  对蛇进行编号A——E
//					mp[i][j] = 'A' + cnt;
//					cnt++;
//				}
//			}
//		}
//		int ans = solve();
//		if (ans == -1) {
//			printf("impossible\n");
//		}
//		else {
//			printf("%d\n", ans);
//		}
//	}
//
//	return 0;
//}
//马走日  每步直一格再斜一格 8个方向
//#include<iostream>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 15;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int r, c, startx, starty, cnt;
//int dirx[8] = { -2 ,-2,-1,-1,1,1,2,2 };
//int diry[8] = { -1,1 ,-2,2,2,-2,-1,1 };
////int dirx[8] = { -2,-1,1,2,2,1,-1,-2 };
////int diry[8] = { 1,2,2,1,-1,-2,-2,-1 };
//void dfs(int x, int y, int step) {
//	if (step >= r * c) {
//		cnt++;
//	}
//	for (int i = 0; i < 8; i++) {
//		int nextx = x + dirx[i];
//		int nexty = y + diry[i];
//		if (vis[nextx][nexty] == 0 && nextx >= 0 && nextx < r&&nexty >= 0 && nexty < c) {
//			//cout << nextx << " " << nexty << " " << step + 1 << " " << cnt << endl;
//			vis[nextx][nexty] = 1;
//			dfs(nextx, nexty, step + 1);
//			vis[nextx][nexty] = 0;
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		cnt = 0;
//		cin >> r >> c >> startx >> starty;
//		vis[startx][starty] = 1;//一定记得初始化第一步
//		dfs(startx, starty, 1);
//		cout << cnt << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//单词接龙  ??思路 dfs  这个代码有两处错误  
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<climits>
//using namespace std;
//const int maxn = 25;
//int maxlen = INT_MIN;
////int flag = 0;
//int n;
//struct letterstr
//{
//	string s;
//	int len;
//	int t;
//};
//letterstr str[maxn];
//void dfs(int pos, int cnt) {//pos是指龙的最后一个单词  cnt是长度
//	/*if (flag) {//回溯的时候 如果找到了一条路 还要遍历完所有路 所以不加这个 如果加了 就是直走一条路
//		return;
//	}*/
//
//	for (int i = 1; i <= n; i++) {//遍历每一个单词
//		if (str[i].t < 2) {//如果被访问两次以内 则继续
//			for (int j = 0; j < str[pos].len; j++) {//遍历pos的所有字母 和每一个单词的第一个字母比对
//网上AC的代码都是和整个字符串来比较的，而不是仅仅和上一个代码来比较
/// act -> tr -> ctrg
///你是考虑 actr -> ctrg  = actrg
///你还是考虑 tr -> ctrg  = XXXXX
//				if (str[pos].s[j] == str[i].s[0]) {//如果pos的单词的某一个字母和第i个单词的首字母匹配成功 则继续比对
//					int k = 1;//用于遍历第i个单词的字母 因为之前已经判断过了0  所以从1开始
//					bool suc = true;
///这边没有考虑 k = str[i].len的情况，就是其实第i个字符换是不能枚举的
///string -> tri 这个不能连接
//					for (int q = j + 1; q < str[pos].len&&k < str[i].len; q++, k++) {
//						if (str[pos].s[q] != str[i].s[k]) {
//							suc = false;
//							break;
//						}
//					}
//					if (suc) {
//						str[i].t = str[i].t + 1;
//						cout << str[i].s <<" "<< cnt + str[i].len - k<< endl;
//						
//						dfs(i, cnt + str[i].len - k);//这里是从i开始 不是从pos+1开始
//						str[i].t = str[i].t - 1;
//					}
//				}
//			}
//		}
//	}
//	if (cnt > maxlen) {//注意退出条件 放在最后
//		maxlen = cnt;
//		//flag = 1;
//		return;
//		
//	}
//}
//int main() {
//	//cout << "hhh" << maxlen << endl;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> str[i].s;
//		str[i].len = str[i].s.length();
//		str[i].t = 0;
//		//cout << str[i].s << " " << str[i].len << endl;
//	}
//	string start;
//	cin >> start;
//	str[0].s = start;
//	str[0].len = start.length();
//	dfs(0, start.length());//把开头字母也加进去处理
//	cout << maxlen << endl;
//	system("pause");
//	return 0;
//}


//单词接龙  修复版
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<climits>
//using namespace std;
//const int maxn = 25;
//
//int maxlen = INT_MIN;
////int flag = 0;
//int n;
//struct wordsstr
//{
//	string s;
//	int len;
//	int t;
//};
//wordsstr str[maxn];
//void dfs(string now) {//now是指整条龙 
//	int len = now.length();
//	//cout << now << " " << len << endl;
//	if (len > maxlen) {
//		maxlen = len;
//	}
//	for (int i = 1; i <= n; i++) {//遍历每个单词
//		if (str[i].t < 2) {//访问次数不能超过2   这里也可以改成if (str[i].t >=2	) continue;
//
//			for (int j = 1; j < str[i].len && (len - j) >= 0; j++) {//假设重合部分第i个单词的0-j  ！！(len - j) >= 0 因为可能加进去的单词比龙还长
//				bool suc = true;
//
//				for (int k = 0; k < j; k++) {//只要有不匹配的 即失败
//					if (now[len - j + k] != str[i].s[k]) {
//						suc = false;
//						break;
//					}
//				}
//				if (suc) {
//					string next = now;
//					for (int q = j; q < str[i].len; q++) {//更新龙
//						next = next + str[i].s[q];
//					}
//					str[i].t = str[i].t + 1;
//					dfs(next);
//					str[i].t = str[i].t - 1;//回溯
//				}
//			}
//		}
//	}
//}
//int main() {
//	//cout << "hhh" << maxlen << endl;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> str[i].s;
//		str[i].len = str[i].s.length();
//		str[i].t = 0;
//		//cout << str[i].s << " " << str[i].len << endl;
//	}
//	string start;
//	cin >> start;
//	str[0].s = start;
//	str[0].len = start.length();
//	str[0].t = 0;
//	dfs(str[0].s);//把开头字母也加进去处理
//
//	cout << maxlen << endl;
//	system("pause");
//	return 0;
//}

//2.6基本算法之动态规划
//Maximum sum  思路
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 50010;
//long long orin[maxn];
//long long dp1[maxn];
//long long dp2[maxn];
//long long ans1[maxn];
//long long ans2[maxn];
//int len;
//void f() {
//	ans1[0] = orin[1];
//	ans2[len + 1] = orin[len];
//	for (int i = 1; i <= len; i++) {
//		dp1[i] = max(dp1[i - 1] + orin[i], orin[i]);//表示使用第i个元素，能得到的最大值
//		ans1[i] = max(ans1[i - 1], dp1[i]);//表示使用前i个元素（第i个元素不一定使用），能得到的最大值
//	//	cout << i << " " << dp1[i] << " " << ans1[i] << endl;
//	}
//	for (int i = len; i >= 1; i--) {
//		dp2[i] = max(dp2[i + 1] + orin[i], orin[i]);
//		ans2[i] = max(ans2[i + 1], dp2[i]);
//		//	cout <<i<<" "<< dp2[i] << " " << ans2[i] << endl;
//	}
//	long long ans = INT_MIN;
//	/*for (int i =1; i < len; i++) {
//		ans = max(ans, ans1[i] + ans2[i+1]);
//	}*/
//	for (int i = 2; i <= len; i++) {//遍历断点 两种方式都可以
//		ans = max(ans, ans1[i-1] + ans2[i]);
//	}
//	cout << ans << endl;
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		memset(orin, 0, sizeof(orin));
//		memset(dp1, 0, sizeof(dp1));
//		memset(dp2, 0, sizeof(dp2));
//		memset(ans1, 0, sizeof(ans1));
//		memset(ans2, 0, sizeof(ans2));
//
//		cin >> len;
//		for (int j = 1; j <= len; j++) {//从1开始计数
//			cin >> orin[j];
//		}
//		f();
//	}
//	system("pause");
//	return 0;
//}

//最长上升子序列
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 1010;
//int m[maxn];
//int dp[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		dp[i] = 1;
//		for (int j = 1; j < i; j++) {
//			if (m[i] > m[j]) {
//				dp[i] = max(dp[j] + 1,dp[i]);
//			}
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= n; i++) {
//		ans = max(ans, dp[i]);
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//最大子矩阵
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int temp[maxn];
//int dp[maxn];
//int ans = INT_MIN;
//int main() {
//	memset(temp, 0, sizeof(temp));
//	memset(dp, 0, sizeof(dp));
//	dp[1] = INT_MIN;
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 1; i <= n; i++) {//起始行
//		memset(temp, 0, sizeof(temp));
//		for (int j = i; j <= n; j++) {//结束行
//			for (int k = 1; k <= n; k++) {//遍历列
//				temp[k] = temp[k] + m[j][k];
//			}
//			for (int k = 1; k <= n; k++) {
//				dp[k] = max(dp[k - 1] + temp[k], temp[k]);
//				ans = max(ans, dp[k]);
//			}
//		}
//	}
//	
//	
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//采药  
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;//原来数组只开了110 太小了 要开大一点
//int c[maxn];
//int v[maxn];
//int dp[maxn][maxn];
//int main() {
//	memset(dp, 0, sizeof(dp));
//	memset(c, 0, sizeof(c));
//	memset(v, 0, sizeof(v));
//	int t, n;
//	cin >> t >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> c[i] >> v[i];
//	}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 0; j <= t; j++) {
//			if (j < c[i]) {
//				dp[i][j] = dp[i - 1][j];
//			}
//			if (j >= c[i]) {//这里要取等号
//				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + v[i]);
//			}
//			//cout << dp[i][j] << endl;
//		}
//	}
//	cout << dp[n][t];
//	system("pause");
//	return 0;
//}

//公共子序列  注意数组越界呀
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<string>
//#include<cstdio>
//using namespace std;
//
//const int maxn = 220;
//int dp[maxn][maxn];
//int main() {
//	string a, b;
//	while (cin>>a>>b) {
//		memset(dp, 0, sizeof(dp));
//		int lena = a.length();
//		int lenb = b.length();
//		for (int i = 0; i < lena; i++) {
//			for (int j = 0; j < lenb; j++) {
//				if (a[i] == b[j]) {
//					//cout << i<<" "<<j << endl;
//					dp[i+1][j+1] = dp[i][j] + 1;//这里注意一下下标呀! 0-1是-1  越界了
//				}
//				else {
//					dp[i+1][j+1] = max(dp[i + 1][j], dp[i][j + 1]);
//				}
//			}
//		}
//		cout << dp[lena][lenb] << endl;
//	}
//	return 0;
//}



//吃糖果
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 25;
//int dp[maxn];
//int main() {
//	int n;
//	cin >> n;
//	memset(dp, 0, sizeof(dp));
//	dp[1] = 1;
//	dp[2] = 2;
//	for (int i =3; i <= n; i++) {
//		dp[i] = dp[i - 1] + dp[i - 2];
//	}
//	cout << dp[n] << endl;
//	system("pause");
//	return 0;
//}

//登山
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 1010;
//int dp[maxn];
//int m[maxn];
//int dp2[maxn];
//int main() {
//	memset(dp, 0, sizeof(dp));
//	memset(m, 0, sizeof(m));
//
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		dp[i] = 1;
//		for (int j = 1; j < i; j++) {
//			if (m[i] > m[j]) {
//				dp[i] = max(dp[j] + 1, dp[i]);
//
//			}
//		}
//	}
//	for (int i = n; i >= 1; i--) {
//		dp2[i] = 1;
//		for (int j = n; j > i; j--) {
//			if (m[i] > m[j]) {
//				dp2[i] = max(dp2[j] + 1, dp2[i]);
//			}
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= n; i++) {
//		ans = max(ans, dp[i]+dp2[i]-1);//注意这里要减1 比如1254321 那个最大值5被算了两次
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}

//最长公共子上升序列  不会做
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//#include<climits>
//using namespace std;
//const int maxn = 1010;
//int dp1[maxn];
//int dp2[maxn];
//int dp3[maxn][maxn];
//int m1[maxn];
//int m2[maxn];
//
//int main() {
//	memset(dp1, 0, sizeof(dp1));
//	memset(dp2, 0, sizeof(dp2));
//	memset(dp3, 0, sizeof(dp3));
//	memset(m1, 0, sizeof(m1));
//	memset(m2, 0, sizeof(m2));
//
//	int n1,n2;
//	cin >> n1;
//	for (int i = 1; i <= n1; i++) {
//		cin >> m1[i];
//	}
//	cin >> n2;
//	for (int i = 1; i <= n2; i++) {
//		cin >> m2[i];
//	}
//	for (int i = 1; i <= n1; i++) {
//		dp1[i] = 1;
//		for (int j = 1; j < i; j++) {
//			if (m1[i] > m1[j]) {
//				dp1[i] = max(dp1[j] + 1, dp1[i]);
//			}
//		}
//	}
//	for (int i = 1; i <= n2; i++) {
//		dp2[i] = 1;
//		for (int j = 1; j < i; j++) {
//			if (m2[i] > m2[j]) {
//				dp2[i] = max(dp2[j] + 1, dp2[i]);
//			}
//		}
//	}
//
//	for (int i = 1; i <= n1; i++) {
//		for (int j = 1; j <= n2; j++) {
//			if (m1[i] == m2[j]) {
//				dp3[i][j] = dp3[i - 1][j - 1] + 1;
//			}
//			else {
//				dp3[i][j] = max(dp3[i][j - 1], dp3[i - 1][j]);
//			}
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= n1; i++) {
//		ans = max(ans, dp3[i] + dp3[i] - 1);//注意这里要减1 比如1254321 那个最大值5被算了两次
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}

//2718:移动路线
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 22;
//int dp[maxn][maxn];
//int main() {
//	int r, c;
//	cin >> r >> c;
//	memset(dp, 0, sizeof(dp));
//	for (int i = 1; i <= r; i++) {
//		dp[i][1] = 1;
//	}
//	for (int i = 1; i <= c; i++) {
//		dp[1][i] = 1;
//	}
//	/*for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cout << dp[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	/*dp[1][1] = 1;
//	dp[1][2] = 1;
//	dp[2][1] = 1;*/
//	for (int i = 2; i <= r; i++) {//注意其实坐标是2
//		for (int j =2; j <= c; j++) {
//			dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
//		}
//	}
//	//cout << dp[2][2];
//	cout << dp[r][c] << endl;
//	system("pause");
//	return 0;
//}

//摘花生
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//long long ans[maxn][maxn];
//int main() {
//	int n;
//	int r, c;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		memset(m, 0, sizeof(m));
//		memset(ans, 0, sizeof(ans));
//		cin >> r >> c;
//		for (int j = 1; j <= r; j++) {
//			for (int k = 1; k <= c; k++) {
//				/*ans[j][k] = ans[j - 1][k] + ans[j][k - 1];*/
//				cin >> m[j][k];
//			}
//		}
//		for (int j = 1; j <= r; j++) {
//			ans[j][1] = ans[j - 1][1] + m[j][1];
//		}
//		for (int j = 1; j <= c; j++) {
//			ans[1][j] = ans[1][j - 1] + m[1][j];
//		}
//		//for (int j = 1; j <= r; j++) {
//		//	for (int k = 1; k <= c; k++) {
//		//		/*ans[j][k] = ans[j - 1][k] + ans[j][k - 1];*/
//		//		cout << ans[j][k] << " ";
//		//	}
//		//	cout << endl;
//		//}
//		//ans[1][1] = m[1][1];
//		for (int j = 2; j <= r; j++) {
//			for (int k = 2; k <= c; k++) {
//				ans[j][k] = max(ans[j - 1][k], ans[j][k - 1]) + m[j][k];
//				//cin >> m[j][k];
//			}
//		}
//		cout << ans[r][c] << endl;
//
//	}
//	system("pause");
//	return 0;
//}

//数字组合
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 22;
//int m[maxn];
//int dp[maxn][maxn];
//int main() {
//	int n, t;
//	cin >> n >> t;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= t; j++) {
//			if (j == m[i]) {
//				dp[i][m[i]] = 1;
//			}
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= t; j++) {
//			
//			if (m[i] <= j) {
//				dp[i][j] = dp[i][j] + dp[i - 1][j] + dp[i - 1][j - m[i]];
//			}
//			else {
//				dp[i][j] = dp[i][j] + dp[i - 1][j];
//			}
//		}
//	}
//	cout << dp[n][t] << endl;
//	system("pause");
//	return 0;
//}

//计算字符串距离  ？？不是很理解这道题
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<string>
//
//using namespace std;
//
//const int maxn = 1100;
//int dp[maxn][maxn];
//int main() {
//	int n;
//	cin >> n;
//	string a, b;
//	for (int cnt = 1; cnt <= n; cnt++) {//这里写成cnt
//		memset(dp, 0, sizeof(dp));
//		cin >> a >> b;
//		int lena = a.size();
//		int lenb = b.size();
//		for (int i = 0; i <= lena; i++) {//初始化很关键 为啥要取等号啊？
//			dp[i][0] = i;
//		}
//		for (int i = 0; i <= lenb; i++) {
//			dp[0][i] = i;
//		}
//		for (int i = 0; i < lena; i++) {
//			for (int j = 0; j < lenb; j++) {
//				if (a[i] == b[j]) {//这里之前笔误了 注意debug的时候一定要小黄鸭debug
//					dp[i + 1][j + 1] = dp[i][j];
//				}
//				else {
//					//这里考虑三种情况 
//					dp[i + 1][j + 1] = 1 + min(min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]);
//				}
//				//cout <<i<<" "<<j<<" "<< dp[i][j] << endl;
//			}
//		}
//		cout << dp[lena][lenb] << endl;
//	}
//	system("pause");
//	return 0;
//}

//糖果  没过的  估计是内存爆了
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//long long dp[maxn][maxn];
//int main() {
//	for (int i = 1; i < maxn; i++) {
//		dp[0][i] = -0x3f3f3f;
//	}
//	//memset(dp, 0, sizeof(dp));
//	int n, k;
//	cin >> n >> k;
//	int sum = 0;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		sum += m[i];
//	}
//	int t = sum / k;
//	
//	for (int i = 1; i <= n; i++) {
//		for (int j =0 ; j <= t * k; j++) {
//			if (m[i] > j) {
//				dp[i][j] = dp[i - 1][j];
//			}
//			else {
//				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - m[i]]+m[i]);
//			}
//			//cout << i << " " << j << " " << dp[i][j] << endl;
//		}
//	}
//	long long  ans = LLONG_MIN;
//	for (int i = 1; i <= t; i++) {
//		ans = max(ans, dp[n][i*k]);
//		//cout << i * k << endl;
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}


//糖果  记住余数的求法
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int dp[maxn][maxn];
//int main() {
//	int n, k;
//	cin >> n >> k;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i < k; i++) {//j表示只能是j
//		dp[0][i] = INT_MIN;
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 0; j < k; j++) {
//			int zq = (j - (m[i]) % k + k) % k;
//			dp[i][j] = max(dp[i - 1][j], dp[i - 1][zq] + m[i]);
//			//cout << i << " " << j << " " << dp[i][j] << endl;
//		}
//	}
//	cout << dp[n][0] << endl;
//	system("pause");
//	return 0;
//}



//判断整除  网上答案
//#include<iostream>
//
//using namespace std;
//
//int cun[10005][105], n, k, x;
//
//int main() {
//	cin >> n >> k >> x;//此处先输入第一个x
//	x %= k;//输入后立即进行取模运算
//	cun[1][x] = 1;//用二维数组cun分别记录输入数的个数（i）和求得的余数（x），用1做标记表示曾计算到这一层
//	for (int i = 2; i <= n; i++) {
//		cin >> x; x %= k;//同理输入取模
//		for (int j = 0; j<k; j++) {//j是余数，所以j最小为0，最大不能等于k
//			if (cun[i - 1][j]) {//前提条件：上一行有运算
//				cun[i][abs(j + x) % k] = 1;
//				cun[i][abs(j - x) % k] = 1;//为规避负数要进行绝对值运算
//			}
//		}
//	}
//	if (cun[n][0]) cout << "YES";//如果累积到输入第n个数（最后一个数），有计算到余数为０的情况，则满足题意
//	else cout << "NO";
//	return 0;
//}

//判断整除 自己默写
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int dp[maxn][maxn];
//int main() {
//	int n, k;
//	cin >> n>>k;
//	for (int cnt = 1; cnt <= n; cnt++) {
//		cin >> m[cnt];
//		m[cnt] = m[cnt] % k;
//	}
//	dp[1][m[1]] = 1;
//	for (int i = 2; i <= n; i++) {
//		for (int j = 0; j < k; j++) {
//			if (dp[i-1][j]) {//如果上一个状态存在，则转移
//				dp[i][abs(j + m[i]) % k] = 1;
//				dp[i][abs(j - m[i]) % k] = 1;
//			}
//		}
//	}
//	if (dp[n][0]) {
//		cout << "YES" << endl;
//	}
//	else {
//		cout << "NO" << endl;
//	}
//	system("pause");
//	return 0;
//}

//最大上升子序列和
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 1010;
//long long  m[maxn];
//long long dp[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(dp, 0, sizeof(dp));
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		dp[i] = m[i];
//	}
//
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j < i; j++) {
//			if (m[i] > m[j]) {
//				dp[i] = max(dp[j] + m[i], dp[i]);//注意这里是和dp[i]比 不是和m[i]
//				//cout << i << " " << dp[i] << endl;
//			}
//		}
//	}
//	long long  ans = LLONG_MIN;
//	for (int i = 1; i <= n; i++) {
//		ans = max(ans, dp[i]);
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//怪盗基德的滑翔翼
//#include<iostream>
//#include<cstring>
//#include<climits>
//#include<algorithm>
//using namespace std;
//const int maxn = 10010;
//int m[maxn];
//int dp[maxn];
//int dp2[maxn];
//int main() {
//	int num, n;
//	cin >> n;
//	for (int cnt = 1; cnt <= n; cnt++) {
//		cin >> num;
//		memset(m, 0, sizeof(m));
//		memset(dp, 0, sizeof(dp));
//		for (int i = 1; i <= num; i++) {
//			cin >> m[i];
//		}
//		for (int i = 1; i <= num; i++) {
//			dp[i] = 1;
//			for (int j = 1; j < i; j++) {
//				if (m[i] < m[j]) {
//					dp[i] = max(dp[j] + 1, dp[i]);
//					//cout << i << " " << dp[i] << endl;
//				}
//			}
//		}
//		for (int i = 1; i <= num; i++) {
//			dp2[i] = 1;
//			for (int j = 1; j < i; j++) {
//				if (m[i] > m[j]) {
//					dp2[i] = max(dp2[j] + 1, dp2[i]);
//					//cout << i << " " << dp2[i] << endl;
//				}
//			}
//		}
//		int ans = INT_MIN;
//		for (int i = 1; i <= num; i++) {
//			ans = max(ans, max(dp[i],dp2[i]));
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}


//宠物小精灵之收服  Time Limit Exceeded 4分
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;
//int m[maxn][2];
//int dp[110][1010][510];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(dp, 0, sizeof(dp));
//	int r, c, cnt;
//	cin >> r >> c >> cnt;
//	for (int i = 1; i <= cnt; i++) {
//		cin >> m[i][0] >> m[i][1];
//	}
//	for (int i = 1; i <= cnt; i++) {
//		for (int j = 0; j <= r; j++) {
//			for (int k = 0; k <= c; k++) {
//				if (m[i][0] > j || m[i][1] > k) {
//					dp[i][j][k] = dp[i - 1][j][k];
//				}
//				else {
//					dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - m[i][0]][k - m[i][1]] + 1);
//				}
//			}
//		}
//	}
//	cout << dp[cnt][r][c] << " ";
//	for (int i = 0; i <= c; i++) {
//		if (dp[cnt][r][c] == dp[cnt][r][i]) {//所有物品都考虑 并且考虑背包装r  即装满的情况 找最小的i
//			cout << c - i << endl;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}

//宠物小精灵之收服 2分
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;
//int m[maxn][2];
//int dp[110][1010][510];
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(dp, 0, sizeof(dp));
//	int r, c, cnt;
//	cin >> r >> c >> cnt;
//	for (int i = 1; i <= cnt; i++) {
//		cin >> m[i][0] >> m[i][1];
//	}
//	for (int i = 1; i <= cnt; i++) {
//		for (int j = m[i][0]; j <= r; j++) {
//			for (int k = m[i][1]; k <= c; k++) {//这样也过不了  并且只有2分
//				
//					dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - m[i][0]][k - m[i][1]] + 1);
//				
//			}
//		}
//	}
//	cout << dp[cnt][r][c] << " ";
//	for (int i = 0; i <= c; i++) {
//		if (dp[cnt][r][c] == dp[cnt][r][i]) {//所有物品都考虑 并且考虑背包装r  即装满的情况 找最小的i
//			cout << c - i << endl;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}

//宠物小精灵之收服 过了
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;
//int m[110][2];
//int dp[1010][510];//注意开数组的大小  不然会runtime error
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(dp, 0, sizeof(dp));
//	int ball, energy, cnt;
//	cin >> ball >> energy >> cnt;
//	for (int i = 1; i <= cnt; i++) {
//		cin >> m[i][0] >> m[i][1];
//	}
//	for (int i = 1; i <= cnt; i++) {
//		for (int j = ball; j >=  m[i][0]; j--) {
//			for (int k = energy ; k >= m[i][1]; k--) {
//				dp[j][k] = max(dp[j][k], dp[j - m[i][0]][k - m[i][1]] + 1);//j个精灵球 k个体力 最多能收复小精灵数量
//			}
//		}
//	}
//	cout << dp[ball][energy] << " ";
//	for (int i = 0; i <= energy; i++) {
//		if (dp[ball][energy] == dp[ball][i]) {//所有物品都考虑 并且考虑背包装r  即装满的情况 找最小的i
//			cout << energy - i << endl;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}

//踩方格 思想 类似于走楼梯 但是不同
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 22;
//int l[maxn];
//int r[maxn];
//int u[maxn];
//int main() {
//	int n;
//	cin >> n;
//	l[1] = 1;
//	r[1] = 1;
//	u[1] = 1;
//	for (int i = 2; i <= n; i++) {
//		l[i] = l[i - 1] + u[i - 1];
//		r[i] = r[i - 1] + u[i - 1];
//		u[i] = u[i - 1] + l[i - 1] + r[i - 1];
//	}
//	cout << l[n] + r[n] + u[n] << endl;
//	system("pause");
//	return 0;
//}

//开餐馆 
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int v[maxn];
//long long dp[maxn];
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 1; cnt <= t; cnt++) {
//		memset(m, 0, sizeof(m));
//		memset(v, 0, sizeof(v));
//		memset(dp, 0, sizeof(dp));
//		int n, k;
//		cin >> n >> k;
//		for (int i = 1; i <= n; i++) {
//			cin >> m[i];
//		}
//		for (int i = 1; i <= n; i++) {
//			cin >> v[i];
//		}
//
//		for (int i = 1; i <= n; i++) {
//			dp[i] = v[i];
//			for (int j = 1; j < i; j++) {
//				if (m[i] - m[j] > k) {
//					dp[i] = max(dp[i], dp[j] + v[i]);//表示一定要选到物品i的价值
//				}
//			}
//		}
//		long long ans = LLONG_MIN;
//		for (int i = 1; i <= n; i++) {//一定要遍历答案 因为表示的是一定要选到物品i的价值 而不是截止到i的最大价值 
//			cout << "hhh " << dp[i] << endl;
//			ans = max(ans, dp[i]);
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//买书 完全背包问题 少了一个维度的
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>	
//using namespace std;
//const int maxn = 1010;
//int m[5];
//int dp[maxn];
//int main() {
//	m[1] = 10;
//	m[2] = 20;
//	m[3] = 50;
//	m[4] = 100;
//	int n;
//	cin >> n;
//	dp[0] = 1;
//	for (int i = 1; i <= 4; i++) {
//		for (int j = m[i]; j <= n; j++) {
//			dp[j] = dp[j] + dp[j - m[i]];
//		}
//	}
//	cout << dp[n] << endl;
//	system("pause");
//	return	 0;
//}

//买书  自己重新默写  用3个维度表示
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>	
//using namespace std;
//const int maxn = 1010;
//int m[5];
//int dp[maxn][maxn];
//int main() {
//	m[1] = 10;
//	m[2] = 20;
//	m[3] = 50;
//	m[4] = 100;
//	int n;
//	cin >> n;
//	dp[0][0] = 1;
//	for (int i = 1; i <= 4; i++) {
//		for (int j = 0; j <= n; j++) {
//			/*for (int k = 0; k <= n / m[i]; k++) {
//				if (j >= k * m[i]) {
//					dp[i][j] = dp[i][j] + dp[i - 1][j - k * m[i]];
//				}
//				else {
//					dp[i][j] = dp[i][j];
//				}
//			}*/
//			for (int k = 0; k <= j / m[i]; k++) {//这样也可以
//				dp[i][j] = dp[i][j] + dp[i - 1][j - k * m[i]];
//			}
//		}
//	}
//	cout << dp[4][n] << endl;
//	system("pause");
//	return	 0;
//}

//带通配符的字符串匹配  最开始只有5分  记得要初始化 ***abc  abc的情况
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>	
//#include<string>
//using namespace std;
//const int maxn = 25;
//int dp[maxn][maxn];
//int main() {
//	string a, b;
//	cin >> a >> b;
//	int lena = a.size();
//	int lenb = b.size();
//	dp[0][0] = 1;
//	for (int i = 1; a[i - 1] == '*'; i++) {//这里要考虑 ***abc  和 abc的情况 所以要初始化dp[3][0] =1
//		dp[i][0] = 1;
//		//cout << i << endl;
//	}
//	for (int i = 1; i <= lena; i++) {
//		for (int j = 1; j <= lenb; j++) {
//			if (a[i - 1] == '*' && (dp[i - 1][j - 1] || dp[i - 1][j] || dp[i][j - 1])) {
//				dp[i][j] = 1;
//			}
//			if (a[i - 1] == '?'&&dp[i - 1][j - 1]) {
//				dp[i][j] = 1;
//			}
//			if ( dp[i - 1][j - 1] && a[i - 1] == b[j - 1]) {
//				dp[i][j] = 1;
//			}
//		}
//	}
//	if (dp[lena][lenb]) {
//		cout << "matched" << endl;
//	}
//	else {
//		cout << "not matched" << endl;
//	}
//	system("pause");
//	return	 0;
//}



//放苹果
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>	
//using namespace std;
//const int maxn = 15;
//int dp[maxn][maxn][maxn];
//int main() {
//	int t;	
//	cin >> t;
//	for (int cnt = 1; cnt <= t; cnt++) {
//		memset(dp, 0, sizeof(dp));
//		int apple, plate;
//		cin >> apple >> plate;
//		dp[0][0][0] = 1;
//		for (int i = 1; i <= plate; i++) {
//			for (int j = 0; j <= apple; j++) {
//				for (int k = 0; k <= j; k++) {
//					if (dp[i - 1][j][k] == 0) {
//						continue;
//					}
//					for (int y = k; y + j <= apple; y++) {
//						dp[i][j + y][y] = dp[i][j + y][y] + dp[i-1][j][k];
//					}
//				}
//			}
//		}
//		int ans = 0;
//		for (int i = 0; i <= apple; i++) {
//			ans += dp[plate][apple][i];
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return	 0;
//}


//Color Tunnels 网友答案
//#include<iostream>
//#include<cstdio>
//#include<cstdlib>
//#include<cstring>
//#include<iostream>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//#define M 35
//#define N 65
//#define C 105
//#define INF 2e9
//
//int m, n;
//double start_x, start_y, end_x, end_y;
//int tar[M];
//struct Node {
//	double x, y, xx, yy, l;
//	int color;
//};
//Node tunnel[2 * N];
//double f[2][2 * N];
//
//void add_tunnel(int id, double x, double y, double xx, double yy, int c)
//{
//	tunnel[id].x = x, tunnel[id].y = y, tunnel[id].color = c;
//	tunnel[id].xx = xx, tunnel[id].yy = yy;
//	tunnel[id].l = sqrt((x - xx)*(x - xx) + (y - yy)*(y - yy));
//}
//double mmin(double x, double y) { return x < y ? x : y; }
//double dis(double x, double y, double xx, double yy) { return sqrt((x - xx)*(x - xx) + (y - yy)*(y - yy)); }
//
//int main()
//{
//	int T, i, j, k;
//	scanf("%d", &T);
//	while (T--)
//	{
//		scanf("%lf%lf%lf%lf", &start_x, &start_y, &end_x, &end_y);
//		scanf("%d", &m);
//		for (i = 1; i <= m; i++)
//			scanf("%d", &tar[i]);
//
//		scanf("%d", &n);
//		for (i = 1; i <= n; i++)
//		{
//			double x, y, xx, yy; int c;
//			scanf("%lf%lf%lf%lf%d", &x, &y, &xx, &yy, &c);
//			add_tunnel(2 * i - 1, x, y, xx, yy, c);//进出隧道的顺序无所谓 所以加双向边
//			add_tunnel(2 * i, xx, yy, x, y, c);
//		}
//		n *= 2;
//
//		double ans = INF;
//		//初始化 找到第一个隧道
//		for (j = 1; j <= n; j++)//遍历所有隧道 找到是第一个颜色的隧道
//		{
//			if (tunnel[j].color != tar[1])
//				continue;
//			f[1][j] = dis(start_x, start_y, tunnel[j].x, tunnel[j].y) + tunnel[j].l;
//			if (m == 1) ans = mmin(ans, f[1][j] + dis(tunnel[j].xx, tunnel[j].yy, end_x, end_y));//xx,yy
//		}
//		int u = 1;
//		for (i = 2; i <= m; i++)//遍历颜色序列tar
//		{
//			u = 1 - u;//滚动数组的思想 因为只需要i和i-1  当然第一维也可以开m的数组
//			for (j = 1; j <= n; j++)//遍历所有隧道 找到是第i颜色的隧道
//			{
//				f[u][j] = INF;//f[i][j]表示通过颜色序列前 i 个颜色，这次的第 i 个颜色的隧道选 j 的最小距离
//				if (tunnel[j].color != tar[i]) continue;
//				for (k = 1; k <= n; k++)//遍历所有隧道 找到是第i-1颜色的隧道
//				{
//					if (tunnel[k].color != tar[i - 1]) continue;
//					f[u][j] = mmin(f[u][j], f[1 - u][k] + dis(tunnel[k].xx, tunnel[k].yy, tunnel[j].x, tunnel[j].y) + tunnel[j].l);
//				}
//				//如果结束了，加上最后的路径
//				if (i == m) ans = mmin(ans, f[u][j] + dis(tunnel[j].xx, tunnel[j].yy, end_x, end_y));//xx,yy
//				//cout<<u<<" "<<i<<" "<<j<<" "<<
//			}
//		}
//		printf("%.4lf\n", ans);
//	}
//	return 0;
//}


//山区建小学 网友答案
//#include<iostream>
//#include<cstdio>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//const int inf = 99999999;
//int f[510][510];
//int dis[510][510];//从i到j距离 
//int pos[510];
//int s[510][510];
////s[管辖区起点][管辖区终点]=这片辖区内建一个学校，区内村庄到学校的距离和
//int school, city;
//int dist(int i, int j) {
//	int x = 0;
//	int mid = (i + j) / 2;//学校建在中间
//	for (int k = i; k <= j; k++)
//		x += dis[k][mid];
//	return x;
//}
//
//int main() {
//	scanf_s("%d%d", &city, &school);
//	int i, j, x;
//	for (i = 2; i <= city; i++) {//从2开始，方便求各村庄间距离
//		scanf_s("%d", &x);
//		pos[i] = pos[i - 1] + x;
//	}
//	//
//	for (i = 1; i <= city; i++)
//		for (j = 1; j <= city; j++) {
//			if (i == j)dis[i][j] = 0;
//			else dis[i][j] = dis[j][i] = abs(pos[j] - pos[i]);
//		}//初始化两两距离 
//		 //
//	for (i = 1; i <= city; i++)
//		for (j = 1; j <= city; j++) {
//			s[i][j] = dist(i, j);
//			//cout << i << " " << j << " " << s[i][j] << endl;
//		}
//	//计算一个管辖从i到j村庄的学校到这些村庄的距离和
//	//
//	for (i = 1; i <= city; i++)
//		for (j = 1; j <= city; j++)
//			f[i][j] = inf;
//	for (i = 1; i <= city; i++)f[i][i] = 0;
//	for (i = 1; i <= city; i++)f[i][1] = s[1][i];//只建一个学校的情况 
//											  //f初始化 
//
//											  /*	//test
//											  for(i=1;i<=m;i++)
//											  for(j=1;j<=m;j++)
//											  printf("%d ",s[i][j]);
//											  */
//	for (i = 2; i <= city; i++) {//村庄
//		for (j = 2; j <= min(i, school); j++) {//学校 
//			for (int k = j - 1; k <= i - 1; k++) {//枚举已有的学校管辖的范围 
//				if (i != j)f[i][j] = min(f[i][j], f[k][j - 1] + s[k + 1][i]);
//			}
//		}
//	}
//	printf("%d", f[city][school]);
//	system("pause");
//	return 0;
//}

//鸡蛋的硬度
//#include<cstdio>
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int f[110][11];
//int main()
//{
//	int n, m;
//	while (scanf_s("%d%d", &n, &m) != EOF)
//	{
//		memset(f, 0, sizeof(f));
//		for (int i = 1; i <= n; i++)
//		{
//			for (int j = 1; j <= m; j++)
//			{
//				f[i][j] = i;
//			}
//		}
//		for (int j = 1; j <= n; j++)//遍历楼层
//		{
//			for (int k = 1; k <= j; k++)//枚举从那层楼摔下去
//			{
//				for (int i = 2; i <= m; i++)//遍历鸡蛋个数
//				{
//					f[j][i] = min(f[j][i], max(f[k - 1][i - 1], f[j - k][i]) + 1);//dp方程（我打的有点丑，可以自行修改）
//					cout << j << " " << i << " " << " " << k << " " << f[j][i] << endl;
//				}
//			}
//		}
//		printf("%d\n", f[n][m]);
//	}
//	system("pause");
//	return 0;
//}


//最低通行费
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int dp[maxn][maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 0; i <= n; i++) {
//		dp[0][i] = INT_MAX;
//		dp[i][0] = INT_MAX;
//	}
//	dp[1][1] = m[1][1];
//	/*for (int i = 0; i <= n; i++) {
//		for (int j = 0; j <= n; j++) {
//			cout << dp[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			if (i == 1 && j == 1) {
//				continue;
//			}
//			if (i == 1) {
//				dp[i][j] = dp[i][j - 1] + m[i][j];
//			}
//			else if (j == 1) {
//				dp[i][j] = dp[i - 1][j] + m[i][j];
//			}
//			else {
//				dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + m[i][j];
//			}
//			//cout << i << " " << j << " " << dp[i][j] << endl;
//
//		}
//	}
//	cout << dp[n][n] << endl;
//	system("pause");
//	return 0;
//
//}

//鸡蛋的硬度
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int dp[maxn][maxn];
//int main() {
//	int floor, egg;
//	while (cin >> floor >> egg) {
//		memset(dp, 0, sizeof(dp));
//		for (int i = 0; i <= floor; i++) {//i层楼  1个鸡蛋 初始化
//			dp[i][1] = i;
//		}
//		for (int i = 1; i <= floor; i++) {
//			for (int j = 2; j <= egg; j++) {//从两个鸡蛋开始遍历
//				dp[i][j] = INT_MAX;//这里后面求最小值 所以要赋成最大值
//				for (int k = 1; k <= i; k++) {
//					dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
//				}
//			}
//		}
//		cout << dp[floor][egg] << endl;
//	}
//}


//大盗阿福  超时
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 100010;
//long long  m[maxn];
//long long  dp[maxn];
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 1; cnt <= t; cnt++) {
//		int n;
//		cin >> n;
//		for (int i = 1; i <= n; i++) {
//			cin >> m[i];
//
//		}
//		for (int i = 1; i <= n; i++) {
//			dp[i] = m[i];
//			for (int j = 1; j < i; j++) {
//				if (j + 1 < i) {
//					dp[i] = max(dp[j] + m[i], dp[i]);
//					/*dp[i][1] = dp[i - 1][0] + m[i];
//					dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]);*/
//				}
//			}
//		}
//		long long ans = LLONG_MIN;
//		for (int i = 1; i <= n; i++) {
//			ans = max(ans, dp[i]);
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//大盗阿福  过了 注意状态转移方程 很常见 记住
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 100010;
//long long  m[maxn];
//long long  dp[maxn][2];
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 1; cnt <= t; cnt++) {
//		int n;
//		cin >> n;
//		for (int i = 1; i <= n; i++) {
//			cin >> m[i];
//
//		}
//		for (int i = 1; i <= n; i++) {
//			dp[i][1] = dp[i - 1][0] + m[i];
//			dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]);
//
//		}
//		long long ans = LLONG_MIN;
//		for (int i = 1; i <= n; i++) {
//			ans = max(max(ans, dp[i][0]), dp[i][1]);
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//鸣人的影分身
//#include<iostream>
//#include<cstring>
//#include<climits>
//#include<algorithm>
//using namespace std;
//const int maxn = 15;//数组不能开10呀！！！
//int dp[maxn][maxn][maxn];
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 1; cnt <= t; cnt++) {
//		memset(dp, 0, sizeof(dp));
//		int apple, plate;
//		cin >> apple >> plate;
//		dp[0][0][0] = 1;
//		for (int i = 1; i <= plate; i++) {
//			for (int j = 0; j <= apple; j++) {
//				for (int k = 0; k <= j; k++) {//这里k<=j
//					//cout << i << " " << j << " " << k << " " << dp[i][j][k] << endl;
//
//					if (dp[i - 1][j][k] == 0) {
//						continue;
//					}
//					for (int y = k; y + j <= apple; y++) {
//						dp[i][j + y][y] += dp[i - 1][j][k];
//					}
//				}
//			}
//		}
//		int ans = 0;
//		for (int i = 0; i <= apple; i++) {
//			ans += dp[plate][apple][i];
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//拦截导弹
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 20;
//int dp[maxn];
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		dp[i] = 1;
//		for (int j = 1; j < i; j++) {
//			if (m[i] <= m[j]) {
//				dp[i] = max(dp[i], dp[j] + 1);
//			}
//			//cout << i << " " << dp[i] << endl;
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= n; i++) {
//		ans = max(ans, dp[i]);
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}
//


//乘积最大
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//const int maxn = 50;
//char c[maxn];
//int m[maxn][maxn];
//int dp[maxn][maxn];//dp[i][k]	前i位数 分割k次  最大的乘积
//int main() {
//	int len, t;
//	cin >> len >> t;
//	for (int i = 1; i <= len; i++) {
//		cin >> c[i];
//		m[i][i] = c[i] - '0';
//	}
//	for (int i = 1; i <= len; i++) {
//		for (int j = i+1; j <= len; j++) {
//			m[i][j] = m[i][j - 1] * 10 + m[j][j];
//			//cout << i << " " << j << " " << m[i][j] << endl;
//		}
//	}
//	for (int i = 1; i <= len; i++) {//初始化 前i个数 分0次 就等于本来前i位数
//		dp[i][0] = m[1][i];
//		//cout << dp[i][0] << endl;
//	}
//	for (int k = 1; k <= t; k++) {
//		for (int i = k + 1; i <= len; i++) {
//			for (int j = k; j < i; j++) {
//				dp[i][k] = max(dp[i][k], dp[j][k - 1] * m[j + 1][i]);
//				//cout << i << " " << k << " " << dp[i][k] << endl;
//			}
//		}
//	}
//	cout << dp[len][t];
//	system("pause");
//	return 0;
//}

//装箱问题
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//int m[35];
//int dp[35][20020];
//int main() {
//	int tot, n;
//	cin >> tot >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//
//	for (int i = 1; i <= n; i++) {
//		dp[i][m[i]] = m[i];
//		for (int j = 0; j <= tot; j++) {
//			if (j < m[i]) {
//				dp[i][j] = dp[i - 1][j];
//			}
//			else {
//				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - m[i]] + m[i]);
//			}
//		}
//	}
//	cout << tot - dp[n][tot] << endl;
//	system("pause");
//	return 0;
//}

//方格取数 自己写的
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//const int maxn = 15;
//int m[maxn][maxn];
//int dp[maxn][maxn][maxn][maxn];//dp[i][j][k][l]表示在step步   第一条路径走i，j  第二条路径走k,l  注意i，j   k,l不能重合
//int main() {
//	int  n;
//	cin >> n;
//	int r, c, v;
//	while (cin >> r >> c >> v) {
//		if (r == 0 && c == 0 && v == 0) {
//			break;
//		}
//		m[r][c] = v;
//	}
//	/*for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cout << m[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	dp[1][1][1][1] = m[1][1];
//	for (int step = 3; step <= 2 * n; step++) {
//		for (int i = 1; i <= min(step, n); i++) {
//			int j = step - i;
//			if (j<1 || j>n) {
//				continue;//这里不能写break  写continue 表示跳过这一步 不是直接退出循环
//			}
//			for (int k = 1; k <= min(step, n); k++) {
//				if (k == i) {
//					continue;
//				}
//				int l = step - k;
//				if (l<1 || l>n) {
//					continue;
//				}
//				dp[i][j][k][l] = max(max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]),
//					max(dp[i][j - 1][k][l - 1], dp[i][j - 1][k - 1][l]))
//					+ m[i][j] + m[k][l];
//
//			}
//		}
//	}
//	cout << max(dp[n - 1][n][n][n - 1], dp[n][n - 1][n - 1][n]) + m[n][n] << endl;
//
//	system("pause");
//	return 0;
//}
//


//方格取数 网友答案
//#include <iostream>
//#include<algorithm>
//using namespace std;
//int n, i, j, tmp, k, l;
//int puz[20][20], dp[20][20][20][20];
//int main()
//{
//	scanf("%d", &n);
//	while (scanf("%d%d%d", &i, &j, &tmp) && i)
//		puz[i][j] = tmp;
//
//	for (i = 1; i <= n; i++)//第一条路径横纵坐标
//		for (j = 1; j <= n; j++)
//			for (k = 1; k <= n; k++)//第二条路径横纵坐标
//				for (l = 1; l <= n; l++) {
//					dp[i][j][k][l] = max(max(dp[i - 1][j][k - 1][l], dp[i][j - 1][k][l - 1]),
//						max(dp[i - 1][j][k][l - 1], dp[i][j - 1][k - 1][l])) + puz[i][j];
//					if (i != k || j != l) dp[i][j][k][l] += puz[k][l];
//				}
//	printf("%d\n", dp[n][n][n][n]);
//	return 0;
//}

//数的划分  有问题
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//int dp[10][220][200];
//int main() {
//	int apple, plate;
//	cin >> apple >> plate;
//	//dp[0][1][1] = 1;
//	//dp[1][1][1] = 1;
//	for (int i = 0; i <= plate; i++) {//初值不知道咋弄
//		dp[i][i][1] = 1;
//	}
//	for (int i = 2; i <= plate; i++) {
//		for (int j = 1; j <= apple; j++) {//这里应该错了  j从i开始应该
//			for (int k = 1; k <= j; k++) {
//				if (dp[i - 1][j][k] == 0) {//这里上一步的状态我不知道咋写
//					continue;
//				}
//				for (int y = k; y + j <= apple; y++) {
//					dp[i][j + y][y] += dp[i - 1][j][k];
//				}
//			}
//		}
//	}
//	int ans = 0;
//	for (int i = 1; i <= apple; i++) {
//		ans += dp[plate][apple][i];
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//
//数的划分  改了之后
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//int dp[10][220][200];
//int main() {
//	int apple, plate;
//	cin >> apple >> plate;
//	//dp[0][1][1] = 1;
//	//dp[1][1][1] = 1;
//	for (int i = 0; i <= apple; i++) {//初值不知道咋弄
//		dp[1][i][i] = 1;  
//	}
//	for (int i = 2; i <= plate; i++) {
//		for (int j = i - 1; j <= apple; j++) {//这里应该错了  j从i-1开始应该  因为事从i-1个盘子转移过来的
//			for (int k = 1; k <= j; k++) {
//				if (dp[i - 1][j][k] == 0) {
//					continue;
//				}
//				for (int y = k; y + j <= apple; y++) {
//					dp[i][j + y][y] += dp[i - 1][j][k];
//				}
//			}
//		}
//	}
//	int ans = 0;
//	for (int i = 1; i <= apple; i++) {
//		ans += dp[plate][apple][i];
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}



//数的划分 另一种思路
//#include<iostream>
//#include<cstring>
//#include<climits>
//#include<algorithm>
//using namespace std;
//int dp[1101][1101];//数组开大一点 就能跑过了 之前开dp[210][10]不过
//int main() {
//	int m, n;
//	cin >> m >> n;
//	for (int i = 1; i <= m; i++) {
//		dp[i][1] = 1;
//		dp[i][i] = 1;
//	}
//	for (int i = 2; i <= m; i++) {
//		for (int j = 1; j <= i; j++) {//分成j份
//			//dp[i - 1][j - 1]有一份是1  dp[i - j][j]每一份都大于1 
//			dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];
//
//		}
//	}
//	cout << dp[m][n] << endl;
//	system("pause");
//	return 0;
//}

//滑雪
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int dp[maxn][maxn];
//int r, c;
//int f(int i, int j) {
//	if (dp[i][j] != 0) {
//		return dp[i][j];
//	}
//	dp[i][j] = 1;
//	if (i > 1 && m[i - 1][j] < m[i][j]) {//下一步是向上走
//		dp[i][j] = max(dp[i][j], f(i - 1, j) + 1);
//	}
//	if (j > 1 && m[i][j - 1] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i, j - 1) + 1);
//	}
//	if (i < r && m[i + 1][j] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i + 1, j) + 1);
//	}
//	if (j < c && m[i][j + 1] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i, j + 1) + 1);
//	}
//	return dp[i][j];
//}
//int main() {
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			ans = max(ans, f(i, j));
//		}
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}



//核电站
//#include<cstdio>
//using namespace std;
//long long n, m, f[52][8], ans;
//int main()
//{
//	scanf("%lld%lld", &n, &m);
//	//  for (int i=1;i<=n;i++)
//	//  f[i][0]=1;
//	f[1][0] = 1;
//	f[1][1] = 1;
//	for (int i = 1; i <= n; i++)
//		for (int j = 0; j <= m - 1; j++)
//		{
//			//不放的话，前面的状态是什么都可以了，所以从f[i][0..m-1]推来
//			if (j == 0)//当前状态从前一个状态转移过来  所以当j==0是现在的状态 前一个状态是什么都可以
//			{
//				for (int k = 0; k <= m - 1; k++)
//					f[i][j] += f[i - 1][k];
//			}
//			//当前这个格子放的话，那么加上这个格子为j个，所以由j-1推来
//			else
//				f[i][j] += f[i - 1][j - 1];
//			if (i == n)
//				ans += f[i][j];
//		}
//	printf("%lld", ans);
//}

//9268:酒鬼 网友答案
//#include<iostream>
//#include<stdio.h>
//#include<algorithm>
//using namespace std;
//int a[710];
//int dp[710][4];//前i瓶中连续喝了j 瓶的最大酒量
//int main()
//{
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++)
//		cin >> a[i];
//	for (int i = 1; i <= n; i++) {
//		/*考虑第i瓶酒，连续喝了0瓶  即第i瓶不喝
//		此时最大值等于考虑i-1瓶酒的最大值 */
//		dp[i][0] = dp[i - 1][3];
//		//maxx记录的是考虑到第i瓶酒  能和的最大值
//		int maxx = dp[i][0];
//		cout << i << " " << 0 << " " << dp[i][0] << endl;
//		for (int j = 1; j <= 2; j++) {
//			dp[i][j] = dp[i - 1][j - 1] + a[i];
//			cout << i << " " << j << " " << dp[i][j] << endl;
//
//			maxx = max(maxx, dp[i][j]);
//		}
//		dp[i][3] = maxx;//用来存考虑前i个酒瓶能喝的最大值
//	}
//	printf("%d\n", dp[n][3]);
//	system("pause");
//	return 0;
//}

//9268:酒鬼 网友答案2 
//#include<iostream>
//#include<stdio.h>
//#include<algorithm>
//using namespace std;
//int n, i, k, a[1000], dp[1000];//喝到第i个酒瓶时可以喝到的最大的酒的体积
//int main()
//{
//	cin >> n;
//	for (i = 1; i <= n; i++)
//		cin >> a[i];
//	dp[1] = a[1]; dp[2] = a[1] + a[2];
//	for (i = 3; i <= n; i++)
//		//dp[i - 1]第i瓶不喝  dp[i - 2] + a[i]第i瓶喝 第i-1瓶不喝 相当于上面方法中的j=1  dp[i - 3] + a[i] + a[i - 1]第i，i-1瓶喝 第i-2瓶不喝 相当于上面方法中的j=2
//		dp[i] = max(dp[i - 1], max(dp[i - 2] + a[i], dp[i - 3] + a[i] + a[i - 1]));
//	cout << dp[n];
//	system("pause");
//	return 0;
//}

//偶数个数字3 网友答案
//#include <cstdio>
//int N;
//int dp[1010][2];
////dp[i][1]表示i位数有奇数个三的数量，dp[i][0]表示有偶数个三的数量
//int main() {
//	scanf("%d", &N); 
//	dp[1][1] = 1; //3
//	dp[1][0] = 9; //1 2 4 5 6 7 8 9 0
//	for (int i = 2; i <= N; ++i) {
//		int k = i == N ? 8 : 9;//当i==N时首位不能添加0
//		//dp[i][0]可以从dp[i - 1][0]首位添加0 1 2 4 5 6 7 8 9和dp[i - 1][1]首位添加3转移
//		dp[i][0] = dp[i - 1][0] % 12345 * k + dp[i - 1][1] % 12345;
//		//dp[i][1]可以从dp[i - 1][1]首位添加0 1 2 4 5 6 7 8 9和dp[i - 1][0]首位添加3转移
//		dp[i][1] = dp[i - 1][1] % 12345 * k + dp[i - 1][0] % 12345;
//	}
//	printf("%d", dp[N][0] % 12345);
//	return 0;
//}

//[Usaco2009 Feb]Bullcow
//#include<cstdio>
//#include<iostream>
//using namespace std;
//int main() {
//	//f[i][j]表示一共i只牛，最后一只是j（0为母牛，1为公牛）的方案数
//	int n, k, dp[100100][2];
//	scanf_s("%d%d", &n, &k);
//	dp[1][1] = dp[1][0] = 1;
//	for (int i = 2; i <= n; i++) {
//		//如果最后一头牛是母牛 那么前一头牛既可以是公牛也可以是母牛
//		dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % 5000011;
//		//现在考虑最后一头牛是公牛 分以下两种情况讨论
//		//这种情况前k头牛都必须事母牛  只有最后一头牛是公牛
//		if (i <= k + 1)
//			dp[i][1] = 1;
//		else
//			//第i头牛是公牛 所以第i-1 到第i-k必须是母牛 第i-k-1放公牛母牛均可
//			dp[i][1] = (dp[i - k - 1][0] + dp[i - k - 1][1]) % 5000011;
//	}
//	printf("%d\n", (dp[n][0] + dp[n][1]) % 5000011);
//	system("pause");
//	return 0;
//}


//Exchange Rates
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//#include<iomanip>
//using namespace std;
//const int maxn = 380;
//double m[maxn];
//double dp[maxn][2];
//double solve(double orin) {
//	int temp = floor(orin * 100);
//	double ans = double(temp) / 100.0;
//	return ans;
//}
//int main() {
//	int n;
//	//cout << fixed << setprecision(2) << solve(1001.6089);
//	while (cin >> n) {
//		if (n == 0) {
//			break;
//		}
//		memset(dp, 0, sizeof(dp));
//		for (int i = 1; i <= n; i++) {
//			cin >> m[i];
//		}
//		dp[0][0] = 1000.0;//0表示加元
//		dp[0][1] = 0.0;//1表示美元
//		for (int i = 1; i <= n; i++) {
//			dp[i][0] = max(dp[i-1][0], solve(dp[i - 1][1] * m[i] * 0.97));//注意这里是转移或者不转移两种情况
//			dp[i][1] = max(dp[i-1][1], solve(dp[i - 1][0] / m[i] * 0.97));
//			//cout << i << " " << dp[i][0] << " " << dp[i][1] << endl;
//		}
//		cout <<fixed<<setprecision(2)<< dp[n][0] << endl;
//		
//	}
//	system("pause");
//	return 0;
//}

//3.1数据结构之结构
//生日相同 2.0 ？？有注释的3个小细节要注意
//#include<iostream>
//#include<string>
//#include<algorithm>
//#include<vector>
//using namespace std;
//struct Node
//{
//	string name;
//	int month;
//	int day;
//	bool operator<(const Node a)const {
//		if (month != a.month) {
//			return month < a.month;
//		}
//		else if (day != a.day) {
//			return day < a.day;
//		}
//		else if (name.size() != a.name.size()) {
//			return name.size() < a.name.size();
//		}
//		else if (name != a.name) {//这里判断不仅仅是判断第一个字母 判断的是整个字符串
//			return name < a.name;
//		}
//	}
//};
//
//Node per[200];
//vector<string> ans;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].name >> per[i].month >> per[i].day;
//	}
//	//因为如果不加最后一个temp[n] 会导致最后一组一样的无法输出 所以要加一个一定不会出现的 用于输出最后一组
//	per[n].name = "wxz";
//	per[n].month = 100;
//	per[n].day = 100;
//	sort(per, per + n);
//	ans.push_back(per[0].name);
//	bool flag = false;
//	for (int i = 1; i <= n; i++) {
//		if (per[i].month == per[i - 1].month&&per[i].day == per[i - 1].day)
//		{
//			ans.push_back(per[i].name);
//		}
//		else {
//			//这里还要加一个判断 ans里面长度不止1  因为每个新的加进来都是1
//			if (ans.size() > 1) {
//				cout << per[i - 1].month << " " << per[i - 1].day;
//				for (auto itr = ans.begin(); itr != ans.end(); itr++) {
//					cout << " " << *itr;
//				}
//				flag = true;
//				cout << endl;
//			}
//			ans.clear();
//			ans.push_back(per[i].name);
//		}
//	}
//	if (!flag) {
//		cout << "None" << endl;
//	}
//	system("pause");
//	return 0;
//}

//3.6数据结构之二叉树
//二叉树
//#include<iostream>
//using namespace std;
//int main() {
//	int x, y;
//	cin >> x >> y;
//	while (x != y) {
//		if (x > y) {
//			x = x / 2;
//		}
//		else {
//			y = y / 2;
//		}
//	}
//	cout << x << endl;
//	system("pause");
//	return 0;
//}

//3.8数据结构之图
//Avoid The Lakes
//#include<iostream>
//#include<queue>
//#include<algorithm>
//#include<climits>
//#include<cstring>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int r, c, k;
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//struct Point
//{	
//	int x, y;
//};
//int bfs(int x, int y) {
//	Point start;
//	start.x = x;
//	start.y = y;
//	int step = 1;
//	queue<Point> q;
//	q.push(start);
//	vis[x][y] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 1) {
//				vis[next.x][next.y] = 1;
//				q.push(next);
//				step++;
//			}
//		}
//	}
//	return step;
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	cin >> r >> c >> k;
//	int tempx, tempy;
//	for (int i = 1; i <= k; i++) {
//		cin >> tempx >> tempy;
//		m[tempx][tempy] = 1;
//	}
//	int ans = 1;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (vis[i][j] == 0&&m[i][j] == 1) {
//				ans = max(ans, bfs(i, j));
//			}
//		}
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//围棋  ??注意一个细节
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//int n;
//const int maxn = 110;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int ans_w = 0;
//int ans_b = 0;
//struct Point
//{
//	int x, y;
//};
//void bfs(int x,int y) {
//	Point start;
//	start.x = x;
//	start.y = y;
//	queue<Point> q;
//	q.push(start);
//	vis[x][y] = 1;
//	int step = 1;
//	int flag = 0;//0表示白棋
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			if (next.x >= 1 && next.x <= n && next.y >= 1 && next.y <= n && vis[next.x][next.y] == 0)
//			{
//				vis[next.x][next.y] = 1;
//
//				if (m[next.x][next.y] == '.') {
//					step++;
//				}
//				if (m[next.x][next.y] == 'B') {
//					ans_b++;
//					flag = 1;//1表示黑棋
//				}
//				if (m[next.x][next.y] == 'W') {
//					ans_w++;
//					flag = 0;//0表示白棋
//				}
//				q.push(next);
//			}
//		}
//	}
//	if (flag) {
//		ans_b += step;
//	}
//	else {
//		ans_w += step;
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(vis, 0, sizeof(vis));
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {//这里不仅仅要遍历’.' 因为黑白棋可能不是在'.'包围着
//			if (m[i][j] == '.'&&vis[i][j] == 0) {
//				bfs(i,j);
//			}
//			if (m[i][j] == 'B'&&vis[i][j] == 0) {
//				ans_b++;
//				vis[i][j] = 1;
//			}
//			if (m[i][j] == 'W'&&vis[i][j] == 0) {
//				ans_w++;
//				vis[i][j] = 1;
//			}
//		}
//	}
//	cout << ans_b << " " << ans_w << endl;
//	system("pause");
//	return 0;
//}

//Is It A Tree?  自己写的 杭电上能通过 poj通不过
//#include<iostream>
//#include<cstring>
//#include<set>
//using namespace std;
//int in, out;
//int c = 1;
//const int maxn = 1005;
//int m[maxn];
//set<int> st;
//int root = 0;
//bool flag = true;
//int main() {
//	while (cin >> in >> out) {
//		if (in == -1 && out == -1) {
//			break;
//		}
//		if (in == 0 && out == 0) {
//			cout << "Case " << c;
//			c++;
//			for (auto itr = st.begin(); itr != st.end(); itr++) {
//				if (m[*itr] == 0) {
//					root++;
//					if (root > 1) {
//						flag = false;
//						break;
//					}
//				}
//				
//				if (m[*itr] > 1) {
//					flag = false;
//					break;
//				}
//			}
//			if (flag) {
//				cout << " is a tree." << endl;
//			}
//			else{
//				cout << " is not a tree." << endl;
//			}
//			memset(m, 0, sizeof(m));
//			st.clear();
//			root = 0;
//			flag = true;
//			continue;
//		}
//		else {
//			st.insert(in);
//			st.insert(out);
//			m[out] += 1;
//		}
//		
//	}
//}


//is it a tree 标答
//#include<iostream>
//#include<cstring>
//#include<set>
//using namespace std;
//
//const int N = 1000 + 5;
//
//set<int> S;
//
//int in[N];
//
//int a, b;
//
//int main() {
//	//freopen("in.txt", "r", stdin);
//	int cnt = 0;
//	while (cin >> a >> b) {
//		S.clear();
//		memset(in, 0, sizeof(in));
//		if (a < 0 && b < 0) {
//			break;
//		}
//		while (a != 0 && b != 0) {
//			if (!S.count(a)) {
//				S.insert(a);
//			}
//			if (!S.count(b)) {
//				S.insert(b);
//			}
//			in[b]++;
//			cin >> a >> b;
//		}
//		int flag = 1;
//		int root = 0;
//		for (set<int>::iterator it = S.begin(); it != S.end(); it++) {
//			if (in[*it] == 0) {
//				root++;
//				if (root > 1) {
//					flag = 0;
//					break;
//				}
//			}
//			if (in[*it] >= 2) {
//				flag = 0;
//				break;
//			}
//		}
//		if (flag) {
//			cout << "Case " << ++cnt << " is a tree." << endl;
//		}
//		else {
//			cout << "Case " << ++cnt << " is not a tree." << endl;
//		}
//	}
//
//	return 0;
//}

// 3.9数据结构之C++STL
//词典
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<map>
//using namespace std;
//map<string, string> mp;
//string tar;
//int main() {
//	string orin, forein;
//	string line;
//
//	while (getline(cin, line)) {
//		if (line.size() == 0) {
//			break;
//		}
//		stringstream ss(line);
//		ss >> orin;
//		ss >> forein;
//		mp.insert(pair<string, string>(forein, orin));
//	}
//	while (getline(cin, tar)) {
//		if (tar.size() == 0) {
//			break;
//		}
//		if (mp.find(tar) != mp.end()) {
//			cout << mp[tar] << endl;
//		}
//		else {
//			cout << "eh" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//Set
//#include<iostream>
//#include<set>
//#include<string>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	string op;
//	int x;
//	multiset<int> st;
//	set<int> rec;
//	for (int i = 1; i <= n; i++) {
//		cin >> op >> x;
//		if (op[0] == 'd') {
//			cout << st.count(x) << endl;
//			st.erase(x);
//		}
//		if (op[1] == 'd') {
//			st.insert(x);
//			rec.insert(x);
//			cout << st.count(x) << endl;;
//		}
//		if (op[1] == 's') {
//			if (rec.count(x) != 0) {
//				cout << 1 << " ";
//			}
//			else {
//				cout << 0 << " ";
//			}
//			cout << st.count(x) << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//热血格斗场
//#include<iostream>
//#include<map>
//#include<string>
//using namespace std;
//map<int, int> mp;
//int main() {
//	int n;
//	cin >> n;
//	int id, abi;
//	mp.insert(pair<int, int>(100000, 1));
//	for (int i = 1; i <= n; i++) {
//		cin >> id >> abi;
//		map<int, int>::iterator itr;
//		itr = mp.upper_bound(abi);
//		cout << id << " ";
//		if (itr == mp.end()) {
//			itr--;
//			cout << itr->second << endl;
//		}
//		else {
//			itr--;
//			if ((itr) == mp.begin()) {
//				itr++;
//				cout << itr->second << endl;
//			}
//			else {
//				int temp1 = abs(itr->second - abi);
//				itr++;
//				int temp2 = abs(itr->second - abi);
//				if (temp1 < temp2) {
//					itr--;
//					cout << itr->second << endl;
//				}
//				else if (temp1 > temp2) {
//					cout << itr->second << endl;
//				}
//				else {
//					itr--;
//					cout << itr->second << endl;
//				}
//			}
//		}
//		mp.insert(pair<int, int>(abi, id));
//
//	}
//	system("pause");
//	return 0;
//}

//2013年本科生夏令营及保研考试
//2013A
//#include<iostream>
//using namespace std;
//const int maxn = 110;
//int a[maxn];
//int b[maxn];
//int ansa[maxn];
//int ansb[maxn];
//int main() {
//	int cnta = 0, cntb = 0;
//	int n, na, nb;
//	cin >> n >> na >> nb;
//	for (int i = 0; i < na; i++) {
//		cin >> a[i];
//		//cout << a[i] << " ";
//	}
//	for (int i = 0; i < nb; i++) {
//		cin >> b[i];
//	}
//	for (int i = 0; i < n; i++) {
//		ansa[i] = a[i%na];
//		//cout << ansa[i] << " ";
//	}
//	//cout << endl;
//	for (int i = 0; i < n; i++) {
//		ansb[i] = b[i%nb];
//		//cout << ansb[i] << " ";
//
//	}
//	for (int i = 0; i < n; i++) {
//		if (ansa[i] == 0 && ansb[i] == 2) {
//			cnta++;
//		}
//		else if(ansa[i] == 2 && ansb[i] == 5) {
//			cnta++;
//		}
//		else if (ansa[i] == 5 && ansb[i] == 0) {
//			cnta++;
//		}
//		else if (ansa[i] == 0 && ansb[i] ==5) {
//			cntb++;
//		}
//		else if (ansa[i] == 2 && ansb[i] == 0) {
//			cntb++;
//		}
//		else if (ansa[i] == 5 && ansb[i] == 2) {
//			cntb++;
//		}
//		//cout<<i<<" " << cnta << " " << cntb << endl;
//	}
//	if (cnta == cntb) {
//		cout << "draw";
//	}
//	if (cnta < cntb) {
//		cout << "B";
//	}
//	if (cnta > cntb) {
//		cout << "A";
//	}
//	system("pause");
//	return 0;
//}

//B:冷血格斗场 ac
//#include<iostream>
//#include<map>
//#include<cmath>
//#include<iterator>
//using namespace std;
//int id, abi;
//int main()
//{
//	int n;
//	cin >> n;
//	map<int, int > mp;
//	mp[1000000000] = 1;
//	for (int i = 1; i <= n; i++)
//	{
//		cin >> id >> abi;
//		map<int, int>::iterator itr;
//		itr = mp.lower_bound(abi);
//		//int now_id;
//		if (itr == mp.end())
//		{
//			itr--;
//			//now_id = itr->second;
//		}
//		// else {
//		int now_cha = abs(itr->first - abi);
//		int now_id = itr->second;
//		if (itr != mp.begin())
//		{
//			itr--;
//			if (abs(itr->first - abi) < now_cha || (abs(itr->first - abi) == now_cha && itr->second <now_id))
//			{
//				now_id = itr->second;
//			}
//		}
//		//}
//		cout << id << " " << now_id << endl;
//		itr = mp.find(abi);
//		if (itr == mp.end() || itr->second>id)
//		{
//			mp[abi] = id;
//		}
//	}
//}



//C:上台阶
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int n;
//const int maxn = 110;
//int dp[maxn];
//int main() {
//	while (cin >> n) {
//		if (n == 0)break;
//		memset(dp, 0, sizeof(dp));
//		dp[0] = 0;
//		dp[1] = 1;
//		dp[2] = 2;
//		dp[3] = 4;
//		for (int i = 4; i <= n; i++) {
//			dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
//		}
//		cout << dp[n] << endl;
//	}
//}


//F:Dungeon Master
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//int h, r, c;
//int sx, sy, sz, ex, ey, ez;
//const int maxn = 35;
//int m[maxn][maxn][maxn];
//int vis[maxn][maxn][maxn];
//const int dirx[6] = { 0,0,1,-1,0,0 };
//const int diry[6] = { 1,-1,0,0,0,0 };
//const int dirz[6] = { 0,0,0,0,1,-1 };
//struct Point
//{
//	int x, y, z;
//	int step;
//
//};
//void bfs() {
//	Point start;
//	start.x = sx;
//	start.y = sy;
//	start.z = sz;
//	start.step = 0;
//	queue<Point> q;
//	q.push(start);
//	while (!q.empty()) {
//		Point now = q.front();
//		//cout << now.x << " " << now.y << " " << now.z << " " << now.step << endl;
//		q.pop();
//		if (now.x == ex && now.y == ey && now.z == ez) {
//			cout << "Escaped in " << now.step << " minute(s)." << endl;
//			return;
//		}
//		if (vis[now.x][now.y][now.z]) {
//			continue;
//		}
//		vis[now.x][now.y][now.z] = 1;
//		for (int i = 0; i < 6; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			next.z += dirz[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && next.z >= 1 && next.z <= h && vis[next.x][next.y][next.z] == 0 && m[next.x][next.y][next.z] == 0) {
//				next.step += 1;
//				q.push(next);
//			}
//
//		}
//	}
//	cout << "Trapped!" << endl;
//}
//int main() {
//	while (cin  >> h >> r >> c) {
//		if (r == 0 && c == 0 && h == 0) {
//			break;
//		}
//		memset(vis, 0, sizeof(vis));
//		memset(m, 0, sizeof(m));
//		char temp;
//		for (int k = 1; k <= h; k++) {
//			for (int i = 1; i <= r; i++) {
//				for (int j = 1; j <= c; j++) {
//					cin >> temp;
//					if (temp == '.') {
//						m[i][j][k] = 0;
//					}
//					if (temp == '#') {
//						m[i][j][k] = 1;
//					}
//					if (temp == 'S') {
//						m[i][j][k] = 0;
//						sx = i;
//						sy = j;
//						sz = k;
//					}
//					if (temp == 'E') {
//						m[i][j][k] = 0;
//						ex = i;
//						ey = j;
//						ez = k;
//					}
//				}
//			}
//		}
//		/*for (int k = 1; k <= h; k++) {
//			for (int i = 1; i <= r; i++) {
//				for (int j = 1; j <= c; j++) {
//					cout << m[i][j][k] << " ";
//				}
//				cout << endl;
//			}
//			cout << endl;
//			cout << endl;
//		}*/
//		bfs();
//	}
//}


//G:数字三角形
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int ans[maxn][maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= i; j++) {
//			cin >> m[i][j];
//			
//		}
//	}
//	//cout << "hhh" << endl;
//	ans[1][1] = m[1][1];
//	for (int i = 2; i <= n; i++) {
//		for (int j = 1; j <= i; j++) {
//			ans[i][j] = max(m[i][j] + ans[i - 1][j], m[i][j] + ans[i - 1][j - 1]);
//			//cout << ans[i][j] << " ";
//		}
//		//cout << endl;
//	}
//	int ans_max = INT_MIN;
//	for (int i = 1; i <= n; i++) {
//		ans_max = max(ans_max, ans[n][i]);
//	}
//	cout << ans_max << endl;
//	system("pause");
//	return 0;
//}

//H:Highways
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<algorithm>
//using namespace std;
//int num_city;
//const int maxn = 510;
//int ans = 0;
//int vis[maxn];
//int dis[maxn];
//struct Edge
//{
//	int v;
//	int w;
//	int next;
//};
//Edge edge[maxn *maxn];
//int head[maxn];
//int cnt = 0;
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//struct  Node
//{
//	int id;
//	int v;
//	Node() {};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node & a)const {
//		return v > a.v;//注意这里的符号！！！
//	}
//};
//void prime() {
//	priority_queue<Node> q;
//	dis[1] = 0;
//	q.push(Node(1, dis[1]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();//不要忘记pop（）
//		if (vis[u]) {
//			continue;
//		}
//		ans = max(ans, dis[u]);
//		/*ans += dis[u];*/
//		cout << u << "	" << ans << endl;
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			if (vis[v] == 0 && w < dis[v]) {
//				dis[v] = w;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	int cost;
//	for (int cnt = 1; cnt <= n; cnt++) {
//		memset(head, -1, sizeof(head));//初始化为-1
//		memset(vis, 0, sizeof(vis));
//		memset(dis, 0x3f, sizeof(dis));
//		cnt = 0;
//		ans = 0;
//
//		cin >> num_city;
//		for (int i = 1; i <= num_city; i++) {
//			for (int j = 1; j <= num_city; j++) {
//				cin >> cost;
//				if (i == j) {
//					continue;
//				}
//				else {
//					add_edge(i, j, cost);
//				}
//			}
//		}
//		/*for (int i = head[2]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			cout<<i<<" " << v << " " << w << endl;
//		}*/
//		prime();
//		cout << ans << endl;
//
//	}
//	system("pause");
//	return 0;
//}


//2014计算机学科夏令营上机考试
//A 人民币支付  http://noi.openjudge.cn/ch0113/13/
//#include<iostream>	
//using namespace std;
//int main() {
//	int x;
//	cin >> x;
//	int num_100 = x / 100;
//	x = x - 100 * num_100;
//	int num_50 = x / 50;
//	x = x - 50 * num_50;
//	int num_20 = x / 20;
//	x = x - 20 * num_20;
//	int num_10 = x / 10;
//	x = x - 10 * num_10;
//	int num_5 = x / 5;
//	x = x - 5 * num_5;
//	int num_1 = x;
//	cout << num_100 << endl << num_50 << endl << num_20 << endl << num_10 << endl << num_5 << endl << num_1;
//	system("pause");
//	return 0;
//}

//B:排队游戏
//#include<iostream>
//#include<string>
//#include<stack>
//using namespace std;
//int main() {
//	stack<int> st;
//	string str;
//	cin >> str;
//	int size = str.size();
//	char boy = str[0];
//	for (int i = 0; i < size; i++) {
//		if (str[i] == boy) {
//			st.push(i);
//		}
//		else {
//			cout << st.top() << " " << i << endl;
//			st.pop();
//		}
//	}
//	system("pause");
//	return 0;
//}

//C:取石子游戏 wa
//#include<iostream>
//using namespace std;
//int main() {
//	int a, b;
//	while (cin >> a >> b) {
//		if (a == 0 && b == 0) {
//			break;
//		}
//		if (a == 0 || b == 0) {
//			cout << "win" << endl;
//			continue;
//		}
//		if (a == b) {
//			cout << "win" << endl;
//			continue;
//		}
//		int cnt = 0;
//		while (a != 0 && b != 0) {
//			cnt++;
//			if (a > b) {
//				int t = a / b;
//				a = a - t * b;
//			}
//			else {
//				int t = b / a;
//				b = b - t * a;
//			}
//			
//		}
//		if (cnt % 2 == 1) {
//			cout << "win" << endl;
//		}
//		else {
//			cout << "lose" << endl;
//		}
//	}
//	//system("pause");
//	return 0;
//	
//}


//C:取石子游戏   根据提示
//#include<iostream>
//using namespace std;
//int suc = 0,flag = 1;
//void solve(int a, int b) {
//	if (a == 0 || b == 0) {
//		return;
//	}
//	if (a < b) {
//		int temp = b;
//		b = a;
//		a = temp;
//	}
//	if ((a / b) >= 2) {
//		//cout << "win" << endl;
//		//suc = 1;
//		return;
//	}
//	else {
//		flag = 1 - flag;//用来判断是谁赢 
//		solve(a - b, b);
//	}
//}
//int main() {
//	int a, b;
//	while (cin >> a >> b) {
//		//suc = 0;
//		flag = 1;
//		if (a == 0 && b == 0) {
//			break;
//		}
//		if (a == b) {
//			cout << "win" << endl;
//			continue;
//		}
//		solve(a, b);
//		if (flag) {
//			cout << "win" << endl;
//		}
//		else {
//			cout << "lose" << endl;
//		}
//	}
//	//system("pause");
//	return 0;
//
//}

//F:Battle City
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//int  r, c;
//int sx, sy, ex, ey;
//const int maxn = 310;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//const int dirx[4] = { 0,0,1,-1 };
//const int diry[4] = { 1,-1,0,0 };
//struct Point
//{
//	int x, y;
//	int step;
//	bool operator<(const Point & a)	const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = sx;
//	start.y = sy;
//	start.step = 0;
//	priority_queue<Point> q;//这里是优先队列呀！！！ 不要写成普通队列了
//	q.push(start);
//	while (!q.empty()) {
//		Point now = q.top();
//	//	cout << now.x << " " << now.y << " " << now.step << endl;
//		q.pop();
//		if (now.x == ex && now.y == ey) {
//			cout << now.step << endl;
//			return;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		vis[now.x][now.y] = 1;
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] != 1) {
//				if (m[next.x][next.y] == 2) {
//					next.step += 2;
//				}
//				if (m[next.x][next.y] == 0) {
//					next.step += 1;
//				}
//				
//				q.push(next);
//			}
//
//		}
//	}
//	cout << -1 << endl;
//}
//int main() {
//	while (cin >> r >> c) {
//		if (r == 0 && c == 0) {
//			break;
//		}
//		memset(vis, 0, sizeof(vis));
//		memset(m, 0, sizeof(m));
//		char temp;
//		
//			for (int i = 1; i <= r; i++) {
//				for (int j = 1; j <= c; j++) {
//					cin >> temp;
//					
//					if (temp == 'R') {
//						m[i][j] = 1;
//					}
//					if (temp == 'S') {
//						m[i][j] = 1;
//					}
//					if (temp == 'B') {
//						m[i][j] = 2;
//					}
//
//					if (temp == 'E') {
//						m[i][j] = 0;
//					}
//					if (temp == 'Y') {
//						m[i][j] = 0;
//						sx = i;
//						sy = j;
//					}
//					if (temp == 'T') {
//						m[i][j] = 0;
//						ex = i;
//						ey = j;
//					}
//				
//			}
//		}
//		
//		bfs();
//	}
//}

//Charm Bracelet
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 3500;
//int w[maxn];
//int v[maxn];
//long long dp[13000];//这里一定要开大一点  因为 M(1 ≤ M≤ 12,880) 不然runtime error
//int main() {
//	int n, tot;
//	cin >> n >> tot;
//	dp[0] = 0;
//	for (int i = 1; i <= n; i++) {
//		cin >> w[i] >> v[i];
//	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = tot; j >=w[i]; j--) {//这里注意 j >=w[i]
//			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
//			//cout << j << " " << dp[j] << endl;
//		}
//	}
//	cout << dp[tot] << endl;
//	system("pause");
//	return 0;
//}

//I:兔子与星空  最小生成树
//#include<iostream>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<cstring>
//using namespace std;
//const int maxn = 30;
//int m[maxn][maxn];
//int vis[maxn];
//int dis[maxn];
//int ans = 0;
//struct Edge
//{
//	int v;
//	int w;
//	int next;
//};
//
//Edge edge[100];
//int head[100];
//int cnt = 0;
//
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;//cnt初值是0
//}
//
//struct Node
//{
//	int id;//x
//	int v;//dix[x]
//	Node(){};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node& a)const {
//		return v > a.v;
//	}
//};
//
//priority_queue<Node> q;
//void Prim() {
//	memset(vis, 0, sizeof(vis));
//	memset(dis, 0x3f, sizeof(dis));
//	while (!q.empty()) {
//		q.pop();
//	}
//	dis[0] = 0;
//	
//	q.push(Node(0, dis[0]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();
//		if (vis[u] == 1) {
//			continue;
//		}
//		ans += dis[u];
//		//cout << ans << endl;
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			if (vis[v] == 0 && dis[v] > w) {
//				dis[v] = w;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//}
//int main() {
//	memset(m, 0, sizeof(m));
//	memset(head, -1, sizeof(head));
//	
//	cnt = 0;
//
//	int n;
//	cin >> n;
//	string line;
//	char city_s,city_e;
//	int w;
//	for (int i = 1; i < n; i++) {
//		cin >> city_s;
//		int num;
//		cin >> num;
//		for (int i = 0; i < num; i++) {
//			cin >> city_e >> w;
//			add_edge(city_s - 'A',city_e - 'A', w);
//			add_edge(city_e - 'A', city_s - 'A', w);
//		}
//	}
//	/*for (int i = head[8]; i != -1; i = edge[i].next) {
//		int v = edge[i].v;
//		int w = edge[i].w;
//		cout << v << " " << w << endl;
//	}*/
//
//	Prim();
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}


//2015计算机学科夏令营上机考试
//A:整数的个数
//#include<iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int temp;
//	int cnt_1 = 0, cnt_5 = 0, cnt_10 = 0;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		if (temp == 1) {
//			cnt_1++;
//		}
//		if (temp == 5) {
//			cnt_5++;
//		}
//		if (temp == 10) {
//			cnt_10++;
//		}
//	}
//	cout << cnt_1 << endl << cnt_5 << endl << cnt_10;
//		system("pause");
//		return 0;
//}

//B:过滤多余的空格
//#include<iostream>
//#include<string>
//#include<sstream>
//using namespace std;
//int main() {
//	string line;
//	getline(cin, line);
//	stringstream ss(line);
//	string temp;
//	while (ss >> temp) {
//		cout << temp << " ";
//	}
//	system("pause");
//	return 0;
//}

//C:二维数组右上左下遍历
//#include<iostream>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int main() {
//	int r, c;
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int i;
//	for (int k = 2; k <= r + c; k++) {
//		for (int j = c; j >=1; j--) {
//			i = k - j;
//			if (i >= 1 && i <= r) {
//				cout << m[i][j] << endl;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

////D:合影效果  自己写的 其实还可以用set<int,greater<int>> s;
//#include<iostream>
//#include<string>
//#include<iomanip>
//#include<set>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	string gender;
//	double h;
//	set<double> fe;
//	set<double> ma;
//	for (int i = 1; i <= n; i++) {
//		cin >> gender >> h;
//		if (gender[0] == 'm') {
//			ma.insert(h);
//		}
//		if (gender[0] == 'f') {
//			fe.insert(h);
//		}
//	}
//	for (auto itr = ma.begin(); itr != ma.end(); itr++) {
//		cout << fixed << setprecision(2) << *itr << " ";
//	}
//	auto itr = fe.end();
//	itr--;
//	for (; itr != fe.begin(); itr--) {
//		cout << fixed << setprecision(2) << *itr << " ";
//	}
//	cout << fixed << setprecision(2) << *itr;
//	system("pause");
//	return 0;
//}

//F:To Europe! To Europe!
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//#include<iomanip>
//using namespace std;
//int tot, len, num;
//const int maxn = 1010;
//int w[maxn];
//int sp[maxn];
//double dp[maxn];
//int main()
//{
//	while (cin >> tot >> len >> num)
//	{
//		if (tot == 0 && len == 0 && num == 0)
//		{
//			break;
//		}
//		memset(dp, 0, sizeof(dp));
//		memset(w, 0, sizeof(w));
//		memset(sp, 0, sizeof(sp));
//		len = len * 60;
//		for (int i = 1; i <= num; i++)
//		{
//			cin >> w[i] >> sp[i];
//		}
//		for (int i = 1; i <= num; i++)
//		{
//			int weight = w[i];
//			int speed = sp[i];
//			// cout<<i<<" "<<sp[i] <<endl;
//			dp[i] = dp[i - 1] + double(len) / double(speed);
//			//cout<<double(len)<<" "<<double(speed)<<" "<<dp[i]<<endl;
//			for (int j = i - 1; j >= 1; j--)
//			{
//				if (weight + w[j] > tot)
//				{
//					break;
//				}
//				else
//				{
//					weight += w[j];
//					speed = min(sp[j], speed);
//					dp[i] = min(dp[i], dp[j - 1] + double(len) / double(speed));
//				}
//			}
//		}
//		cout << fixed << setprecision(1) << dp[num] << endl;
//	}
//}


//G:The Game  过了
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<string>
//using namespace std;
//int  r, c;
//int sx, sy, ex, ey;
//const int maxn = 310;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//const int dirx[4] = { 0,0,1,-1 };
//const int diry[4] = { 1,-1,0,0 };
//int cnt = 1;
//int tot = 1;
//struct Point
//{
//	int x, y;
//	int step;
//	int dir;
//	bool operator<(const Point & a)	const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = sx;
//	start.y = sy;
//	start.step = 0;
//	start.dir = -1;
//	priority_queue<Point> q;//这里是优先队列呀！！！ 不要写成普通队列了
//	q.push(start);
//	while (!q.empty()) {
//		Point now = q.top();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		q.pop();
//		if (now.x == ex && now.y == ey) {
//			cout << "Pair " << tot << ": " << now.step << " segments." << endl;
//			return;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		vis[now.x][now.y] = 1;
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			next.dir = i;
//			if (next.x >= 0 && next.x <= r + 1 && next.y >= 0 && next.y <= c + 1 && vis[next.x][next.y] == 0 && m[next.x][next.y] != 1) {
//				if (next.dir != now.dir) {
//					next.step += 1;
//				}
//				q.push(next);
//			}
//
//		}
//	}
//	cout << "Pair " << tot << ": impossible." << endl;
//}
//int main() {
//	while (cin >> c >> r) {
//		if (r == 0 && c == 0) {
//			break;
//		}
//		tot = 1;
//		cout << "Board #" << cnt << ":" << endl;
//		cnt++;
//		
//		memset(m, 0, sizeof(m));
//		char temp;
//
//		string nonsense;
//		getline(cin, nonsense);
//
//		string line;
//		for (int i = 1; i <= r; i++) {
//			getline(cin, line);
//			//cout << "hhh" << endl;
//			//cout << line << endl;
//			for (int j = 0; j < c; j++) {
//				if (line[j] == 'X') {
//					m[i][j + 1] = 1;
//				}
//				if (line[j] == ' ') {
//					m[i][j + 1] = 0;
//				}
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		while (cin >> sy >> sx >> ey >> ex) {
//			if (sx == 0 && sy == 0 && ex == 0 && ey == 0) {
//				break;
//			}
//			m[ex][ey] = 0;
//			memset(vis, 0, sizeof(vis));//这里是每次样例都要重新置0！！！
//			bfs();
//			m[ex][ey] = 1;
//			tot++;
//		}
//		cout << endl;//每组样例之后都要输出空行！！！！
//	}
//	//system("pause");
//	return 0;
//}


//2016计算机学科夏令营上机考试
//A:分段函数
//#include<iostream>
//#include<iomanip>
//using namespace std;
//int main() {
//	double in;
//	double ans;
//	cin >> in;
//	if (in >= 0 && in < 5) {
//		ans = -in + 2.5;
//	}
//	if (in >= 5 && in < 10) {
//		ans = 2.0 - 1.5*(in - 3.0)*(in - 3.0);
//	}
//	if (in >= 10 && in < 20) {
//		ans = in / 2.0 - 1.5;
//	}
//	cout << fixed << setprecision(3) << ans;
//	system("pause");
//	return 0;
//}

//B:单词翻转 6分
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//int main() {
//	string line;
//	getline(cin, line);
//	int len = line.size();
//	//cout << len << endl;
//	string temp;
//	for (int i = 0; i < len; i++) {
//		//cout << i << " " << line[i] << endl;
//		if (line[i] != ' ') {//这儿不能写isalpha 因为可能是数字
//			temp += line[i];
//		}
//		if (line[i] == ' ') {
//			if (temp.size() != 0) {
//				reverse(temp.begin(),temp.end());
//				cout << temp;
//				temp.clear();
//			}
//			cout << line[i];
//		}
//	}
//	if (!temp.empty()) {
//		reverse(temp.begin(), temp.end());
//		cout << temp;
//	}
//	
//	system("pause");
//	return 0;
//}

//C:反反复复
//#include<iostream>
//#include<string>
//using namespace std;
//const int maxn = 22;
//char m[maxn][maxn];
//int main() {
//	int c;
//	cin >> c;
//	string orin;
//	cin >> orin;
//	int len = orin.size();
//	int r = len / c;
//	int k = 0;
//	for (int i = 0; i < r; i++) {
//		if (i % 2 == 0) {
//			for (int j = 0; j < c; j++) {
//				m[i][j] = orin[k++];
//			}
//		}
//		else {
//			for (int j = c-1; j >=0; j--) {
//				m[i][j] = orin[k++];
//			}
//		}
//		
//	}
//	/*for (int i = 0; i < r; i++) {
//		
//		for (int j = 0; j < c; j++) {
//			cout << m[i][j] << " ";
//		}
//		cout << endl;
//	}*/
//	for (int i = 0; i < c; i++) {
//		for (int j = 0; j < r; j++) {
//			cout << m[j][i];
//		}
//	}
//	system("pause");
//	return 0;
//}

//E:Exchange Rates  ac
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<iomanip>
//using namespace std;
//const int maxn = 400;
//double m[maxn];
//double dp[maxn][2];
//double solve(double x)
//{
//	double temp = x * 100.0;
//	int temp1 = temp;
//	//cout<<x<<"  "<<temp1<<" "<<temp<<endl;
//	double y = double(temp1) / 100.0;
//	return y;
//}
//int main()
//{
//	int d;
//	// cout<<solve(0.9999)<<" "<<solve(1.0500);
//	while (cin >> d)
//	{
//		if (d == 0)
//		{
//			break;
//		}
//		memset(m, 0, sizeof(m));
//		memset(dp, 0, sizeof(dp));
//		for (int i = 1; i <= d; i++)
//		{
//			cin >> m[i];//汇率是美元转加元
//		}
//		dp[0][0] = 1000.0;//加元
//		dp[0][1] = 0.0;//美元
//		for (int i = 1; i <= d; i++)
//		{
//			dp[i][0] = max(dp[i - 1][0], solve(dp[i - 1][1] * m[i] * 0.97));
//			dp[i][1] = max(dp[i - 1][1], solve(dp[i - 1][0] / m[i] * 0.97));
//			//cout<<dp[i][0]<<" "<<dp[i][1] <<endl;
//		}
//		cout << fixed << setprecision(2) << dp[d][0] << endl;
//	}
//	//system("pause");
//	return 0;
//}


//H:丛林中的路
//#include<iostream>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<cstring>
//using namespace std;
//const int maxn = 30;
//int m[maxn][maxn];
//int vis[maxn];
//int dis[maxn];
//int ans = 0;
//struct Edge
//{
//	int v;//终点
//	int w;//权重
//	int next;
//};
//
//Edge edge[100];
//int head[100];
//int cnt = 0;
//
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;//edge[i]表示第i条边的终点
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];//head[i]表示以i为起点的最后一条边的储存位置 
//	head[u] = cnt++;//cnt初值是0
//}
//
//struct Node
//{
//	int id;//x
//	int v;//dix[x]
//	Node() {};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node& a)const {
//		return v > a.v;
//	}
//};
//
//priority_queue<Node> q;
//void Prim() {
//	memset(vis, 0, sizeof(vis));
//	memset(dis, 0x3f, sizeof(dis));
//	while (!q.empty()) {
//		q.pop();
//	}
//	dis[0] = 0;
//
//	q.push(Node(0, dis[0]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();
//		if (vis[u] == 1) {
//			continue;
//		}
//		ans += dis[u];
//		//cout << ans << endl;
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {//head[i]表示以i为起点的最后一条边的储存位置 
//			int v = edge[i].v;
//			int w = edge[i].w;
//			if (vis[v] == 0 && dis[v] > w) {
//				dis[v] = w;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//}
//int main() {
//	
//
//	int n;
//	while (cin >> n) {
//		if (n == 0) {
//			break;
//		}
//		memset(m, 0, sizeof(m));
//		memset(head, -1, sizeof(head));
//		cnt = 0;
//		ans = 0;
//
//		char city_s, city_e;
//		int w;
//		for (int i = 1; i < n; i++) {
//			cin >> city_s;
//			int num;
//			cin >> num;
//			for (int i = 0; i < num; i++) {
//				cin >> city_e >> w;
//				add_edge(city_s - 'A', city_e - 'A', w);
//				add_edge(city_e - 'A', city_s - 'A', w);
//			}
//		}
//		/*for (int i = head[8]; i != -1; i = edge[i].next) {
//		int v = edge[i].v;
//		int w = edge[i].w;
//		cout << v << " " << w << endl;
//		}*/
//
//		Prim();
//		cout << ans << endl;
//	}
//
//
//	system("pause");
//	return 0;
//}

//I:Dominoes
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 1100;
//int up[maxn];
//int down[maxn];
//int cha;
//int dp[maxn][12010];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> up[i] >> down[i];
//	}
//	memset(dp, 0x3f, sizeof(dp));
//	dp[0][6000] = 0;//初始化是dp[0][6000] = 0
//	for (int i = 1; i <= n; i++) {
//		for (int j = 0; j <= 12000; j++) {
//			cha = up[i] - down[i];//这里不加6000  因为这里是差值 不需要偏移  偏移的应该是基准
//			dp[i][j] = min(dp[i - 1][j - cha], dp[i - 1][j + cha] + 1);
//		}
//	}
//	int ans = INT_MAX;
//	for (int i = 0; i <= 6000; i++) {
//		ans = min(dp[n][6000 - i], dp[n][6000 + i]);
//		if (ans <= n) {
//			cout << ans << endl;
//			break;
//		}
//	}
//}


// 2017计算机学科夏令营上机考试
//A:判决素数个数   0和1既不是素数,也不是合数,2是素数  考虑x>y
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int solve(int x) {
//	if (x == 1) {
//		return 0;
//	}
//	for (int i = 2; i <= sqrt(x); i++) {
//		if (x%i == 0) {
//			return 0;
//		}
//	}
//	//cout << x << endl;
//	return 1;
//}
//int main() {
//	int x, y;
//	cin >> x >> y;
//	int cnt = 0;
//	if (x > y) {
//		swap(x, y);
//	}
//	for (int i = x; i <= y; i++) {
//		cnt += solve(i);
//	}
//	cout << cnt;
//	system("pause");
//	return 0;
//}

//B:编码字符串  未提交
//#include<iostream>
//#include<string>
//using namespace std;
//int main() {
//	string line;
//	cin >> line;
//	string temp = "";
//	for (int i = 0; i < line.size(); i++) {
//		line[i] = tolower(line[i]);
//		if (temp.empty()) {
//			temp += line[i];
//		}
//		else {
//			if (temp[0] == line[i]) {
//				temp += line[i];
//			}
//			else {
//				cout << "(" << temp[0] << "," << temp.size() << ")";
//				temp = "";
//				temp += line[i];
//			}
//		}
//
//	}
//	if (!temp.empty()) {
//		cout << "(" << temp[0] << "," << temp.size() << ")";
//
//	}
//	system("pause");
//	return 0;
//}

//C:岛屿周长  没地方提交  https://blog.csdn.net/qq_34446716/article/details/85055844
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//const int dirx[4] = { 0,0,1,-1 };//记住加const
//const int diry[4] = { 1,-1,0,0 };
//int r, c;
//int cnt = 0;
//struct  Point
//{
//	int x, y;
//};
//void bfs(int x, int y) {
//	Point start;
//	start.x = x;
//	start.y = y;
//	for (int j = 0; j < 4; j++) {
//		Point next_start = start;
//		next_start.x += dirx[j];
//		next_start.y += diry[j];
//		//cout << nn.x << " " << nn.y << endl;
//		if (m[next_start.x][next_start.y] == 0) {
//			cnt++;
//		}
//	}
//	queue<Point> q;
//	q.push(start);
//	vis[x][y] = 1;
//	while (!q.empty()) {
//		Point now = q.front();
//		q.pop();
//		//cout << now.x << " " << now.y << " " << cnt << endl;
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			if (next.x >= 1 && next.x <= r && next.y >= 1 && next.y <= c && vis[next.x][next.y] == 0 && m[next.x][next.y] == 1) {
//				//cout << next.x << " " << next.y << endl;
//				vis[next.x][next.y] = 1;
//				for (int j = 0; j < 4; j++) {
//					Point nn = next;
//					nn.x += dirx[j];
//					nn.y += diry[j];
//					//cout << nn.x << " " << nn.y << endl;
//					if (m[nn.x][nn.y] == 0) {
//						cnt++;
//					}
//				}
//				q.push(next);
//			}
//		}
//	}
//
//}
//int main() {
//
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//			//cout << "hhh" << endl;
//
//		}
//	}
//	for (int i = 1; i <= 1; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (vis[i][j] == 0 &&m[i][j] ==1) {
//				bfs(i, j);
//				break;
//			}
//		}
//		break;
//	}
//	cout << cnt << endl;
//	system("pause");
//	return 0;
//}

//E:怪盗基德的滑翔翼
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//#include<iomanip>
//using namespace std;
//int num, n;
//const int maxn = 110;
//int m[maxn];
//int dp[maxn];
//int dp2[maxn];
//int main()
//{
//
//	cin >> num;
//	for (int cnt = 1; cnt <= num; cnt++)
//	{
//		cin >> n;
//		for (int cnt2 = 1; cnt2 <= n; cnt2++)
//		{
//			cin >> m[cnt2];
//		}
//		for (int i = 1; i <= n; i++)
//		{
//			dp[i] = 1;
//			for (int j = i - 1; j >= 1; j--)
//			{
//				if (m[i] > m[j])
//				{
//					dp[i] = max(dp[j] + 1, dp[i]);
//				}
//			}
//		}
//		for (int i = n; i >= 1; i--)
//		{
//			dp2[i] = 1;
//			for (int j = i + 1; j <= n; j++)
//			{
//				if (m[i] > m[j])
//				{
//					dp2[i] = max(dp2[j] + 1, dp2[i]);
//				}
//			}
//		}
//		int ans = 0;
//		for (int i = 1; i <= n; i++)
//		{
//			ans = max(ans, max(dp[i], dp2[i]));
//		}
//		cout << ans << endl;
//	}
//	return 0;
//}

//G:实现堆结构  百炼提交的网址和这道题 输入不一样
//#include<iostream>
//#include<cstring>
//#include<set>
//#include<iterator>
//using namespace std;
//int op;
//int ob;
//
//int main()
//{
//	int num, tot;
//	cin >> num;
//	multiset<int> st;//multiset 因为可能重复
//	cin >> tot;
//	for (int j = 1; j <= tot; j++)
//	{
//		cin >> op;
//		if (op == 1)
//		{
//			cin >> ob;
//			st.insert(ob);
//		}
//		if (op == 2)
//		{
//			set<int>::iterator itr;
//			itr = st.begin();
//			cout << *itr << endl;
//			st.erase(itr);//这里st.erase(itr)是指删除指针指向的元素 st.erase(*itr)  删除值等于这个的元素
//		}
//		//            for(set<int>::iterator p = st.begin();p!=st.end();p++){
//		//                cout<<*p<<" ";
//		//            }
//		//            cout<<endl;
//	}
//
//}


//The Game   wa ??
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<string>
//using namespace std;
//int  r, c;
//int sx, sy, ex, ey;
//const int maxn = 310;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//const int dirx[4] = { 0,0,1,-1 };
//const int diry[4] = { 1,-1,0,0 };
//int cnt = 1;
//int tot = 1;
//struct Point
//{
//	int x, y;
//	int step;
//	int dir;
//	bool operator<(const Point & a)	const {
//		return step > a.step;
//	}
//};
//void bfs() {
//	Point start;
//	start.x = sx;
//	start.y = sy;
//	start.step = 0;
//	start.dir = -1;
//	priority_queue<Point> q;//这里是优先队列呀！！！ 不要写成普通队列了
//	q.push(start);
//	while (!q.empty()) {
//		Point now = q.top();
//		//cout << now.x << " " << now.y << " " << now.step << endl;
//		q.pop();
//		if (now.x == ex && now.y == ey) {
//			cout << "Pair " << tot << ": " << now.step << " segments." << endl;
//			return;
//		}
//		if (vis[now.x][now.y]) {
//			continue;
//		}
//		vis[now.x][now.y] = 1;
//		for (int i = 0; i < 4; i++) {
//			Point next = now;
//			next.x += dirx[i];
//			next.y += diry[i];
//			next.dir = i;
//			if (next.x >= 0 && next.x <= r + 1 && next.y >= 0 && next.y <= c + 1 && vis[next.x][next.y] == 0 && m[next.x][next.y] != 1) {
//				if (next.dir != now.dir) {
//					next.step += 1;
//				}
//				q.push(next);
//			}
//
//		}
//	}
//	cout << "Pair " << tot << ": impossible." << endl;
//}
//int main() {
//	while (cin >> c >> r) {
//		if (r == 0 && c == 0) {
//			break;
//		}
//		tot = 1;
//		cout << "Board #" << cnt << ":" << endl;
//		cnt++;
//		memset(vis, 0, sizeof(vis));
//		memset(m, 0, sizeof(m));
//		char temp;
//
//		string nonsense;
//		getline(cin, nonsense);
//
//		string line;
//		for (int i = 1; i <= r; i++) {
//			getline(cin, line);
//			//cout << "hhh" << endl;
//			//cout << line << endl;
//			for (int j = 0; j < c; j++) {
//				if (line[j] == 'X') {
//					m[i][j + 1] = 1;
//				}
//				if (line[j] == ' ') {
//					m[i][j + 1] = 0;
//				}
//			}
//		}
//		/*for (int i = 1; i <= r; i++) {
//			for (int j = 1; j <= c; j++) {
//				cout << m[i][j] << " ";
//			}
//			cout << endl;
//		}*/
//		while (cin >> sy >> sx >> ey >> ex) {
//			if (sx == 0 && sy == 0 && ex == 0 && ey == 0) {
//				break;
//			}
//			m[ex][ey] = 0;
//			bfs();
//			m[ex][ey] = 1;
//			tot++;
//		}
//	}
//	//system("pause");
//	return 0;
//}

//2018计算机学科夏令营上机考试
//A:计算两个日期之间的天数  自己写
//#include<iostream>
//#include<cstring>
//using namespace std;
//int month[20] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
//int month_r[20] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 };
//int ans = 0;
//int tot = 0;
////int flag = 1;
//int main() {
//	int sy, sm, sd;
//	int ey, em, ed;
//	cin >> sy >> sm >> sd;
//	cin >> ey >> em >> ed;
//	for (int i = sy; i <= ey; i++) {
//
//		if ((i % 4 == 0 && i % 100 != 0) || i % 400 == 0) {
//			for (int j = 1; j <= 12; j++) {
//				if (i == sy && j < sm) {
//					continue;
//				}
//				for (int k = 1; k <= month_r[j]; k++) {
//
//					if (i == ey && j == em && k == ed) {
//						cout << tot;
//						system("pause");
//
//						return 0;
//					}
//					if (i == sy && j == sm && k < sd) {//i == sy && j == sm
//						continue;
//					}
//					else {
//						//flag = 0;
//						tot++;
//					}
//				}
//			}
//		}
//		else {
//			for (int j = 1; j <= 12; j++) {
//				if (i == sy && j < sm) {
//					continue;
//				}
//				for (int k = 1; k <= month[j]; k++) {
//
//					if (i == ey && j == em && k == ed) {
//						cout << tot;
//						system("pause");
//
//						return 0;
//					}
//					if (i == sy && j == sm && k < sd) {//i == sy && j == sm
//						continue;
//					}
//					else {
//						//flag = 0;
//						tot++;
//					}
//				}
//			}
//		}
//	}
//}

//A:计算两个日期之间的天数  网上答案
//#include<iostream>
//using namespace std;
//int bgyear, bgmonth, bgday;
//int enyear, enmonth, enday;
//int month[21] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };//非闰年
//int rmonth[21] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 };//闰年 
//int flag = 1;
//int tot = 0;
//int main()
//{
//	cin >> bgyear >> bgmonth >> bgday;
//	cin >> enyear >> enmonth >> enday;
//	for (int i = bgyear; i <= enyear + 1; i++)//寻找年数上的差异 
//	{
//		if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0))
//		{
//			for (int j = 1; j <= 12; j++)
//			{
//				if (i == bgyear && j < bgmonth)
//					continue;//寻找开始月份
//				for (int k = 1; k <= rmonth[j]; k++)
//				{
//					if (i == enyear && j == enmonth && k == enday)
//					{
//						cout << tot;
//						system("pause");
//						return 0;
//					}
//					if (k < bgday&&flag == 1)//寻找开始的那一天
//						continue;
//					else
//					{
//						flag = 0;
//						tot++;
//					}
//
//				}
//
//			}
//		}//闰年 
//		else
//		{
//
//			for (int j = 1; j <= 12; j++)
//			{
//				if (i == bgyear && j < bgmonth)
//					continue;//寻找开始月份
//				for (int k = 1; k <= month[j]; k++)
//				{
//					if (i == enyear && j == enmonth && k == enday)
//					{
//						cout << tot;
//						system("pause");
//						return 0;
//					}
//					if (k < bgday&&flag == 1)
//						continue;
//					else
//					{
//						flag = 0;
//						tot++;
//					}
//
//				}
//
//			}
//		}//非闰年 
//	}
//	cout << tot;
//	system("pause");
//	return 0;
//}

//B:回文子串  substr的用法 reverse的用法
//#include<iostream>
//#include<string>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//int suc = 0;
//int main() {
//	int n;
//	cin >> n;
//
//	for (int cnt = 1; cnt <= n; cnt++) {
//		string str;
//		cin >> str;
//		suc = 0;
//		int len = str.size();
//		for (int i = len; i >= 1; i--) {
//			string temp = "";
//			for (int j = 0; j < len - i + 1; j++) {
//				temp = str.substr(j, j + i);
//				//for (int k = j; k < j + i; k++) {
//				//	temp += str[k];
//				//	//cout << i << " " << j << " " << k << " " << temp << endl;
//				//}
//				
//				string temp2 = temp;
//				reverse(temp.begin(), temp.end());
//				if (temp == temp2) {
//					cout << temp2 << endl;
//					temp = "";
//					suc = 1;
//					break;
//				}
//				else {
//					temp = "";
//					//break;
//				}
//			}
//			if (suc) {
//				break;
//
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//D:Euro Efficiency  http://bailian.openjudge.cn/practice/1252/
//#include<iostream>
//#include<cstring>
//#include<iomanip>
//#include<climits>
//using namespace std;
//const int maxn = 2000 + 5;
//int dp[maxn];
//int m[7];
//int main()
//{
//	int n;
//	cin >> n;
//	for (int cnt = 1; cnt <= n; cnt++)
//	{
//		for (int i = 1; i <= 6; i++)
//		{
//			cin >> m[i];
//		}
//		for (int i = 1; i<maxn; i++)
//		{
//			dp[i] = i;
//		}
//		for (int i = 1; i <= 6; i++)
//		{
//			for (int j = m[i]; j<maxn; j++)
//			{
//				dp[j] = min(dp[j], dp[j - m[i]] + 1);
//			}
//
//		}
//		for (int i = 1; i <= 6; i++)
//		{
//			for (int j = maxn - 1 - m[i]; j >= 1; j--)
//			{
//				dp[j] = min(dp[j], dp[j + m[i]] + 1);
//			}
//		}
//		int sum = 0;
//		int max_v = INT_MIN;
//		for (int i = 1; i <= 100; i++)
//		{
//			sum += dp[i];
//			max_v = max(max_v, dp[i]);
//		}
//		cout << fixed << setprecision(2) << double(sum) / 100.0 << " " << max_v << endl;
//	}
//
//	// system("pause");
//	return 0;
//}


//2.4基本算法之分治
//求排列的逆序数  超时 https://blog.csdn.net/mrvector/article/details/81090165
//#include<iostream>
//#include<set>
//#include<iterator>
//#include<climits>
//using namespace std;
//const int maxn = 100010;
//int m[maxn];
//long long ans = 0;
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	multiset<int> s;
//	s.insert(INT_MAX);
//	
//	for (int i = n; i >= 1; i--) {
//		//cin >> temp;
//		ans += distance(s.begin(), s.lower_bound(m[i]));
//		s.insert(m[i]);
//	//	cout << i << " " << ans << endl;
//	}
//	cout << ans << endl;
//	system("pause");
//		return 0;
//}

//http://poj.org/problem?id=1258  最小生成树  多组数据
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//const int maxn = 110;
//int vis[maxn];
//int dis[maxn];
//long long ans = 0;
//struct Edge
//{
//	int v;
//	int w;
//	int next;
//};
//Edge edge[10000];
//int head[10000];
//int cnt = 0;
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//struct Node
//{
//	int id;
//	int v;
//	Node() {};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node& a)const {
//		return v > a.v;
//	}
//};
//priority_queue<Node> q;
//void prim() {
//	memset(vis, 0, sizeof(vis));
//	memset(dis, 0x3f, sizeof(dis));
//	while (!q.empty()) {
//		q.pop();
//	}
//	dis[1] = 0;//dis[0] = 0; 0不在节点中 这里可以用1-4为起点
//	q.push(Node(1, dis[1]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();//记住pop
//
//		if (vis[u]) {
//			continue;
//		}
//		vis[u] = 1;
//		ans += dis[u];
//		//cout << ans << endl;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			if (vis[v] == 0 && w < dis[v]) {
//				//cout << "hhh" << endl;
//				dis[v] = w;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//
//}
//int main() {
//	memset(head, -1, sizeof(head));
//	int n;
//	cin >> n;
//	int temp;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= n; j++) {
//			if (i == j) {
//				cin >> temp;
//				continue;
//			}
//			cin >> temp;
//			add_edge(i, j, temp);
//			//cout << i << " " << j << " " << temp << endl;
//		}
//	}
//	/*for (int i = head[2]; i != -1; i = edge[i].next) {
//		cout  << edge[i].v << " " << edge[i].w << endl;
//	}*/
//	prim();
//	cout << ans;
//	system("pause");
//	return 0;
//}

//E：重要逆序对
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 200010;
//int m[maxn];
//int temp[maxn];
//long long ans = 0;
//int n;
//void merge(int st, int ed, int mid) {
//	//memset(temp, 0, sizeof(temp));//可以不要这一行 会超时
//	int i = st;
//	int j = mid + 1;
//	int k = st;
//	int p = st;
//	while (i <= mid && j <= ed) {
//		if (m[i] > m[j]) {
//			temp[k] = m[j];
//			while (p <= mid && m[p] <= 2 * m[j]) {
//				p++;
//			}
//			if (p != mid + 1) {
//				ans += mid - p + 1;
//				//cout << ans << endl;
//			}
//			j++;
//		}
//		else {
//			temp[k] = m[i];
//			i++;
//		}
//		k++;
//	}
//	while (i <= mid) {
//		temp[k++] = m[i++];
//	}
//	while (j <= ed) {
//		temp[k++] = m[j++];
//	}
//	for (int i = st; i <= ed; i++) {
//		m[i] = temp[i];
//		//cout << temp[i] <<  " ";
//	}
//	//cout << endl;
//}
//void mergeSort(int st, int ed) {
//	int mid = (st + ed) / 2;
//	if (st < ed) {
//		mergeSort(st, mid);
//		mergeSort(mid + 1, ed);
//		merge(st, ed, mid);
//	}
//	
//}
//int main() {
//
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin>>m[i];
//	}
//	mergeSort(0, n - 1);
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//http://poj.org/problem?id=2299 逆序对
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 500010;
//int m[maxn];
//int temp[maxn];
//long long ans = 0;
//int n;
//void merge(int st, int ed, int mid) {
//	//memset(temp, 0, sizeof(temp));//可以不要这一行 会超时
//	int i = st;
//	int j = mid + 1;
//	int k = st;
//	int p = st;
//	while (i <= mid && j <= ed) {
//		if (m[i] > m[j]) {
//			temp[k] = m[j];
//
//			ans += mid - i + 1;
//			j++;
//		}
//		else {
//			temp[k] = m[i];
//			i++;
//		}
//		k++;
//	}
//	while (i <= mid) {
//		temp[k++] = m[i++];
//	}
//	while (j <= ed) {
//		temp[k++] = m[j++];
//	}
//	for (int i = st; i <= ed; i++) {
//		m[i] = temp[i];
//		//cout << temp[i] <<  " ";
//	}
//	//cout << endl;
//}
//void mergeSort(int st, int ed) {
//	int mid = (st + ed) / 2;
//	if (st < ed) {
//		mergeSort(st, mid);
//		mergeSort(mid + 1, ed);
//		merge(st, ed, mid);
//	}
//
//}
//int main() {
//	while (cin >> n) {
//		if (n == 0) {
//			break;
//		}
//		memset(m, 0, sizeof(m));
//		ans = 0;
//		for (int i = 0; i < n; i++) {
//			cin >> m[i];
//		}
//		mergeSort(0, n - 1);
//		cout << ans << endl;
//	}
//
//	//system("pause");
//	return 0;
//}

//http://poj.org/problem?id=1502  MPI Maelstrom
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//int num_city;
//const int maxn = 510;
//int ans = 0;
//int vis[maxn];
//int dis[maxn];
//struct Edge
//{
//	int v;
//	int w;
//	int next;
//};
//Edge edge[maxn *maxn];
//int head[maxn];
//int cnt = 0;
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//struct  Node
//{
//	int id;
//	int v;
//	Node() {};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node & a)const {
//		return v > a.v;//注意这里的符号！！！
//	}
//};
//void prime() {
//	priority_queue<Node> q;
//	dis[1] = 0;
//	q.push(Node(1, dis[1]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();//不要忘记pop（）
//		/*if (u == tar) {
//			return ans;
//		}*/
//		if (vis[u]) {
//			continue;
//		}
//		ans += dis[u];
//
//		/*ans += dis[u];*/
//		//cout << u << "	" << ans << endl;
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			//if (vis[v] == 0 && w < dis[v]) {
//			//	dis[v] = w;
//			//	q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			//}
//
//			if (vis[v] == 0 && w + dis[u] < dis[v]) {
//				dis[v] = w + dis[u];
//				q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			}
//		}
//	}
//}
//int main() {
//	
//	while (cin >> num_city) {
//		
//		string cost;
//		/*cin >> cost;
//		cout << cost << endl;*/
//		memset(head, -1, sizeof(head));//初始化为-1
//		memset(vis, 0, sizeof(vis));
//		memset(dis, 0x3f, sizeof(dis));
//		cnt = 0;
//		ans = 0;
//		for (int i = 2; i <= num_city; i++) {
//			for (int j = 1; j <= i - 1; j++) {
//				cin >> cost;
//				if (cost[0] == 'x') {
//					continue;
//				}
//				else {
//					stringstream ss(cost);//字符串转数字
//					int a;
//					ss >> a;
//					add_edge(i, j, a);
//					add_edge(j, i, a);
//				}
//
//			}
//		}
//		/*for (int i = head[5]; i != -1; i = edge[i].next) {
//		int v = edge[i].v;
//		int w = edge[i].w;
//		cout << i << " " << v << " " << w << endl;
//		}*/
//		prime();
//		int res = 0;
//		for (int i = 2; i <= num_city; i++) {
//			res = max(res, dis[i]);
//		}
//		//prime();
//		cout << res << endl;
//	}
//	
//	
//
//
//	//system("pause");
//	return 0;
//}


//http://poj.org/problem?id=2502
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//int num_city;
//const int maxn = 510;
//const int INF = 0x3f3f3f3f;
//double ans = 0;
//int vis[maxn];
//double dis[maxn];
//struct Edge
//{
//	int v;
//	double w;
//	int next;
//};
//Edge edge[maxn *maxn];
//int head[maxn];
//int cnt = 0;
//void add_edge(int u, int v, double w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//struct Point
//{
//	double x, y;
//};
//Point point[210];
//int tot = 3;
//struct  Node
//{
//	int id;
//	double v;
//	Node() {};
//	Node(int _id, double _v) :id(_id), v(_v) {};
//	bool operator<(const Node & a)const {
//		return v > a.v;//注意这里的符号！！！
//	}
//};
//double prime(int tar) {
//	priority_queue<Node> q;
//	dis[1] = 0;
//	q.push(Node(1, dis[1]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();//不要忘记pop（）
//		if (u == tar) {
//			return dis[tar];
//		}
//		if (vis[u]) {
//			continue;
//		}
//		//ans += dis[u];
//
//		/*ans += dis[u];*/
//		//cout << u << "	" << ans << endl;
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			double w = edge[i].w;
//			//if (vis[v] == 0 && w < dis[v]) {
//			//	dis[v] = w;
//			//	q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			//}
//
//			if (vis[v] == 0 && w + dis[u] < dis[v]) {
//				dis[v] = w + dis[u];
//				q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			}
//		}
//	}
//}
//int main() {
//
//	
//	while()
//	string cost;
//	memset(head, -1, sizeof(head));//初始化为-1
//	memset(vis, 0, sizeof(vis));
//	for (int i = 0; i < maxn; i++) {
//		dis[i] = INF;
//	}
//
//	cnt = 0;
//	ans = 0;
//	double sx, sy, ex, ey;
//	cin >> sx >> sy >> ex >> ey;
//	point[1].x = sx;
//	point[1].y = sy;
//	point[2].x = ex;
//	point[2].y = ey;
//
//	double len = sqrt((sx - ex)*(sx - ex) + (sy - ey)*(sy - ey));
//	add_edge(1, 2, len*3.0 / 500.0);
//	add_edge(2, 1, len*3.0 / 500.0);
//	double tempx, tempy;
//	int flag = 1;
//	while (cin >> tempx >> tempy) {
//		//cout << tempx << " " << tempy << endl;
//		if (tempx < 0 && tempy < 0) {
//			//cout << "hhh" << endl;
//			flag = 1;
//			continue;
//		}
//		point[tot].x = tempx;
//		point[tot].y = tempy;
//		if (!flag) {
//			len = sqrt((point[tot].x - point[tot - 1].x)*(point[tot].x - point[tot - 1].x) + (point[tot].y - point[tot - 1].y)*(point[tot].y - point[tot - 1].y));
//			add_edge(tot, tot - 1, len*3.0 / 2000.0);
//			add_edge(tot - 1, tot, len*3.0 / 2000.0);
//		}
//		else {
//			flag = 0;
//		}
//		tot++;
//	}
//	for (int i = 1; i <= tot - 1; i++) {
//		for (int j = i + 1; j <= tot - 1; j++) {
//			len = sqrt((point[i].x - point[j].x)*(point[i].x - point[j].x) + (point[i].y - point[j].y)*(point[i].y - point[j].y));
//			add_edge(i, j, len*3.0 / 500.0);
//			add_edge(j, i, len*3.0 / 500.0);
//		}
//	}
//	ans = prime(2);
//	
//
//	cout << round(ans) << endl;
//
//
//	//system("pause");
//	return 0;
//	
//}

//F:Tram http://poj.org/problem?id=1847
//#include<iostream>
//#include<cstring>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<algorithm>
//#include<cmath>
//using namespace std;
//int num_city, inter, df;
//const int maxn = 510;
//const int INF = 0x3f3f3f3f;
//int ans = 0;
//int vis[maxn];
//int dis[maxn];
//struct Edge
//{
//	int v;
//	double w;
//	int next;
//};
//Edge edge[maxn *maxn];
//int head[maxn];
//int cnt = 0;
//void add_edge(int u, int v, double w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//int tot = 3;
//struct  Node
//{
//	int id;
//	int v;
//	Node() {};
//	Node(int _id, double _v) :id(_id), v(_v) {};
//	bool operator<(const Node & a)const {
//		return v > a.v;//注意这里的符号！！！
//	}
//};
//int prime(int start, int tar) {
//	priority_queue<Node> q;
//	dis[start] = 0;
//	q.push(Node(start, dis[start]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();//不要忘记pop（）
//		if (u == tar) {
//			return dis[tar];
//		}
//		if (vis[u]) {
//			continue;
//		}
//
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			double w = edge[i].w;
//			//if (vis[v] == 0 && w < dis[v]) {
//			//	dis[v] = w;
//			//	q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			//}
//
//			if (vis[v] == 0 && w + dis[u] < dis[v]) {
//				dis[v] = w + dis[u];
//				q.push(Node(v, dis[v]));//这里是加Node(v, dis[v])！！！！
//			}
//		}
//	}
//	return -1;
//}
//int main() {
//
//	memset(head, -1, sizeof(head));//初始化为-1
//	memset(vis, 0, sizeof(vis));
//	for (int i = 0; i < maxn; i++) {
//		dis[i] = INF;
//	}
//	int start, tar;
//	cin >> num_city >> start >> tar;
//	cnt = 0;
//	ans = 0;
//
//	for (int i = 1; i <= num_city; i++) {
//		cin >> inter >> df;
//		add_edge(i, df, 0);
//		for (int j = 2; j <= inter; j++) {
//			cin >> df;
//			add_edge(i, df, 1);
//		}
//	}
//	ans = prime(start, tar);
//	cout <<ans<< endl;
//	system("pause");
//	return 0;
//
//}

//上交3题
////o(n^2)
////给定两个英文单词，每次操作可以删去任一单词中的任一字母，求使两个单词最终一样的最少操作次数
////Eg：给定eat和sea，最少操作次数为2。
////
////输入：eat sea
////输出：2
//#include<iostream>
//#include<cstring>
//#include<climits>
//#include<string>
//#include<algorithm>
//using namespace std;
//const int maxn = 10000;
//int dp[maxn][maxn];//dp[i][j]：a的前i位  b的前j位 加的最小字符数
//int main() {
//	string a, b;
//	while (cin >> a >> b) {
//		memset(dp, 0x3f, sizeof(dp));
//		int lena = a.size();
//		int lenb = b.size();
//		//cout << lena << " " << lenb << endl;
//		for (int i = 0; i <= lena; i++) {
//			dp[i][0] = i;
//		}
//		for (int i = 0; i <= lenb; i++) {
//			dp[0][i] = i;
//		}
//		for (int i = 1; i <= lena; i++) {
//			for (int j = 1; j <= lenb; j++) {
//				if (a[i - 1] == b[j - 1]) {
//					dp[i][j] = dp[i - 1][j - 1];
//				}
//				else {
//					dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1;
//				}
//				//cout << i << " " << j << " " << dp[i][j] << endl;
//			}
//		}
//		cout << dp[lena][lenb] << endl;
//	}
//
//	system("pause");
//	return 0;
//}
//
////第二题不会做
////商店中有若干商品(<10)，它们也会打包在一起优惠出售，现给出需要购买的商品数量，求最低购买价格。要求购买的商品数量刚好符合题目要求。
////
////	eg：
////	输入：
////	2
////	2 4
////	2
////	3 0 5
////	1 2 10
////	3 2
////
////	输出：13
////
////	题目解释：
////	输入：
////	第一行商品数目n
////	第二行每个商品的单独价格
////	第三行优惠组合数目m
////	接下来m行是优惠组合介绍：每一行每个套餐对应商品数目，最后一个是该优惠套餐的价格
////	最后一行是想买的各个商品数目
////	输出：
////	最低价格
////
////	举例：商店中有A、B两种商品，A价格为2元，B价格为4元；优惠组合一包含3个A商品，0个B商品，共5元；优惠组合二包含1个A商品，2个B商品，共10元；
////	现在要购买3个A商品，2个B商品；
////	答案：最低价格是，购买1个优惠组合一（含3个A、0个B），5元；再单独购买2个B，8元；共计13元
////
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 15;
//int a[maxn];
//int main() {
//	int  k;
//	//cin >> n;
//
//	for (int i = 0; i < 3; i++) {
//		cin >> a[i];
//	}
//	cin >> k;
//	for (int i = 1; i <= k; i++) {
//
//	}
//}
//
////附加题 一个有序三元组（a, b, c）, 1 <= a <= X, 1 <= b <= Y, 1 <= c <= Z，且a，b，c皆为正整数。
////给定X, Y, Z求所有能够形成三角形的(a, b, c)的数目。(3, 4, 5)和(3, 5, 4)为两个三角形。
////
////输入 : X Y Z（三个数都在1到10的九次方之间）
////	输出数量。输出结果对1000000007取模。
////
////	样例 :
////输入：2 3 3
////输出：9
////o(n^2)
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//int main() {
//	long long x, y, z;
//	while (cin >> x >> y >> z) {
//		long long ans = 0;
//		for (long long i = 1; i <= x; i++) {
//			for (long long j = 1; j <= y; j++) {
//				/*ans += min(i + j - 1, z) - (max(i - j, j - i) + 1) + 1;
//				ans = ans % 1000000007;*/
//
//				ans = (ans + min(i + j - 1, z) - (max(i - j, j - i) + 1) + 1) % 1000000007;
//			}
//		}
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}
//
////o(n)
////10000 10000 10000
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//const long long mod = 1000000007;
//long long a[3];
//int main() {
//	cin >> a[0] >> a[1] >> a[2];
//	sort(a, a + 3);
//	long long m = a[0];
//	long long n = a[1];
//	long long k = a[2];
//	long long res = (((m% mod)*(n%mod)) % mod)*((k%mod) % mod);
//	for (long long i = 1; i <= m; i++) {
//		res = res - ((i - 1)*i / 2);//b+c<=a  a-b>=c
//		res = res % mod;
//		res = res - ((n - i + 1)*(n - i) / 2);//a+c<=b   b-a>=c
//		res = res % mod;
//		long long  r = k - i;
//		long long l = max(1LL, (k - n - i + 1LL));
//		res = res - ((l + r)*(r - l + 1LL) / 2);//a+b<=c
//		res = res % mod;
//	}
//	res = (res %mod + mod) % mod;
//	cout << res << endl;
//	system("pause");
//	return 0;
//}

//Risk http://poj.org/problem?id=1603
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int n, temp;
//const int  maxn = 25;
//int m[maxn][maxn];
//const int INF = 0x3f3f3f3f;
//int cnt = 1;
//void floyd() {
//	for (int k = 1; k <= 20; k++) {//中间城市
//		for (int i = 1; i <= 20; i++) {//起始城市
//			if (m[i][k] != INF) {
//				for (int j = 1; j <= 20; j++) {//终止城市
//					m[i][j] = min(m[i][j], m[i][k] + m[k][j]);
//					//cout<<
//				}
//			}
//		}
//	}
//}
//int main() {
//	while (cin>>n) {//读到文件末 
//		memset(m, 0x3f, sizeof(m));
//		for (int j = 1; j <= n; j++) {//所以要特判第一组
//			cin >> temp;
//			m[1][temp] = 1;
//			m[temp][1] = 1;
//		}
//		for (int i = 2; i <= 19; i++) {
//			cin >> n;
//			for (int j = 1; j <= n; j++) {
//				cin >> temp;
//				m[i][temp] = 1;
//				m[temp][i] = 1;
//			}
//		}
//		floyd();
//		int tot;
//		int st, ed;
//		cin >> tot;
//		cout << "Test Set #" << cnt<<endl;
//		cnt++;
//		for (int i = 1; i <= tot; i++) {
//			cin >> st >> ed;
//			cout << st << " to " << ed << ": " << m[st][ed] << endl;
//		}
//		cout << endl;
//		
//	}
//}

////二叉树 已知前中序  求后序
//#include<iostream>
//#include<string>
//#include<vector>
//#include<cstring>
//using namespace std;
//vector<char> pre, in, post;
//void build(int la, int ra, int lb, int rb) {//左闭右开 la ra为中序  lb rb为先序
//	if (la >= ra) {
//		return;
//	}
//	char root = pre[lb];
//	int pos1, pos2;
//	pos1 = la;
//	while (in[pos1] != root) {
//		pos1++;
//	}
//	pos2 = pos1 - la;
//	build(la, la + pos2, lb + 1, lb + 1 + pos2);
//	build(la + pos2 + 1, ra, lb + 1 + pos2, rb);
//	post.push_back(root);
//}
//void print() {
//	for (auto itr = post.begin(); itr != post.end(); itr++) {
//		cout << *itr;
//	}
//}
//int main() {
//	string temp_pre, temp_in;
//	cin >> temp_pre >> temp_in;
//	for (int i = 0; i < temp_pre.size(); i++) {
//		pre.push_back(temp_pre[i]);
//		in.push_back(temp_in[i]);
//	}
//	int len = pre.size();
//	build(0, len, 0, len);
//	print();
//	system("pause");
//	return 0;
//}

//二叉树 已知后中序  求前序
//#include<iostream>
//#include<string>
//#include<vector>
//#include<cstring>
//using namespace std;
//vector<char> pre, in, post;
//void build(int la, int ra, int lb, int rb) {//左闭右开 la ra为中序  lb rb为后序
//	if (la >= ra) {
//		return;
//	}
//	char root = post[rb-1];
//	int pos1, pos2;
//	pos1 = la;
//	while (in[pos1] != root) {
//		pos1++;
//	}
//	pos2 = pos1 - la;
//	pre.push_back(root);
//	build(la, la + pos2, lb, lb + pos2);
//	build(la + pos2 + 1, ra, lb + pos2, rb - 1);
//}
//void print() {
//	for (auto itr = pre.begin(); itr != pre.end(); itr++) {
//		cout << *itr;
//	}
//}
//int main() {
//	string temp_post, temp_in;
//	cin >> temp_post >> temp_in;
//	for (int i = 0; i < temp_post.size(); i++) {
//		post.push_back(temp_post[i]);
//		in.push_back(temp_in[i]);
//	}
//	int len = in.size();
//	build(0, len, 0, len);
//	print();
//	system("pause");
//	return 0;
//}

//给出一个多叉树（多于二叉）的先序遍历和后序遍历，（每个节点以字符串表示），求该树的深度。
//#include<iostream>
//#include<cstring>
//#include<vector>
//#include<algorithm>
//#include<string>
//using namespace std;
//const int maxn = 100;
//int dp[maxn][maxn];
//int main() {
//	string pre, post;
//	cin >> pre >> post;
//	pre.reserve();
//	for (int i = 0; i < pre.size(); i++) {
//		for (int j = 0; j < post.size(); j++) {
//			if (pre[i] == post[j]) {
//				dp[i + 1][j + 1] = max(dp[i+1][j+1],dp[i][j] + 1);
//			}
//			else {
//				dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
//			}
//		}
//	}
//	cout << dp[pre.size()][post.size()] << endl;
//	system("pause");
//	return 0;
//}

//Tree Recovery http://poj.org/problem?id=2255
//#include<iostream>
//#include<string>
//#include<vector>
//#include<cstring>
//#include<iterator>
//using namespace std;
//vector<char> pre, in, post;
//void build(int la, int ra, int lb, int rb) {//左闭右开 la ra为中序  lb rb为后序
//	if (la >= ra) {
//		return;
//	}
//	char root = pre[lb];
////	cout << root << endl;
//
//	int pos1, pos2;
//	pos1 = la;
//	while (in[pos1] != root) {
//		pos1++;
//	}
//	pos2 = pos1 - la;
//	//cout << la << " "<<la + pos2 << " " << lb + 1 << " " << lb + 1 + pos2 << endl;
//	build(la, la + pos2, lb + 1, lb + 1 + pos2);
//	build(la + pos2 + 1, ra, lb + pos2 + 1, rb);
//	post.push_back(root);
//}
//void print() {
//	for (vector<char>::iterator itr = post.begin(); itr != post.end(); itr++) {
//		cout << *itr;
//	}
//	cout << endl;
//}
//int main() {
//	string temp_pre, temp_in;
//	while (cin >> temp_pre >> temp_in) {
//		pre.clear();
//		in.clear();
//		post.clear();
//		for (int i = 0; i < temp_pre.size(); i++) {
//			pre.push_back(temp_pre[i]);
//			in.push_back(temp_in[i]);
//		}
//		int len = in.size();
//		build(0, len, 0, len);
//		print();
//	}
//
//
//	//system("pause");
//	return 0;
//}

//给出初始单词，终止单词，以及词典，所有单词均为长度相等的小写字母串，求从初始单词变换到终止单词的路径长度。每次变换只允许改变一个字符，且所有中间单词只能是词典中的，若不能做到则输出0。
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<map>	
//#include<queue>
//using namespace std;
//map<string, int> mp;
//map<string, int > vis;
//string st, ed;
//int ans = 0;
//struct  Node
//{
//	string str;
//	int step;
//	Node() {};
//	Node(string _str, int _step) :str(_str), step(_step) {};
//};
//void bfs() {
//	queue<Node> q;
//	q.push(Node(st, 1));
//	while (!q.empty()) {
//		Node now = q.front();
//		q.pop();
//		if (now.str == ed) {
//			ans = now.step;
//			return;
//		}
//		if (vis[now.str] == 1) {
//			continue;
//		}
//		vis[now.str] == 1;
//		for (int i = 0; i <= st.length(); i++) {
//			for (char j = 'a'; j <= 'z'; j++) {
//				Node next = now;
//				next.str[i] = j;
//				if (mp[next.str] == 1 && vis[next.str] == 0) {
//					next.step += 1;
//					q.push(next);
//				}
//			}
//		}
//		
//	}
//}
//int main() {
//
//	cin >> st >> ed;
//	int n;
//	cin >> n;
//	string temp;
//	for (int i = 1; i <= n; i++) {
//		cin >> temp;
//		mp[temp] = 1;
//	}
//	bfs();
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//Count number of binary strings without consecutive 1’s
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100;
//long long dp[maxn][2];//dp[i][0]表示第位是0 dp[i][1]表示第位是1
//int main() {
//	int n;
//	cin >> n;
//	dp[2][0] = 2;
//	dp[2][1] = 1;
//	for (int i = 3; i <= n; i++) {
//		dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
//		dp[i][1] = dp[i - 1][0] ;
//	}
//	cout << dp[n][0] + dp[n][1] << endl;
//	system("pause");
//	return 0;
//}


//法2
//#include <iostream>
//#define N 90+5
//
//using namespace std;
//
//long long dp[N];
//
//int main()
//{
//	int n;
//
//	dp[1] = 2, dp[2] = 3;
//
//	cin >> n;
//
//	for (int i = 3; i <= n; i++) {
//		dp[i] = dp[i - 1] + dp[i - 2];
//	}
//
//	cout << dp[n] << endl;
//	system("pause");
//	return 0;
//}

//给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
//被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
//示例:
//
//X X X X
//X O O X
//X X O X
//X O X X
//运行你的函数后，矩阵变为：
//
//X X X X
//X X X X
//X X X X
//X O X X

//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 100;
//char m[maxn][maxn];
//int vis[maxn][maxn];
//int dirx[4] = { 0,0,1,-1 };
//int diry[4] = { 1,-1,0,0 };
//int r, c;
//void dfs(int x, int y) {
//	for (int i = 0; i < 4; i++) {
//		int nx = x + dirx[i];
//		int ny = y + dirx[i];
//		if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && vis[nx][ny] == 0 && m[nx][ny] == 'O') {
//			vis[nx][ny] = 1;
//			dfs(nx, ny);
//		}
//	}
//}
//int main() {
//	
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		if (m[i][1] == 'O'&&vis[i][1] == 0) {
//			vis[i][1] = 1;
//			dfs(i, 1);
//		}
//		if (m[i][c] == 'O'&&vis[i][c] == 0) {
//			vis[i][c] = 1;
//			dfs(i, c);
//		}
//	}
//	for (int i = 1; i <= c; i++) {
//		if (m[1][i] == 'O'&&vis[1][i] == 0) {
//			vis[1][i] = 1;
//			dfs(1, i);
//		}
//		if (m[r][i] == 'O'&&vis[r][i] == 0) {
//			vis[r][i] = 1;
//			dfs(r, i);
//		}
//	}
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			if (m[i][j] == 'X') {
//				cout << "X"<<" ";
//			}
//			else {
//				if (vis[i][j] == 1) {
//					cout << "O" << " ";
//				}
//				else {
//					cout << "X" << " ";
//				}
//			}
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//最长上升子序列的加强版 http://poj.org/problem?id=1836
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;
//double m[maxn];
//int dp1[maxn], dp2[maxn];
//int main() {
//	int n;
//	while (cin >> n) {
//		memset(dp1, 0, sizeof(dp1));
//		memset(dp2, 0, sizeof(dp2));
//		for (int i = 1; i <= n; i++) {
//			cin >> m[i];
//		}
//		for (int i = 1; i <= n; i++) {
//			dp1[i] = 1;
//			for (int j = 1; j < i; j++) {
//				if (m[j] < m[i]) {
//					dp1[i] = max(dp1[j] + 1, dp1[i]);
//				}
//			}
//		}
//		for (int i = n; i >= 1; i--) {
//			dp2[i] = 1;
//			for (int j = n; j > i; j--) {
//				if (m[i] > m[j]) {
//					dp2[i] = max(dp2[j] + 1, dp2[i]);
//				}
//			}
//		}
//		int ans = 0;
//		for (int i = 1; i <= n; i++) {
//			for (int j = i + 1; j <= n; j++) {
//				ans = max(ans, dp1[i] + dp2[j]);
//			}
//		}
//		//cout << ans << endl;
//		cout << n - ans << endl;
//	}
//
//	//system("pause");
//	return 0;
//}

//多重背包问题 标答  ??
//#include <iostream>
//#include <stdio.h>
//#include<algorithm>
//#define N 100+5
//#define B 1000+100
//const int inf = 123123123;
//using namespace std;
//int dp[N][B + 1];
//int main()
//{
//	int T, n, m;
//	int b, p;
//	cin >> T;
//	for (int t = 1; t <= T; t++) {
//		cin >> n;
//		for (int i = 0; i <= B; i++)
//			dp[0][i] = 0;
//
//		for (int i = 1; i <= n; i++) {//因为每一个制造商必须选一个商品，因此一开始要初始化为无穷大，
//									  //使得dp[i][j]至少更新一次
//			for (int j = 0; j <= B; j++) {
//				dp[i][j] = inf;
//			}
//		}
//		for (int i = 1; i <= n; i++) {//遍历生产商
//			cin >> m;
//			for (int j = 1; j <= m; j++) {//遍历生产商i的商品
//				cin >> b >> p;//输入该生产商的m个设备
//				for (int k = 0; k <= B; k++) {//遍历带宽
//
//					if (dp[i - 1][k] != inf) {
//
//						if (k <= b) {//当前商品的带宽小于给定带宽时
//							dp[i][k] = min(dp[i][k], dp[i - 1][k] + p);
//						}
//						else
//							dp[i][b] = min(dp[i][b], dp[i - 1][k] + p);
//					}
//				}
//			}
//		}
//		double ans = 0;
//		for (int j = 0; j <= B; j++) {//遍历所有的
//			if (dp[n][j] != inf) {
//				ans = max(ans, j*1.0 / dp[n][j]);
//			}
//		}
//		printf("%.3f\n", ans);
//	}
//	system("pause");
//	return 0;
//}

//计算表达式 标答
/*
实现中缀表达式的计算求值
步骤总览:
中缀表达式->后缀表表达式->利用操作数栈辅助求值
中缀表达式->后缀表达手：
step1: 声明符号栈S，从左到右扫描输入的字符串，得到当前字符c
step2: if c is digit:
then c加入到后缀表达式的输出中
step3: if c is '(':
then c S.push(c)
step4: if c is ')':
逐一弹出S中的元素加入到后缀表达式的输出中，知道遇到'('为止，并将其丢弃
step5: while(c is 操作符)
if 栈顶为空 或者 S.top为'(' 或者 c的优先级比S.top高
S.push(c)
break
else
弹出栈顶元素加入到后缀表达式的输出中
step6: 跳转到step1,直到字符串扫描结束为止
step7: 如果此时栈S仍不为空,则将栈内的元素逐一弹出,加入到后缀表达式的输出中
后缀表表达式->利用操作数栈辅助求值：
维护一个数字栈S
扫描得到的后缀表达式的字符串
if(当前字符为数字)
S.push(当前数字)
else//当前字符为操作符(这里需要注意运算时操作数的顺序)
根据操作符运算所需的操作数个数，弹出栈顶元素进行运算
并将运算的结果压入到栈中
字符串识别结束后，栈内只有一个元素，即运算的结果。
*/
/*
(3^2/(2+1))-3*(4-5)+2!
1+2!-3*(4-5)
1+2*(3-4)-5*6
*/

//#include <iostream>
//#include <string>
//#include <stack>
//#include <map>
//using namespace std;
//stack<char> Op;
//map<int, int> prior;
//bool isOp(char c) {
//	if (c == '-' || c == '+' || c == '*' || c == '/' || c == '^' || c == '!')
//		return true;
//	else
//		return false;
//}
//
//int jiechen(int n) {//阶乘
//	int x = 1;
//	for (int i = 1; i <= n; i++) {
//		x *= i;
//	}
//	return x;
//}
//
//int power(int x, int n) {
//	int ans = 1;
//	for (int i = 1; i <= n; i++) {
//		ans *= x;
//	}
//	return ans;
//}
//
//int main()
//{
//
//	prior['+'] = 1, prior['-'] = 1, prior['*'] = 2, prior['/'] = 2, prior['^'] = 3, prior['!'] = 4;
//
//	string src = "", tar = "";//src为中缀表达式，tar为后缀表达式
//
//	cin >> src;
//	int len = src.size();
//
//	//中缀表达式转为后缀表达式
//	for (int i = 0; i<len; i++) {//扫描输入的字符串
//		if (src[i] <= '9'&&src[i] >= '0')//当输入为操作数时
//			tar += src[i];
//		else if (src[i] == '(')//当输入为左括号时
//			Op.push(src[i]);
//		else if (src[i] == ')') {//当输入为右括号时
//			while (Op.top() != '(') {
//				tar += Op.top();
//				Op.pop();
//			}
//			Op.pop();
//		}
//		while (isOp(src[i])) {//当输入为操作符时
//			if (Op.size() == 0 || Op.top() == '(' || prior[Op.top()]<prior[src[i]]) {
//				Op.push(src[i]);
//				break;
//			}
//			else {
//				tar += Op.top();
//				Op.pop();
//			}
//		}
//	}
//	while (Op.size() != 0) {//当输入结束时，如果栈内还有元素的话
//		tar += Op.top();
//		Op.pop();
//	}
//	cout << tar << endl;
//
//	//后缀表达式求值
//	int lentar = tar.size();
//
//	stack<int> Num;
//	for (int i = 0; i<lentar; i++) {
//		if (tar[i] <= '9'&&tar[i] >= '0') {
//			Num.push(tar[i] - '0');
//		}
//		else {
//			int num1, num2;
//			if (tar[i] == '+') {
//				num1 = Num.top(), Num.pop();
//				num2 = Num.top(), Num.pop();
//				Num.push(num1 + num2);
//			}
//			else if (tar[i] == '-') {//注意操作数的运算顺序
//				num1 = Num.top(), Num.pop();
//				num2 = Num.top(), Num.pop();
//				Num.push(num2 - num1);
//			}
//			else if (tar[i] == '*') {
//				num1 = Num.top(), Num.pop();
//				num2 = Num.top(), Num.pop();
//				Num.push(num1*num2);
//			}
//			else if (tar[i] == '/') {//注意操作数的运算顺序
//				num1 = Num.top(), Num.pop();
//				num2 = Num.top(), Num.pop();
//				Num.push(num2 / num1);
//			}
//			else if (tar[i] == '^') {//注意操作数的运算顺序
//				num1 = Num.top(), Num.pop();
//				num2 = Num.top(), Num.pop();
//				Num.push(power(num2, num1));
//			}
//			else if (tar[i] == '!') {//注意操作数的运算顺序
//				num1 = Num.top(), Num.pop();
//				Num.push(jiechen(num1));
//			}
//		}
//	}
//	cout << Num.size() << endl;
//	cout << "The result is:" << Num.top() << endl;
//	system("pause");
//	return 0;
//}


//求树上最长的路径长度 Roads in the North  http://poj.org/problem?id=2631 
/*
5 1 6
1 4 5
6 3 9
2 6 8
6 1 7
0 0 0
*/
//#include<iostream>
//#include<queue>
//#include<string>
//#include<sstream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 10010;
//int m[maxn][maxn];
//int vis[maxn];
//int dis[maxn];
//int ans = 0, max_ans = 0;
//int temp_id;
//struct Edge
//{
//	int v;
//	int w;
//	int next;
//};
//
//Edge edge[maxn*maxn];
//int head[maxn];
//int cnt = 0;
//
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;//cnt初值是0
//}
//
//struct Node
//{
//	int id;//x
//	int v;//dix[x]
//	Node() {};
//	Node(int _id, int _v) :id(_id), v(_v) {};
//	bool operator<(const Node& a)const {
//		return v > a.v;//从大到小排序
//	}
//};
//
//priority_queue<Node> q;
//void bfs(int st) {
//	max_ans = 0;
//	memset(vis, 0, sizeof(vis));
//	memset(dis, 0, sizeof(dis));//因为这里求最大值 所以初值设成最小值
//	while (!q.empty()) {
//		q.pop();
//	}
//	dis[st] = 0;
//
//	q.push(Node(st, dis[st]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();
//		if (vis[u] == 1) {
//			continue;
//		}
//
//		if (dis[u] > max_ans) {
//			max_ans = dis[u];
//			temp_id = u;
//		}
//
//		//cout << ans << endl;
//		vis[u] = 1;
//		//cout << u << " " << max_ans << endl;
//
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			if (vis[v] == 0 && dis[v] < dis[u] + w) {
//				dis[v] = dis[u] + w;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//}
//int main() {
//	//memset(m, 0, sizeof(m));
//	memset(head, -1, sizeof(head));
//
//	cnt = 0;
//	int st, ed, len;
//	while (cin >> st >> ed >> len) {
//		add_edge(st, ed, len);
//		add_edge(ed, st, len);
//	}
//	/*for (int i = head[1]; i != -1; i = edge[i].next) {
//		int v = edge[i].v;
//		int w = edge[i].w;
//		cout << v << " " << w << endl;
//	}*/
//
//	bfs(1);
//	//cout << "temp_id" << temp_id << endl;
//	bfs(temp_id);
//	cout << max_ans << endl;
//	system("pause");
//	return 0;
//}

//给定一个n层的满二叉树，不存在的结点用-1表示，同时给定一个sum，问从根结点到达叶节点有哪些路径使得点权和刚好为sum。从左到右输出所有满足条件的路径。
//#include <iostream>
//#include <queue>
//#include <stack>
//#define N 1000+5
//using namespace std;
//int loc;
//int n, sum;
//void init() {
//	loc = 0;
//}
//int A[N];
//struct TreeNode {
//	int data;
//	TreeNode* lchild;
//	TreeNode* rchild;
//}Tree[N];
//
//TreeNode* create() {
//	Tree[loc].lchild = Tree[loc].rchild = NULL;
//	return &Tree[loc++];
//}
//queue<TreeNode*> Que;
//stack<int> S, Stmp;
//vector<int> res;
//void dfs(TreeNode* T, int curSum) {
//	S.push(T->data);
//	curSum += T->data;
//	if (T->lchild == NULL && T->rchild == NULL && curSum == sum) {
//		res.clear();
//		Stmp = S;
//		while (!Stmp.empty()) {
//			res.push_back(Stmp.top());
//			Stmp.pop();
//		}
//		for (int i = res.size() - 1; i >= 0; i--) {
//			cout << res[i] << " ";
//		}
//		cout << endl;
//	}
//	if (T->lchild != NULL)
//		dfs(T->lchild, curSum);
//	if (T->rchild != NULL)
//		dfs(T->rchild, curSum);
//	curSum -= T->data;
//	S.pop();
//}
//int main()
//{
//	while (~scanf("%d%d", &n, &sum)) {
//
//		for (int i = 0; i < n; i++)
//			cin >> A[i];
//
//		while (!Que.empty())
//			Que.pop();
//		while (!S.empty())
//			S.pop();
//		TreeNode* T = create();
//		T->data = A[0];
//		Que.push(T);
//		int pos = 0;
//		while (!Que.empty()) {//层次遍历建树
//			TreeNode* tmp = Que.front();
//			Que.pop();
//			if (pos < n&&A[++pos] != -1) {
//				TreeNode* lt = create();
//				lt->data = A[pos];
//				tmp->lchild = lt;
//				Que.push(lt);
//			}
//			if (pos < n&&A[++pos] != -1) {
//				TreeNode* rt = create();
//				rt->data = A[pos];
//				tmp->rchild = rt;
//				Que.push(rt);
//			}
//		}
//		dfs(T, 0);
//	}
//	return 0;
//}


//给定由IF，THEN，ELSE，BEGIN，END构成的一组语句，判断该语句的嵌套结构是否符合语法规范
//#include <iostream>
//#include <string>
//#include <sstream>
//#include <stack>
//
//using namespace std;
//
//const int N = 1000 + 5;
//
//string Token, TokenSet[N], src;
//stack<string> S1, S2;//其中S2专门用来判断ELSE是否合法,当IF-THEN匹配完之后把THEN压入到S2中，
//					 //只有当S2不为空时才能匹配ELSE。
//
//bool Syntax(int len) {
//	while (!S1.empty())S1.pop();
//	while (!S2.empty())S2.pop();
//	for (int i = 0; i<len; i++) {
//		if (TokenSet[i] == "IF") {
//			S1.push(TokenSet[i]);
//		}
//		else if (TokenSet[i] == "THEN") {
//			if (!S1.empty() && S1.top() == "IF") {
//				S2.push(TokenSet[i]);
//				S1.pop();
//			}
//			else {
//				cout << "No Matching Token 'THEN'" << endl;
//				return false;
//			}
//		}
//		else if (TokenSet[i] == "ELSE") {
//			if (!S2.empty() && S2.top() == "THEN") {
//				S2.pop();
//			}
//			else {
//				cout << "No Matching Token 'ELSE'" << endl;
//				return false;
//			}
//		}
//		else if (TokenSet[i] == "BEGIN") {
//			S1.push(TokenSet[i]);
//		}
//		else if (TokenSet[i] == "END") {
//
//			if (!S1.empty() && S1.top() == "BEGIN") {
//				S1.pop();
//			}
//			else {
//				cout << "No Matching Token 'END'" << endl;
//				return false;
//			}
//		}
//		else {
//			cout << "invalid token!" << endl;
//			return false;
//		}
//
//	}
//
//	if (!S1.empty())
//		return false;
//
//	return true;
//}
//
//int main()
//{
//	int cnt;
//	while (cin >> src) {
//		cnt = 0;
//		stringstream ss(src);
//
//		while (getline(ss, Token, ',')) {
//			TokenSet[cnt++] = Token;
//		}
//
//		if (Syntax(cnt)) {
//			cout << "Yes!" << endl;
//		}
//		else {
//			cout << "No!" << endl;
//		}
//
//	}
//	return 0;
//}


//给定一组数，问从给定的数组中选取3个数作为三角形的不同边，一共有多少中符合条件的选法
//#include <iostream>
//#include <algorithm>
//#define N 100+5
//using namespace std;
//int A[N];
//int solve(int n) {
//	int ans = 0;
//	for (int i = 0; i < n; i++) {//最小边下标
//		for (int j = i + 2; j < n; j++) {//最大边下标 所以要从+2开始遍历
//			int low = A[j] - A[i];
//			int hig = A[j] + A[i];
//			int lb = upper_bound(A, A + n, low) - A;
//			lb = max(i + 1, lb);
//			int rb = lower_bound(A, A + n, hig) - A;
//			rb = min(j - 1, rb - 1);
//			if (rb >= lb) {
//				ans += rb - lb + 1;
//			}
//			cout << i << " " << j << " " << low << " " << hig << " " << lb << " " << rb << " " << ans << endl;
//		}
//	}
//	return ans;
//}
//
//int main()
//{
//	int n;
//	while (~scanf_s("%d", &n)) {
//		for (int i = 0; i < n; i++)
//			cin >> A[i];
//		sort(A, A + n);
//		cout << solve(n) << endl;
//	}
//
//	/*int m[5] = { 1,2,3,4,5 };
//	int pos = lower_bound(m, m + 5, 10) - m;
//	cout << pos << "hhh" << endl;*/
//	system("pause");
//	return 0;
//}


//n件物品，盗窃第i件被抓获的概率为p[i], 第i件价值为a[i]，问被抓获概率小于P的情况下可获得的最大价值。不同物品的盗窃事件概率相互独立。n范围100，a[i]范围100。
//Hdu2955 http://acm.hdu.edu.cn/showproblem.php?pid=2955
//#include <iostream>
//#include <cstring>
//#include <cstdio>
//#include <cstdlib>
//#include <algorithm>
//
//using namespace std;
//
//double f[10003], p[103], P;
//int a[103], n, sum;
//
//int main()
//{
//	int T;  scanf_s("%d", &T);
//	for (; T--;)
//	{
//		scanf_s("%lf%d", &P, &n);
//		for (int i = 1; i <= n; i++)
//			scanf_s("%d %lf", &a[i], &p[i]);
//
//		sum = 0;
//		for (int i = 1; i <= n; i++)
//			sum += a[i];
//
//		for (int i = 1; i <= sum; i++) {
//			f[i] = P * 2;
//			//cout << i << " " << f[i] << endl;
//		}
//		f[0] = 0;
//
//		for (int i = 1; i <= n; i++)
//			for (int j = sum; j >= a[i]; j--) {
//				f[j] = min(f[j], f[j - a[i]] + (1. - f[j - a[i]])* p[i]);//抢这一次之前的风险+本次被抢（之前不被抢*本次被抢）
//				//cout << i << " " << j << " " << f[j] << endl;
//			}
//
//		for (int i = sum; i >= 0; i--)
//			if (f[i] <= P)
//			{
//				printf("%d\n", i);
//				break;
//			}
//	}
//}


//Coins  Hdu2844  ？？	http://acm.hdu.edu.cn/showproblem.php?pid=2844
//多重背包问题的二进制优化解法
//对于a[i] * c[i] >= m的情况，可以将其视为无限背包
//
//否则，可以将第i种硬币的使用数量x(x <= c[i])分解成1, 2, 4...2^k, c[i] - 2 ^ (k + 1) + 1, 这几个数的唯一组合。其中k为使得c[i] - 2 ^ k>0的最大的k。
//#include <iostream>
//#include <cstring>
//#include <cstdio>
//#include <cstdlib>
//#include <algorithm>
//
//using namespace std;
//
//bool f[100003];
//int A[103], C[103], n, m, ans;
//
//
//void dp1(int x)
//{
//	for (int j = 0; j + x <= m; j++)
//		f[j + x] |= f[j];
//}
//
//void dp2(int x)
//{
//	for (int j = m; j >= x; j--)
//		f[j] |= f[j - x];
//}
//
//
//
//int main()
//{
//	for (;;)
//	{
//		scanf("%d%d", &n, &m);
//		if (!n && !m) break;
//
//		for (int i = 1; i <= n; i++)    scanf("%d", &A[i]);
//		for (int i = 1; i <= n; i++)    scanf("%d", &C[i]);
//
//		for (int i = 0; i <= m; i++)    f[i] = 0;
//
//		f[0] = 1;
//
//		for (int i = 1; i <= n; i++)
//		{
//			if (A[i] * C[i] >= m)   dp1(A[i]);              //可视作无限背包
//			else {
//				int sl = C[i], k = 1;
//				for (; k <= sl;)
//				{
//					dp2(A[i] * k);            //二进制优化转为01背包
//					sl -= k;
//					k <<= 1;
//				}
//				if (sl) dp2(A[i] * sl);
//			}
//
//		}
//
//		ans = 0;
//		for (int i = 1; i <= m; i++) ans += f[i];
//		printf("%d\n", ans);
//	}
//}


//#include <iostream>
//#include<cstdio>
//#include<cstring>
//using namespace std;
//int dp[100007], n, m, a[105], c[105], count;
//void zeropack(int cost, int value)
//{
//	for (int i = m; i >= cost; i--)
//		dp[i] = max(dp[i], dp[i - cost] + value);
//	// cout<<"01"<<endl;
//}
//void completepack(int cost, int value)
//{
//	for (int i = cost; i <= m; i++)
//		dp[i] = max(dp[i], dp[i - cost] + value);
//	//cout<<"complete"<<endl;
//}
//void multipack(int cost, int value, int num)
//{
//	if (num*cost >= m)
//	{
//		completepack(cost, value);
//		return;
//	}
//	int k = 1;
//	while (k<num)
//	{
//		zeropack(k*cost, k*value);
//		num -= k;
//		k *= 2;
//	}
//	zeropack(num*cost, num*value);
//}
//int main()
//{
//	// freopen("cin.txt","r",stdin);
//	while (~scanf("%d%d", &n, &m))
//	{
//		if (n == 0 && m == 0) break;
//		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
//		for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
//		memset(dp, 0, sizeof(dp));
//		count = 0;
//		for (int i = 1; i <= n; i++)
//		{
//			multipack(a[i], a[i], c[i]);
//		}
//
//		for (int i = 1; i <= m; i++)
//		{
//			if (dp[i] == i) count++;
//			//printf("dp[]=%d\n",dp[i]);
//		}
//		printf("%d\n", count);
//	}
//	return 0;
//}


//
//Hdu2159 http ://acm.hdu.edu.cn/showproblem.php?pid=2159
//
//K种怪物，每种怪物无限只，每杀一只增长a[i]的经验值，减去b[i]的忍耐度。初始忍耐度是m，减到小于等于0时不再杀怪。问在最多杀s只怪的情况下，能否得到经验值总量n。若能达到输出达到后还能保留的最大忍耐度。
//
//Dp
//
//无限背包
//#include <stdio.h>
//#include <iostream>
//#include <cstring>
//#include <stdlib.h>
//#include <algorithm>
//#include <queue>
//#include <math.h>
//#define INF 1e8
//
//using namespace std;
//int n, m, k, s;
//int dp[100][100];
//int a[100], aa[100];
//int main(void)
//{
//	while (scanf("%d %d %d %d", &n, &m, &k, &s) != EOF)
//	{
//		for (int i = 0; i < k; i++)
//			scanf("%d %d", &a[i], &aa[i]);
//		memset(dp, 0, sizeof(dp));
//		for (int i = 1; i <= s; i++)
//		{
//			for (int j = 0; j < k; j++)
//			{
//				for (int q = aa[j]; q <= m; q++)
//				{
//					dp[i][q] = max(dp[i][q], dp[i - 1][q - aa[j]] + a[j]);//状态转移方程
//				}
//			}
//		}
//		if (dp[s][m] < n)
//			cout << -1 << endl;
//		else
//		{
//			for (int i = 0; i <= m; i++)
//			{
//				if (dp[s][i] >= n)
//				{
//					cout << m - i << endl;
//					break;
//				}//找到最小的忍耐度，输出，结束
//			}
//		}
//	}
//	return 0;
//}




//poj练习 
//1002:方便记忆的电话号码
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<map>
//#include<set>
//using namespace std;
//map<char, int> mp;
//
//
//int main() {
//	mp['A'] = 2;
//	mp['B'] = 2;
//	mp['C'] = 2;
//	mp['D'] = 3;
//	mp['E'] = 3;
//	mp['F'] = 3;
//	mp['G'] = 4;
//	mp['H'] = 4;
//	mp['I'] = 4;
//	mp['J'] = 5;
//	mp['K'] = 5;
//	mp['L'] = 5;
//	mp['M'] = 6;
//	mp['N'] = 6;
//	mp['O'] = 6;
//	mp['P'] = 7;
//	mp['R'] = 7;
//	mp['S'] = 7;
//	mp['T'] = 8;
//	mp['U'] = 8;
//	mp['V'] = 8;
//	mp['W'] = 9;
//	mp['X'] = 9;
//	mp['Y'] = 9;
//	int n;
//	cin >> n;
//	string str;
//	multiset<string > ms;
//	set<string> s;
//	for (int cnt = 0; cnt < n; cnt++) {
//		cin >> str;
//		string tp = "";
//		for (int i = 0; i < str.length(); i++) {
//			if (isdigit(str[i])) {
//				tp += str[i];
//			}
//			if (isalpha(str[i])) {
//				if (str[i] != 'Q'&&str[i] != 'Z') {
//					tp += mp[str[i]] + '0';
//				}
//			}
//		}
//		ms.insert(tp);
//		s.insert(tp);
//	}
//	int suc = 0;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		int tot = ms.count(*itr);
//		string ans = *itr;
//		if (tot > 1) {
//			suc = 1;
//			cout << ans[0] << ans[1] << ans[2] << "-" << ans[3] << ans[4] << ans[5] << ans[6] << " " << tot << endl;
//		}
//	}
//	if (!suc) {
//		cout << "No duplicates." << endl;
//	}
//	system("pause");
//	return 0;
//}


//1003:Hangover
//#include<iostream>
//using namespace std;
//double m[300];
//int main() {
//	double ans = 0.0;
//	for (int i = 2; i < 300; i++) {
//		ans += 1.0 / i;
//		m[i - 1] = ans;
//		//cout << i << " " << ans << endl;
//	}
//	double tar;
//	while (cin >> tar) {
//		if (tar == 0.0) {
//			break;
//		}
//		for (int i = 1;; i++) {
//			if (m[i] > tar) {
//				cout << i << " card(s)" << endl;
//				break;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//poj 字符串处理
//1488:TEX Quotes
//#include<iostream>
//#include<string>
//using namespace std;
//int main() {
//	string line;
//	int cnt = 0;
//	while (getline(cin, line)) {
//		for (int i = 0; i < line.length(); i++) {
//			if (line[i] == '"') {
//				if (cnt % 2 == 0) {
//					cout << "`" << "`";
//				}
//				else {
//					cout << "''";
//				}
//				cnt++;
//			}
//			else {
//				cout << line[i];
//			}
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//1598:Excuses, Excuses!
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<sstream>
//#include<vector>
//#include<algorithm>
//#include<set>
//#include<climits>
//using namespace std;
//int cnt[25];
//int main() {
//	int k, e;
//	int tot = 1;
//	while (cin >> k >> e) {
//		memset(cnt, 0, sizeof(cnt));
//		string nonsense, line;
//		set<string> keys;
//		vector<string> sentences;
//		string ky;
//		for (int i = 0; i < k; i++) {
//			cin >> ky;
//			keys.insert(ky);
//		}
//		getline(cin, nonsense);
//		for (int i = 0; i < e; i++) {
//			getline(cin, line);
//			sentences.push_back(line);
//			stringstream ss(line);
//			string tp;
//			while (ss >> tp) {
//				transform(tp.begin(), tp.end(), tp.begin(), ::tolower);
//				string proc = "";
//				int flag = 1;
//				for (int j = 0; j < tp.length(); j++) {
//					//注释掉的这段代码不行 因为只能扫描出一个str中的第一个单词
//					////cout << tp.length() << " " << j << endl;
//					//if (!isalpha(tp[j]) && flag)
//					//{
//					//	//cout << "hhh" << endl;
//					//	flag = 0;
//					//	continue;
//					//}
//
//					//if (!isalpha(tp[j])) {
//					//	cout << proc << endl;
//					//	if (keys.find(proc) != keys.end()) {
//					//		cnt[i] += 1;
//					//	}
//					//	proc = "";
//					//	flag = 1;
//					//}
//					//proc += tp[j];
//
//					if (isalpha(tp[j])) {
//						while (isalpha(tp[j])) {
//							proc += tp[j];
//							j++;
//						}
//					}
//					if (keys.find(proc) != keys.end()) {
//						cnt[i] += 1;
//					}
//					proc = "";
//				}
//
//			}
//		}
//		int mx = INT_MIN;
//		cout << "Excuse Set #" << tot << endl;
//		tot++;
//		for (int i = 0; i < e; i++) {
//			//cout << i << " " << cnt[i] << endl;
//			if (cnt[i] > mx) {
//				mx = cnt[i];
//			}
//		}
//
//		for (int i = 0; i < e; i++) {
//			if (cnt[i] == mx) {
//				cout << sentences[i] << endl;
//			}
//		}
//
//
//		cout << endl;
//	}
//
//	system("pause");
//	return 0;
//}

//poj 中文题目
//1007:DNA排序 
//#include<iostream>
//#include<algorithm>
//#include<string>
//using namespace std;
//
//struct DNA
//{
//	string str;
//	int cnt;
//};
//DNA dna[110];
//bool cmp(const DNA &a, const DNA &b) {
//	if (a.cnt < b.cnt) {
//		return true;
//	}
//	else {
//		return false;
//	}
//}
//int main() {
//	int n, m;
//	cin >> n >> m;
//	for (int i = 0; i < m; i++) {
//		cin >> dna[i].str;
//		int a = 0, c = 0, g = 0;
//		int tot = 0;
//		for (int j = n-1; j >=0; j--) {//这里一定要是逆序
//			switch (dna[i].str[j])
//			{
//			case 'A':a++; break;
//			case 'C':c++; tot += a; break;
//			case 'G':g++; tot += a + c; break;
//			case 'T':tot += a + c + g; break;
//			default:break;
//			}
//			//cout << "hhh " << j << " " << tot << endl;
//		}
//		//cout << i << " " << tot << endl;
//		dna[i].cnt = tot;
//	}
//	sort(dna, dna + m, cmp);
//	//cout << endl;
//	for (int i = 0; i < m; i++) {
//		cout << dna[i].str << endl;
//	}
//	system("pause");
//	return 0;
//}

//1017:装箱问题
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int main() {
//	int c1, c2, c3, c4, c5, c6;
//	
//	
//	while (cin >> c1 >> c2 >> c3 >> c4 >> c5 >> c6) {
//		if (!c1 && !c2 && !c3 && !c4 && !c5 && !c6) {
//			break;
//		}
//		int tot = 0;
//		int n2 = 0, n1 = 0;
//		//考虑装4,5,6
//		tot += c4 + c5 + c6;
//		//考虑装3
//		tot += ceil(double(c3) / 4.0);
//		//装2
//		n2 += c4 * 5;
//		if (c3 % 4 == 3) {
//			n2 += 1;
//		}
//		else if (c3 % 4 == 2) {
//			n2 += 3;
//		}
//		else if (c3 % 4 == 1) {
//			n2 += 5;
//		}
//
//		if (n2 < c2) {
//			tot += ceil(double(c2 - n2) / 9.0);
//		}
//		//装1
//		n1 = 36 * tot - 36 * c6 - 25 * c5 - 16 * c4 - 9 * c3 - 4 * c2;
//
//		if (n1 < c1) {
//			tot += ceil(double(c1 - n1) / 36.0);
//		}
//		cout << tot << endl;
//	}
//	system("pause");
//	return 0;
//}

//1035:Spell checker  拼写检查
//#include<iostream>
//#include<string>
//#include<vector>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//const int maxn = 10010;
//vector<string> dic;
//
//int main() {
//	string temp;
//	int cnt = 0;
//	while (cin >> temp) {
//		if (temp == "#") {
//			break;
//		}
//		dic.push_back(temp);
//	}
//	cnt = dic.size();
//	while (cin >> temp) {
//		if (temp == "#") {
//			break;
//		}
//		//先比较长度
//
//		int suc = 0;
//		for (int i = 0; i < cnt; i++) {
//			if (temp == dic[i]) {
//				cout << temp << " is correct" << endl;
//				suc = 1;
//			}
//		}
//		if (!suc) {
//			cout << temp << ": ";
//			for (int i = 0; i < cnt; i++) {
//				int lent = temp.length();
//				int lend = dic[i].length();
//				if (lent == lend) {
//					int dif = 0;
//					for (int j = 0; j < lent; j++) {
//						if (temp[j] != dic[i][j]) {
//							dif++;
//							if (dif > 1) {
//								break;
//							}
//						}
//					}
//					if (dif == 1) {
//						cout << dic[i] << " ";
//					}
//				}
//				else {
//					if (abs(lent - lend) == 1) {
//						if (lent > lend) {
//							int flag = 0;
//							//j是temp的index  k是dic[i]的index
//							for (int j = 0, k = 0; j < lent; j++, k++) {
//								if (temp[j] != dic[i][k]) {
//									//这里本意是要j++ k不变 但是循环本身就要j++ k++ 所以这里要k--  然后k++ 相当于不变
//									k--;
//									flag++;
//								}
//								if (flag > 1) {
//									break;
//								}
//							}
//							if (flag == 1) {
//								cout << dic[i] << " ";
//							}
//						}
//						else if (lent < lend) {
//							int flag = 0;
//							for (int j = 0, k = 0; k < lend; j++, k++) {
//								if (temp[j] != dic[i][k]) {
//									j--;
//									flag++;
//								}
//								if (flag > 1) {
//									break;
//								}
//							}
//							if (flag == 1) {
//								cout << dic[i] << " ";
//							}
//						}
//					}
//				}
//			}
//			cout << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//1061:青蛙的约会  暴力求解 超时
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int main() {
//	int x, y, m, n, len;
//	cin >> x >> y >> m >> n >> len;
//	int cnt = 0;
//	if (m == n) {
//		cout<<"Impossible" << endl;
//		system("pause");
//		return 0;
//	}
//	while (x != y) {
//		x = (x + m) % len;
//		y = (y + n) % len;
//		cnt++;
//	}
//	cout << cnt << endl;
//	system("pause");
//	return 0;
//}

//1088:滑雪
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn][maxn];
//int dp[maxn][maxn];
//int r, c;
//int f(int i, int j) {
//	if (dp[i][j] != 0) {
//
//		return dp[i][j];
//	}
//	dp[i][j] = 1;
//	if (i > 1 && m[i - 1][j] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i - 1, j) + 1);
//	}
//	if (j > 1 && m[i][j - 1] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i, j - 1) + 1);
//	}
//	if (i < r && m[i + 1][j] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i + 1, j) + 1);
//	}
//	if (j < c && m[i][j + 1] < m[i][j]) {
//		dp[i][j] = max(dp[i][j], f(i, j + 1) + 1);
//	}
//	return dp[i][j];
//}
//int main() {
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int ans = INT_MIN;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			ans = max(ans, f(i, j));
//		}
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}

//1184:聪明的打字员
//#include<iostream>
//#include<queue>
//#include<string>
//#include<cstring>
//#include<algorithm>
//#include<map>
//#include<sstream>
//using namespace std;
//int ans = 0;
//string orin, tar;
//const int maxn = 1000010;
//int vis[maxn][10];//vis一定要开2维  字符串和字符串的位置
//struct Node
//{
//	string str;
//	int step;
//	int index;
//	int num;
//	/*bool operator<(const Node& a)const {
//		return step > a.step;
//	}*/
//};
//int str2num(string s) {
//	//用sstream要慢一点 但是也可以ac
//	stringstream ss;
//	ss << s;
//	int num;
//	ss >> num;
//	/*int num = 0;
//	for (int i = 0; i < 6; i++) {
//		num = num * 10 + s[i] - '0';
//	}*/
//	//cout << num << endl;
//	return num;
//
//}
//int bfs() {
//	//int tar_num = str2num(tar);
//	memset(vis, 0, sizeof(vis));
//	Node first;
//	first.str = orin;
//	first.step = 0;
//	first.index = 0;//范围是0-5
//	first.num = str2num(first.str);
//	//priority_queue<Node> q;
//	queue<Node> q;
//	q.push(first);
//	while (!q.empty()) {
//		Node now = q.front();
//		q.pop();
//		//cout <<"hhh "<< now.str << " " << now.index << " " << now.step << endl;
//
//		if (now.str == tar) {
//
//			return now.step;
//		}
//		if (vis[now.num][now.index]) {
//			continue;
//		}
//		vis[now.num][now.index] = 1;
//		for (int i = 1; i <= 5; i++) {
//			Node next = now;
//			//剪枝
//			if ((i == 5 || i == 6) && now.index >= 1 && now.index <= 4 && now.str[now.index] != tar[now.index]) {
//				continue;
//			}
//			if (i == 1) {
//				swap(next.str[next.index], next.str[0]);
//			}
//			if (i == 2) {
//				swap(next.str[next.index], next.str[5]);
//			}
//			if (i == 3) {
//				if (next.str[next.index] != '9') {
//					next.str[next.index] += 1;
//				}
//			}
//			if (i == 4) {
//				if (next.str[next.index] != '0') {//取值范围是0-9！！
//					next.str[next.index] -= 1;
//				}
//			}
//			if (i == 5) {
//				if (next.index != 5) {
//					next.index += 1;
//				}
//			}
//			/*if (i == 6) {
//				if (next.index != 0) {
//					next.index -= 1;
//				}
//			}*/
//			next.step += 1;
//			next.num = str2num(next.str);
//			q.push(next);
//			//cout << i << " " << next.str << " " << next.index << " " << next.step << endl;
//		}
//	}
//	return  -1;
//}
//int main() {
//	cin >> orin >> tar;
//
//	ans = bfs();
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//1189:钉子和小球 网上答案
//#include<cstdio>
//#include<cstring>
//#include<algorithm>
//#include<iostream>
//using namespace std;
//typedef long long ll;
//const int N = 53;
//int in() {
//	int k = 0, fh = 1; char c = getchar();
//	for (; c < '0' || c > '9'; c = getchar())
//		if (c == '-') fh = -1;
//	for (; c >= '0' && c <= '9'; c = getchar())
//		k = k * 10 + c - 48;
//	return k * fh;
//}
//
//char c[N][N];
//ll f[N][N];
//int n, m;
//
//int main() {
//	n = in(); m = in();
//	//cout << n << " " << m << endl;
//	char ch;
//	for (int i = 1; i <= n; ++i)
//		for (int j = 1; j <= i; ++j) {
//			for (ch = getchar(); ch != '*' && ch != '.'; ch = getchar());
//			c[i][j] = ch;
//		}
//	f[1][1] = 1ll << n;//右移相当于乘2
//	//cout << f[1][1] << endl;
//	for (int i = 2; i <= n + 1; ++i)
//		for (int j = 1; j <= i; ++j) {
//			if (j - 1 > 0 && c[i - 1][j - 1] == '*')//不在最左边 且左上方有钉子
//				f[i][j] += f[i - 1][j - 1] >> 1;
//			if (j < i && c[i - 1][j] == '*')//不在最右边  且右上方有钉子
//				f[i][j] += f[i - 1][j] >> 1;
//			//往上数2层恰巧头上就是空的 所以必须从第3层开始 并且不能再最左边和最右边
//			if (i > 2 && 1 <= j - 1 && j - 1 <= i - 2 && c[i - 2][j - 1] == '.')
//				f[i][j] += f[i - 2][j - 1];
//		}
//	ll fz = f[n + 1][m + 1], fm = 1ll << n;
//	//约分
//	while (fz % 2 == 0 && fm % 2 == 0)
//		fz >>= 1, fm >>= 1;
//	if (fz == 0) fm = 1;
//	printf("%I64d/%I64d\n", fz, fm);
//	system("pause");
//	return 0;
//}

//1190:生日蛋糕 不好理解
//#include<stdio.h>
//#include<string.h>
//#include<iostream>
//#include<math.h>
//#include<algorithm>
//#include<map>
//#include<queue>
//#include<set>
//using namespace std;
//
//int minA[30], minV[30], minArea, Area;
//int N, M;
//
//int maxvFormrh(int m, int r, int h)
//{
//	int maxv = 0;
//	for (int i = 0; i < m; i++)
//		maxv += (r - i) * (r - i) *(h - i);
//	return maxv;
//}
//
//void dfs(int n, int m, int r, int h)
//{
//	if (m == 0)
//	{
//		if (n)
//			return;
//		else if (minArea > Area)
//		{
//			minArea = Area;
//			return;
//		}
//	}
//	//如果在搜索的过程中体积小于0 
//	if (n <= 0) // 剪枝1
//		return;
//	//当前半径或高度小于剩余要制作的层数（因为每层必须是相差1的，当前半径或高度小于要制作的层数，肯定不能制作完）就要剪枝.
//	if (h < m || r < m)//剪枝1
//		return;
//	//当前剩下m层需要制作，可以预测制作这m层蛋糕最少需要多少体积，如果这个最少的体积还大于当前剩余的体积，那个这个不必继续搜索，所以要剪枝。
//	if (minV[m] > n)//剪枝2
//		return;
//	//因为要求求最小表面积，如果当前枚举到的面积已经大于要求得的最优表面积，就要剪枝，但是这个剪枝还可以更优化，根据剪枝二的启发，如果当前枚举到的面积加上制作剩余m层蛋糕所要花费的最小表面积大于已经求得的最优解，那么剪枝。
//	if (minA[m] + Area >= minArea) // 剪枝3
//		return;
//	if (maxvFormrh(m, r, h) < n)//剪枝4
//		return;
//
//	for (int i = r; i >= m; i--)
//	{
//		if (m == M)//最下面一层
//			Area = i * i;
//		for (int j = h; j >= m; j--)
//		{
//			Area += 2 * i * j;
//			dfs(n - i * i*j, m - 1, i - 1, j - 1);
//			Area -= 2 * i * j;
//		}
//	}
//}
//
//int main()
//{
//	while (scanf_s("%d%d", &N, &M) != EOF)
//	{
//		minA[0] = 0;
//		minV[0] = 0;
//		for (int i = 1; i <= M; i++)//求出最小体积个最小表面积
//		{
//			minA[i] = minA[i - 1] + 2 * i * i;
//			minV[i] = minV[i - 1] + i * i * i;
//		}
//		cout << minA[M] << " " << minV[M] << endl;
//		if (minV[M] > N)
//		{
//			printf("0\n");
//		}
//		else
//		{
//			int maxH = (N - minV[M - 1]) / (M * M) + 1;//最大的高度
//			int maxR = sqrt((N - minV[M - 1]) / M) + 1;//最大的半径
//													   //Ps:上面的加1是因为避免出现小数取整，反正最后会减掉不必纠结。
//			cout << maxH << " " << maxR << endl;
//			minArea = 1 << 30;
//			Area = 0;
//			dfs(N, M, maxR, maxH);
//			printf("%d\n", minArea);
//		}
//	}
//	system("pause");
//	return 0;
//}


//1190:生日蛋糕  网上答案 要好理解一点
//#include<stdio.h>
//#include<string.h>
//#include<algorithm>
//#include<iostream>
//using namespace std;
//int minv[30], minb[30];  //由题目可知,每一层的半径与高度是逐渐递减的,且最小是少1
//int n, m, ans;             //所以提前把每一层的体积与表面积算出来
//void dfs(int sum, int v, int dep, int h, int r)  //sum 表面涂的面积 v是蛋糕体积 dep是第几层 h是高度 r是半径
//{
//	cout << sum << " " << v << " " << dep << " " << h << " " << r << endl;
//	if (v > n)return;  //如果堆蛋糕的体积已经大于所给体积了,那么就无法再向上搭建了
//	if (dep == 0)    //如果搭建完成了且此时蛋糕刚好用完,判断此时的表面积是否是最优的
//	{
//		cout << "xxx " << endl;
//		//  printf("%d %d\n",v,sum);
//		if (v == n && sum < ans)
//		{
//			ans = sum;
//		}
//		return;
//	}
//	//   如果现在的体积加上下一层所用的最小体积依然大于规定的体积,那就返回上一层
//	//    如果现在所求的表面积加上下一层的依然大于之前所求的的结果,则返回
//	//    如果剩余体积的测面积加上之前的大于之前求得的最优结果,返回上一层.
//	if (v + minv[dep - 1] > n || sum + minb[dep - 1] > ans || (n - v) / r * 2 + sum >= ans) {
//		cout << "hhh " << sum << " " << v << " " << dep << " " << h << " " << r << endl;
//		return;
//	}
//	for (int i = r - 1; i >= dep; i--)   //从大到小枚举半径,所求的结果一定是最优的
//	{
//		if (dep == m)sum = i * i;  //到了最后一层的时候要算上顶部
//		int th = min(h - 1, (n - v - minv[dep - 1]) / (i*i));  //找到这一层的最大高度
//		for (int j = th; j >= dep; j--)
//		{
//			dfs(sum + 2 * i*j, v + i * i*j, dep - 1, j, i);
//		}
//	}
//	return;
//}
//int main()
//{
//	for (int i = 1; i < 21; i++)//最上面最小的是第一层
//	{
//		minv[i] = minv[i - 1] + i * i * i;//最小体积
//		minb[i] = minb[i - 1] + i * i * 2;//最小侧面积
//	}
//	while (~scanf_s("%d%d", &n, &m))
//	{
//		ans = 0x3f3f3f3f;
//		dfs(0, 0, m, n + 1, n + 1);
//		if (ans == 0x3f3f3f3f)
//			ans = 0;
//		printf("%d\n", ans);
//	}
//	return 0;
//}


//1610:四分树
//#include <cstdio>
//#include <cstdlib>
//#include <queue>
//#include <string>
//#include <cstring>
//#define maxn 515
//using namespace std;
//int mymap[maxn][maxn] = { 0 };/*记录点的颜色*/
//
//bool ans[2 * maxn*maxn] = { 0 };/*01序列*/
//int ans_len = 0;
//
//class area/*区域类*/
//{
//public:
//	int a1, b1, a2, b2;
//	area(int a, int b, int c, int d)
//	{
//		a1 = a;
//		b1 = b;
//		a2 = c;
//		b2 = d;
//	}
//};
//
//queue <area> aq;/*用于bfs*/
//
//void bfs(area ar)
//{
//	int x1 = ar.a1;
//	int y1 = ar.b1;
//	int x2 = ar.a2;
//	int y2 = ar.b2;
//
//	bool is_one = 0;/*是否有1*/
//	bool is_zero = 0;/*是否有0*/
//	bool is_div = 0;/*是否可分*/
//
//	for (int i = x1; i <= x2; ++i)
//	{
//		if (is_one && is_zero)
//			break;
//		for (int j = y1; j <= y2; ++j)
//		{
//			if (is_one && is_zero)
//				break;
//			if (mymap[i][j]) is_one = 1;
//			else is_zero = 1;
//		}
//	}
//	if (is_one && is_zero)/*不全0不全1则可分*/
//		is_div = 1;
//	if (is_div)
//	{
//		int hx = (x1 + x2) >> 1;/*区间的中间坐标*/
//		int hy = (y1 + y2) >> 1;
//
//		ans[ans_len++] = 1;
//
//		aq.push(area(x1, y1, hx, hy));
//		aq.push(area(x1, hy + 1, hx, y2));
//		aq.push(area(hx + 1, y1, x2, hy));
//		aq.push(area(hx + 1, hy + 1, x2, y2));
//		return;
//	}
//	ans[ans_len++] = 0;
//	ans[ans_len++] = is_one;
//	return;
//}
//
//
//void trans()/*01序列转16进制输出*/
//{
//	int los = ans_len % 4;
//	int tmp = 0;
//	if (los)
//	{
//		for (int i = 0; i < los; ++i)
//		{
//			tmp += ans[i] << (los - i - 1);
//		}
//		printf("%X", tmp);
//	}
//	for (int i = los; i < ans_len; i += 4)
//	{
//		tmp = 0;
//		for (int j = 0; j < 4; ++j)
//		{
//			tmp += ans[i + j] << (3 - j);
//		}
//		printf("%X", tmp);/*一定要大写啊!!!*/
//	}
//	printf("\n");
//	return;
//}
//
//void init()
//{
//	memset(mymap, 0, sizeof(mymap));
//	memset(ans, 0, sizeof(ans));
//	ans_len = 0;
//	return;
//}
//
//int main()
//{
//	int t = 0, n = 0;
//	scanf("%d", &t);
//	while (t--)
//	{
//		init();
//		scanf("%d", &n);
//		for (int i = 0; i < n; ++i)
//			for (int j = 0; j < n; ++j)
//				scanf("%d", &mymap[i][j]);
//		aq.push(area(0, 0, n - 1, n - 1));//左上角和右下角的点
//
//		while (!aq.empty())
//		{
//			area ar_tmp = aq.front();
//			aq.pop();
//			bfs(ar_tmp);
//		}
//
//		trans();
//
//	}
//	return 0;
//}

//1661:帮助 Jimmy
//#include <iostream>
//#include <algorithm>
//#include <vector>
//#include <cstring>
//using namespace std;
//const int inf = 0x3f3f3f3f;
//struct Point {
//	int l;
//	int r;
//	int h;
//	Point(int _l, int _r, int _h) :l(_l), r(_r), h(_h) {};
//	bool operator < (const Point &p) const {
//		return h<p.h;
//	}
//};
//vector <Point> p_v;
//int dp[1010][2];
//
//int find_black(int index, int p) {
//	//从这个板子的下面的那个板子开始找,下面的if不加等号就错了哦～
//	for (int i = index - 1; i >= 0; i--) {
//		if (p_v[i].l <= p && p_v[i].r >= p) {
//			return i;
//		}
//	}
//	return inf;
//}
//int drop(int n, int maxs) {
//	dp[0][1] = dp[0][0] = p_v[0].h;//0代表左边的点，1代表右边的点
//	int m;
//	for (int i = 1; i <= n; ++i) {
//		//更新这个板子左边的点
//		if ((m = find_black(i, p_v[i].l)) != inf) {
//			//下面有板子
//			if ((p_v[i].h - p_v[m].h) <= maxs)
//				dp[i][0] = p_v[i].h - p_v[m].h + min(dp[m][0] + p_v[i].l - p_v[m].l, dp[m][1] + p_v[m].r - p_v[i].l);
//			else
//				dp[i][0] = inf;
//		}
//		else {
//			if (p_v[i].h>maxs) dp[i][0] = inf;
//			else {
//				dp[i][0] = p_v[i].h;
//			}
//		}
//		//更新板子右边的点
//		if ((m = find_black(i, p_v[i].r)) != inf) {
//			//下面有板子
//			if ((p_v[i].h - p_v[m].h) <= maxs) {
//				dp[i][1] = p_v[i].h - p_v[m].h + min(dp[m][0] + p_v[i].r - p_v[m].l, dp[m][1] + p_v[m].r - p_v[i].r);
//			}
//			else
//				dp[i][1] = inf;
//		}
//		else {
//			if (p_v[i].h>maxs) dp[i][1] = inf;
//			else dp[i][1] = p_v[i].h;
//		}
//	}
//	return min(dp[n][0], dp[n][1]);
//}
//int main()
//{
//	int t;
//	cin >> t;
//	while (t--) {
//		int n, x, y, maxs;
//		cin >> n >> x >> y >> maxs;
//		memset(dp, 0, sizeof(dp));//初始化为0
//		p_v.clear();//将vector清零
//					//填充p_v并且按照这些point里面的h从小到大排序
//		p_v.push_back(Point(x, x, y));
//		for (int i = 0; i < n; ++i) {
//			int x1, x2, h;
//			cin >> x1 >> x2 >> h;
//			p_v.push_back(Point(x1, x2, h));
//		}
//		sort(p_v.begin(), p_v.end());
//		cout << drop(n, maxs) << endl;
//	}
//	return 0;
//}

//1686:等价表达式
//#include <cstdio>
//#include <iostream>
//#include <string>
//#include <cstring>
//#include <stack>
//using namespace std;
//#define MAX 100
//string change(char *p) {
//	string cnt;
//	int len = strlen(p);
//	stack<char>astack;
//	for (int i = 0; i <= len; i++) {
//		if ((p[i] >= '0' && p[i] <= '9') || (p[i] >= 'a' && p[i] <= 'z'))
//			cnt += p[i];
//		else if (p[i] == '(')
//			astack.push('(');
//		else if (p[i] == ')') {
//			while (astack.top() != '(') {
//				cnt += astack.top();
//				astack.pop();
//			}
//			astack.pop();
//		}
//		else if (p[i] == '+' || p[i] == '-') {
//			while (!astack.empty() && astack.top() != '(') {
//				cnt += astack.top();
//				astack.pop();
//			}
//			astack.push(p[i]);
//		}
//		else if (p[i] == '*') {
//			while (!astack.empty() && astack.top() != '(' && astack.top() == '*') {
//				cnt += astack.top();
//				astack.pop();
//			}
//			astack.push(p[i]);
//		}
//		else if (p[i] == ' ' || p[i] == '	')
//			continue;
//	}
//	while (!astack.empty()) {
//		cnt += astack.top();
//		astack.pop();
//	}
//	return cnt;
//}
//int getsum(string num) {
//	int len = num.length();
//	stack<int>astack;
//	for (int i = 0; i < len; i++) {
//		if (num[i] <= 'z' && num[i] >= 'a') {
//			int ascii = num[i];
//			astack.push(ascii);
//		}
//		else if (num[i] >= '0' && num[i] <= '9')
//			astack.push((int)num[i] - '0');
//		else if (num[i] == '+') {
//			int n = astack.top();
//			astack.pop();
//			int m = astack.top();
//			astack.pop();
//			m += n;
//			astack.push(m);
//		}
//		else if (num[i] == '*') {
//			int n = astack.top();
//			astack.pop();
//			int m = astack.top();
//			astack.pop();
//			n *= m;
//			astack.push(n);
//		}
//		else if (num[i] == '-') {
//			int n = astack.top();
//			astack.pop();
//			int m = astack.top();
//			astack.pop();
//			m -= n;
//			astack.push(m);
//		}
//	}
//	int result = astack.top();
//	astack.pop();
//	return result;
//}
//int main() {
//	int N;
//	cin >> N;
//	cin.get();
//	while (N--) {
//		char s1[MAX], s2[MAX];
//		cin.getline(s1, MAX);
//		string p1 = change(s1);
//		cout << p1 << endl;
//		int a = getsum(p1);
//		cin.getline(s2, MAX);
//		string p2 = change(s2);
//		int b = getsum(p2);
//		if (a == b)
//			cout << "YES" << endl;
//		else
//			cout << "NO" << endl;
//	}
//	return 0;
//}

//1961:前缀中的周期
//#include<iostream>
//#include<string>
//using namespace std;
//#define MAXN 10010000
//int* cmput(int *const next, const string &s) {//next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。
//	int ls = s.length();
//	int k = -1;
//	int j = 0;
//	next[0] = -1;
//	while (j<ls)
//	{
//		if (k == -1 || s[j] == s[k]) {
//			k++;
//			j++;
//			next[j] = k;
//		}
//		else {
//			k = next[k];
//		}
//	}
//	return next;
//}
//
//int main() {
//	int n;
//	string s;
//	int *next = new int[MAXN];
//	int len;
//	int count = 1;
//	while (cin >> n) {
//		if (!n)
//			return 0;
//		cout << "Test case #" << count++ << endl;
//		cin >> s;
//		len = s.length();
//		cmput(next, s);
//		for (int i = 0; i <= len; i++) {
//			cout << "hhh " << i << " " << next[i] << endl;
//		}
//		for (int i = 2; i <= len; i++) {
//			if (next[i] == 0)
//				continue;
//			if (next[i] % (i - next[i]) == 0) {
//				cout << i << ' ' << i / (i - next[i]) << endl;
//			}
//		}
//		cout << endl;
//	}
//	return 0;
//}

//2681:求字符串长度
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int main() {
//	string line;
//	getline(cin, line);
//	cout << line.length();
//	system("pause");
//	return 0;
//}


//2689:大小写字母互换
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//int main() {
//	string line;
//	getline(cin, line);
//	for (int i = 0; i < line.length(); i++) {
//		if (isupper(line[i])) {
//			line[i] = tolower(line[i]);
//		}
//		else if (islower(line[i])) {
//			line[i] = toupper(line[i]);
//		}
//
//	}
//	for (int i = 0; i < line.length(); i++) {
//		cout << line[i];
//	}
//	system("pause");
//	return 0;
//}

//2690:首字母大写
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<sstream>
//using namespace std;
//int main() {
//	string line;
//	getline(cin, line);
//	for (int i = 0; i < line.length(); i++) {
//		if (i == 0) {
//			line[i] = toupper(line[i]);
//		}
//		else if (line[i-1] == ' '|| line[i - 1] == '\t'|| line[i - 1] == '\r'|| line[i - 1] == '\n') {
//			line[i] = toupper(line[i]);
//		}
//
//	}
//	for (int i = 0; i < line.length(); i++) {
//		cout << line[i];
//	}
//	system("pause");
//	return 0;
//}


//2692:假币问题
//#include<stdio.h>
//
//int status[12];
//char left[3][7], right[3][7], result[3][7];
//
////判断当前的情况是否满足条件
//bool Balanced()
//{
//	int i, k, leftw, rightw;
//	for (i = 0; i < 3; i++)//判断3个等式是否相等
//	{
//		leftw = rightw = 0;
//		for (k = 0; k <6 && left[i][k] != 0; k++)
//		{
//			leftw += status[left[i][k] - 'A'];
//			rightw += status[right[i][k] - 'A'];
//		}
//		if (leftw > rightw && result[i][0] != 'u') //条件1 
//			return false;
//		if (leftw < rightw && result[i][0] != 'd') //条件2 
//			return false;
//		if (leftw == rightw && result[i][0] != 'e') //条件3 
//			return false;
//	}
//	return true;
//}
//
//int main()
//{
//	int i, num;
//	scanf("%d", &num);
//	while (num--)
//	{
//		for (i = 0; i < 3; i++)
//			scanf("%s%s%s", left[i], right[i], result[i]);
//		for (i = 0; i < 12; i++)
//			status[i] = 0;
//		for (i = 0; i < 12; i++)//遍历12枚硬币
//		{
//			status[i] = 1;    //第i枚硬币是较重假币 
//			if (Balanced())
//				break;
//			status[i] = -1;   //第i枚硬币是较轻假币 
//			if (Balanced())
//				break;
//			status[i] = 0;	  //第i枚硬币是真币 
//		}
//		printf("%c is the counterfeit coin and it is %s.\n", i + 'A', status[i] > 0 ? "heavy" : "light");
//	}
//	return 0;
//}


//2705:跳绳游戏  网上答案
//#include<stdio.h>
//#include<iostream>
//using namespace std;
//int m[70];
//int main()
//{
//	int  cnt, bad_cnt, i, j, k, t;
//	while (scanf_s("%d", &cnt) != EOF)
//	{
//		for (i = 0; i < cnt; i++)
//		{
//			scanf_s("%d", &bad_cnt);
//			bad_cnt = bad_cnt + 1;
//			for (j = 1; j < bad_cnt; j++)
//				scanf_s("%d", &m[j]);
//			for (j = 1, k = 0; j <= bad_cnt; j++)
//			{
//				k = j * 3 + m[j];
//				cout << "hhh " << j << " " << k << endl;
//				if (k > 60)          //判断跳的时间是否超过60秒
//					break;
//			}
//			cout << "hhh " << k << endl;
//			//printf("%d ",j);
//			if (j > bad_cnt - 1)
//				printf("%d\n", 60 - 3 * (bad_cnt - 1));      //没有超过60秒的
//			else
//			{
//				t = 60 - 3 * (j - 1);
//				if (t < m[j])                     //判断跳坏之后的时间是否还够下一次在跳的时间（3秒）。
//					printf("%d\n", t);
//				else
//					printf("%d\n", m[j]);
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//2705:跳绳游戏 网上答案
//#include <stdio.h>
//#include<iostream>
//using namespace std;
//int main()
//{
//	int n;
//	cin >> n;
//	while (n--)
//	{
//		int sum = 0, i, m;
//		cin >> m;
//		int flag = 0;
//		for (i = 1; i <= m; i++)
//		{
//			cin >> sum;
//			if (sum + 3 * i >= 60)
//			{
//				flag = 1; break;
//			}      //判断时间时是否结束 ; 
//
//		}
//		printf("hhh %d %d\n", i, sum);          // i的值容易搞错 ； 
//		int j, nonsense;
//		for (j = i + 1; j <= m; j++)          // 输入已经超过一分钟， 无效的跳绳数 ； 
//			cin >> nonsense;
//		if (sum <= 60 && sum + (i - 1) * 3 <= 60 && flag)
//			printf("%d\n", sum);          // 在57 ~60（s），直接输出结果 ； 
//		else
//			printf("%d\n", 60 - 3 * (i - 1));// 否则减去失败次数 ； 
//	}
//	system("pause");
//	return 0;
//}

//2705:跳绳游戏  自己的方法 模拟时间流逝  wa
//#include<iostream>
//using namespace std;
//const int maxn = 70;
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int cnt = 0; cnt < n; cnt++) {
//		int tot;
//		cin >> tot;
//		if (tot == 0) {
//			cout << 60 << endl;
//		}
//		else {
//			for (int i = 1; i <= tot; i++) {
//				cin >> m[i];
//			}
//			m[0] = 0;
//			int t = 0;
//			int ans = 0;
//
//
//			for (int i = 1; i <= tot; i++) {
//				if (t + m[i] - m[i - 1] <= 60) {
//					t += m[i] - m[i - 1] + 3;
//					ans += m[i] - m[i - 1];
//				}
//				//cout << i << " " << t << " " << ans << endl;
//			}
//			if (t <= 60) {
//				ans += 60 - t;
//			}
//			cout << ans << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//2721:忽略大小写比较字符串大小
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//int main() {
//	string str1, str2;
//	getline(cin, str1);
//	getline(cin, str2);
//	transform(str1.begin(), str1.end(), str1.begin(), ::tolower);
//	transform(str2.begin(), str2.end(), str2.begin(), ::tolower);
//	if (str1 > str2) {
//		cout << ">" << endl;
//	}
//	else if (str1 < str2) {
//		cout << "<" << endl;
//	}
//	else {
//		cout << "=" << endl;
//	}
//	system("pause");
//	return 0;
//}


//2723:不吉利日期
//#include<iostream>
//using namespace std;
//const int mom[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
//int main() {
//	int n;
//	cin >> n;
//	int d1 = 1;
//	int m1 = 1;
//	int d2 = 13;
//	int m2 = 12;
//	int sum = 0;
//	while (d1 < d2 || m1 < m2) {
//		d1++;
//		if (d1 > mom[m1]) {
//			m1++;
//			d1 = 1;
//		}
//		sum++;
//		if (d1 == 13) {
//			if ((sum % 7 + n) % 7 == 5) {
//				cout << m1 << endl;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//
//}

//2725:跳格问题 网上答案
//#include<iostream>
//using namespace std;
//int vis[30] = { 0 };
//int m[30] = { 0 };
//int main()
//{
//	int n, ans = 0;
//	cin >> n;
//	for (int i = 1; i <= n; i++)
//	{
//		cin >> m[i];
//	}
//	int index = 0;
//	m[0] = 1;
//	while (index <= n + 1)//当走出去了 也算是走到了终点
//	{
//		if (vis[index] == 1)
//		{
//			index++;
//			if (index >= n + 1)//走到了终点
//			{
//				ans++;//不太懂这里为什么是加1  不加2？
//				break;
//			}
//			else
//				ans += 2;
//		}
//		else
//		{
//			vis[index] = 1;
//			ans++;
//			index += m[index];
//		}
//		if (index < 0)
//		{
//			index = 0;
//			ans++;
//		}
//		cout << index << " " << ans << " " << vis[index] << endl;
//	}
//	cout << ans;
//	system("pause");
//	return 0;
//}

//2730:求20以内n的阶乘
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//int main() {
//	double n,tot = 1;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		tot *= i;
//	}
//	//cout << tot << endl;
//	printf("%.0lf\n", tot);
//	system("pause");
//	return 0;
//}

//2732:求自然常数e的近似值（精确到n）
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//int main() {
//	double n, tot = 1.0, sum = 1.0;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		tot *= i;
//		sum = double(sum) + double(1.0) / double(tot);
//		//cout << sum << " " << double(1.0) / double(tot) << endl;
//
//	}
//	//cout << tot << endl;
//	printf("%.15lf\n", sum);
//	system("pause");
//	return 0;
//}


//2744:子串
//#include <stdio.h>
//#include <string.h>
//#include<iostream>
//using namespace std;
//#define N 100
//char s[N][N + 1], sub[N + 1], rev[N + 1];
//
//void strrev_2(char s[])
//{
//	int i = 0, j = strlen(s) - 1;
//	char c;
//	while (i < j) {
//		c = s[i];
//		s[i] = s[j];
//		s[j] = c;
//		i++;
//		j--;
//	}
//}
//
//int maxSubString(char t[], int len, int n)
//{
//	int sublen, srclen, flag, i, j;
//	sublen = srclen = len;
//	while (sublen > 0) {//遍历子串长度 从大到小 保证能得到正确答案
//		for (i = 0; i <= srclen - sublen; i++) {//遍历所有长度为sublen的子串 并且翻转子串
//			strncpy_s(sub, t + i, sublen);
//			strncpy_s(rev, t + i, sublen);
//			sub[sublen] = rev[sublen] = '\0';
//			strrev_2(rev);
//			flag = 1;
//			for (j = 0; j < n; j++) {//只要有一个串不满足条件 就不行 
//				if (strstr(s[j], sub) == NULL && strstr(s[j], rev) == NULL) {
//					flag = 0;
//					break;
//				}
//			}
//			if (flag)
//				return sublen;
//		}
//		sublen--;//子串长度-1
//	}
//	return 0;
//}
//
//int main(void)
//{
//	int t, n, minlen, len, pos, i;
//	cin >> t;
//	while (t--) {
//		cin >> n;
//		pos = 0;
//		minlen = N;
//		for (i = 0; i < n; i++) {
//			cin >> s[i];
//			len = (int)strlen(s[i]);
//			if (len < minlen) {
//				minlen = len;
//				pos = i;
//			}
//		}
//
//		/* 输出结果 */
//		printf("%d\n", maxSubString(s[pos], minlen, n));
//	}
//	system("pause");
//	return 0;
//}

//2745:显示器
//#include <iostream>
//#include <cstdio>
//#include <cstring>
//
//using namespace std;
//
//string typematrix[10][5] = {
//	{
//		" - ",
//		"| |",
//		"   ",
//		"| |",
//		" - "
//	},
//	{
//		"   ",
//		"  |",
//		"   ",
//		"  |",
//		"   "
//	},
//	{
//		" - ",
//		"  |",
//		" - ",
//		"|  ",
//		" - "
//	},
//	{
//		" - ",
//		"  |",
//		" - ",
//		"  |",
//		" - "
//	},
//	{
//		"   ",
//		"| |",
//		" - ",
//		"  |",
//		"   "
//	},
//	{
//		" - ",
//		"|  ",
//		" - ",
//		"  |",
//		" - "
//	},
//	{
//		" - ",
//		"|  ",
//		" - ",
//		"| |",
//		" - "
//	},
//	{
//		" - ",
//		"  |",
//		"   ",
//		"  |",
//		"   "
//	},
//	{
//		" - ",
//		"| |",
//		" - ",
//		"| |",
//		" - "
//	},
//	{
//		" - ",
//		"| |",
//		" - ",
//		"  |",
//		" - "
//	}
//};
//
//int getrow(int row, int multiple)
//{
//	if (row == 0)
//		return 0;   // 第1行
//	else if (row < multiple + 1)
//		return 1;   // 第2行
//	else if (row == multiple + 1)
//		return 2;   // 第3行
//	else if (row == 2 * multiple + 2)
//		return 4;   // 第5行
//	else
//		return 3;   // 第4行
//}
//
//void zoom(string& s, int n)
//{
//	printf("%c", s[0]);
//	for (int i = 0; i < n; i++) {
//		printf("%c", s[1]);
//	}
//	printf("%c", s[2]);
//}
//
//int main()
//{
//	int n;
//	char s[100];
//
//	while (cin >> n >> s && n) {
//		for (int i = 0; i < 2 * n + 3; i++) {                // 行控制
//			for (int j = 0; j < (int)strlen(s); j++) {     // 列控制
//				if (j != 0)//在两个数字之间要输出一个空白的列
//					printf(" ");
//				zoom(typematrix[s[j] - '0'][getrow(i, n)], n);
//			}
//			printf("\n");
//		}
//		printf("\n");
//	}
//
//	return 0;
//}

//2748:全排列
//#define _CRT_SECURE_NO_WARNINGS  
//#include <stdio.h>
//#include <math.h>
//#include <algorithm>
//#include <stdlib.h>
//#include <vector>
//#include <map>
//#include <queue>
//#include <string>
//#include <iostream>
//#include <ctype.h>
//#include <string.h>
//#include <set>
//#include <stack>
//#include<functional>
//using namespace std;
//#define Size 27
//#define maxn  1<<30
//int  mark[Size];
//int b[Size];
//char a[Size];
//set<char> s;
//vector<char> v;
//int len;
//void dfs(int pos) {
//	if (pos > len) {
//		vector<char>::iterator iter = v.begin();
//		for (; iter < v.end(); iter++)
//			cout << *iter;
//		cout << endl;
//		return;
//	}
//	for (int i = 0; i < 26; i++) {
//		if (b[i] && mark[i] == 0)
//		{
//			char c = i + 'a';
//			v.push_back(c);
//			mark[i] = 1;
//			dfs(pos + 1);
//			mark[i] = 0;
//			v.pop_back();
//		}
//	}
//}
//int main() {
//
//	cin >> a;
//	len = strlen(a);
//	for (int i = 0; i < len; i++) {//b取值只可能为01 因为题目说是有不同的小写字母组成的字符串
//		b[a[i] - 'a']++;
//	}
//	
//	dfs(1);
//	system("pause");
//	return 0;
//}

//2750:鸡兔同笼
//#include<iostream>
//using namespace std;
//int main() {
//	int n;
//	cin >> n;
//	int minx, maxx;
//	if (n % 2 != 0) {
//		cout << 0 << " " << 0 << endl;
//
//	}
//	else {
//		maxx = n / 2;
//		if (n % 4 == 0) {
//			minx = n / 4;
//		}
//		else {
//			minx = (n - 2) / 4 + 1;
//		}
//		cout << minx << " " << maxx << endl;
//		system("pause");
//		return 0;
//	}
//	
//}

//2753:菲波那契数列  菲波那契数列(2)
//#include <iostream>
//#include<string.h>//memset函数要头文件string.h
//using namespace std;
//const int maxn = 1000000;
//long long m[maxn];
//int main() {
//	memset(m, 0, sizeof(m));
//	m[1] = 1;
//	m[2] = 1;
//	for (int i = 3; i <= maxn+20; i++) {
//		m[i] = (m[i - 1] + m[i - 2]) % 1000;
//	}
//	
//	int n;
//	cin >> n;
//	int k;
//	while (n--) {
//		cin >> k;
//		cout << m[k] << endl;
//	}
//	system("pause");
//	return 0;
//}



//2759:神奇的口袋(2)  超时
//#include<iostream>
//using namespace std;
//const int maxn = 220;
//int m[maxn];
//int ans = 0;
//int n;
//int tot = 0;
//void dfs(int x) {//已经考虑了第1-x件物品   现在考虑第x件物品
//	if (tot >= 400) {
//		if (tot == 400) {
//			//cout << "hhh" << endl;
//			ans = (ans + 1) % 10000;	
//		}
//		return;
//	}
//	for (int i = x; i <= n; i++) {//这里遍历后面的物品 
//
//		tot = tot + m[i];
//		//cout << i << " " << tot << endl;
//		dfs(i + 1);//这里是i+1 不是x+1
//		tot = tot - m[i];
//	}
//}
//int main() {
//
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//	}
//	dfs(1);
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//2759:神奇的口袋(2)
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;//原来数组只开了110 太小了 要开大一点
//int m[maxn];
//int dp[maxn][maxn];
//int main() {
//	memset(dp, 0, sizeof(dp));
//	memset(m, 0, sizeof(m));
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		cin >> m[i];
//		dp[i][0] = 1;
//	}
//	dp[0][0] = 1;
//	for (int i = 1; i <= n; i++) {//遍历n个物品
//		for (int j = 0; j <= 400; j++) {//遍历背包的总容量
//			if (j < m[i]) {
//				dp[i][j] = dp[i - 1][j];
//			}
//			if (j >= m[i]) {//这里要取等号
//				dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - m[i]]) % 10000;
//			}
//			//cout << dp[i][j] << endl;
//		}
//	}
//	cout << dp[n][400];
//	system("pause");
//	return 0;
//}

//2774:木材加工
//#include <iostream>
//using namespace std;
//int len[10001]={0},n,k;
//int input(){
//    cin>>n>>k;
//    int max=0;
//    for(int i=0;i<n;++i){
//    	cin>>len[i];
//    	if(len[i]>max)
//    		max=len[i];
//    }
//    return max;
//}
//int solve(int max){
//    int l = 1;
//    int r = max;
//    while(l<=r){
//        int mid = (l+r)/2;
//        int sum = 0;
//        for(int i=0;i<n;++i){
//            sum+=len[i]/mid;
//        }
//        if(sum<k) r = mid-1;
//        else if(sum>=k) l = mid+1;
//    }
//    return r;
//}
//int main(){
//    int p=input();
//    cout<<solve(p)<<endl;
//	system("pause");
//    return 0;
//}

//2775:文件结构“图”
//#include <iostream>
//#include <set>
//#include<string>
//using namespace std;
//int n = 0;//层数
//int m = 1;//第几组数据
//bool have_print;
//bool stop = false;
//void print(void) {
//	if (have_print == false) {
//		have_print = true;
//		if (m != 1) cout << endl;
//		cout << "DATA SET " << m << ":" << endl << "ROOT" << endl;
//	}
//}
//void fun(void) {
//	string str;
//	set<string> s;
//	while (cin >> str) {
//		switch (str[0]) {
//		case '#':
//			stop = true;
//			return;
//		case 'f':
//			print();
//			s.insert(str);
//			break;
//		case 'd':
//			print();
//			n++;
//			for (int i = 0; i < n; i++) {
//				cout << "|     ";
//			}
//			cout << str << endl;
//			fun();
//			break;
//		case ']':
//			for (set<string>::iterator itr = s.begin(); itr != s.end(); itr++) {
//				for (int j = 0; j < n; j++) {
//					cout << "|     ";
//				}
//				cout << *itr << endl;
//			}
//			n--;
//			return;
//		case '*':
//			for (set<string>::iterator i = s.begin(); i != s.end(); i++) {
//				cout << *i << endl;
//			}
//			m++;
//			return;
//		}
//	}
//}
//int main() {
//	while (!stop) {
//		have_print = false;
//		fun();
//	}
//	system("pause");
//	return 0;
//}



//
//#include<stdio.h>
//#include<string.h>
//#include<queue>
//#include<iostream>
//using namespace std;
//
//typedef struct nn
//{
//	int y, x;
//}node;
//typedef struct nnn
//{
//	char ID;
//	int nenli, cofu, life;
//	int fite, dir;
//}people;
//
//int inList[2][13][13], peopNumb[2][13][13], step;
//people p[2][13][13][1005];
//queue<node> head[2];
//void setFite(people &pp)
//{
//	double f;
//	if (pp.ID == 'S')
//		f = (0.5*pp.nenli + 0.5*pp.cofu)*(pp.life + 10) / 100.0;
//	else if (pp.ID == 'W')
//		f = (0.8*pp.nenli + 0.2*pp.cofu)*(pp.life + 10) / 100.0;
//	else f = (0.2*pp.nenli + 0.8*pp.cofu)*(pp.life + 10) / 100.0;
//	pp.fite = (int)f;
//}
//void moveTo(people pp, int flog, int y, int x)
//{
//	int n = peopNumb[flog][y][x];
//	p[flog][y][x][++n] = pp;
//	peopNumb[flog][y][x]++;
//}
//void countLoct(people &pp, int &y, int &x)
//{
//	if (pp.ID == 'S') {
//		if (pp.dir == 0) {
//			if (y == 12)pp.dir = 1, y = 11;
//			else y += 1;
//		}
//		else {
//			if (y == 1)pp.dir = 0, y = 2;
//			else y -= 1;
//		}
//	}
//	else if (pp.ID == 'W') {
//		if (pp.dir == 0) {
//			if (x == 12)pp.dir = 1, x = 11;
//			else x += 1;
//		}
//		else {
//			if (x == 1)pp.dir = 0, x = 2;
//			else x -= 1;
//		}
//	}
//	else if (pp.ID == 'E')
//	{
//		if (pp.dir == 0)
//		{
//			if (y == 12 && x > 1 || x == 12 && y > 1)
//				pp.dir = 1, y -= 1, x -= 1;
//			else if (y < 12 && x < 12) y += 1, x += 1;
//		}
//		else
//		{
//			if (y == 1 && x < 12 || x == 1 && y < 12)
//				pp.dir = 0, y += 1, x += 1;
//			else if (y > 1 && x > 1) y -= 1, x -= 1;
//		}
//	}
//}
//void GoFite(int flog)
//{
//	int ty, tx, i, j;
//	node q, qq;
//	for (i = 1; i <= 12; i++)
//		for (j = 1; j <= 12; j++)
//			inList[!flog][i][j] = 0;
//	while (!head[flog].empty())
//	{
//		q = head[flog].front(); head[flog].pop();
//		int &n = peopNumb[flog][q.y][q.x];
//		people &pp1 = p[flog][q.y][q.x][1];
//		people &pp2 = p[flog][q.y][q.x][2];
//		if (n == 2 && pp1.ID != pp2.ID)
//		{
//			pp1.life -= pp2.fite; pp2.life -= pp1.fite;
//			if (pp1.life <= 0 && pp2.life > 0)
//				pp1 = pp2, n--;
//			else if (pp1.life > 0 && pp2.life <= 0)
//				n--;
//			else if (pp1.life <= 0 && pp2.life <= 0)
//				n = 0;
//		}
//
//		for (; n > 0; n--)
//		{
//			ty = q.y; tx = q.x;
//			countLoct(p[flog][q.y][q.x][n], ty, tx);
//			setFite(p[flog][q.y][q.x][n]);
//			moveTo(p[flog][q.y][q.x][n], !flog, ty, tx);
//			if (inList[!flog][ty][tx] == 0)
//			{
//				qq.y = ty; qq.x = tx;
//				head[!flog].push(qq);
//				inList[!flog][ty][tx] = 1;
//			}
//		}
//	}
//	step--;
//	if (step)
//		GoFite(!flog);
//}
//int main()
//{
//	int data_cnt, y, x, flog;
//	char str[5];
//	people s;
//	node q;
//
//	scanf("%d", &data_cnt);
//	while (data_cnt--)
//	{
//		memset(inList, 0, sizeof(inList));
//		memset(peopNumb, 0, sizeof(peopNumb));
//		scanf("%d", &step);
//		while (scanf("%s", str) > 0 && str[0] != '0')
//		{
//			s.ID = str[0];
//			s.dir = 0;
//			scanf("%d%d%d%d%d", &x, &y, &s.nenli, &s.cofu, &s.life);
//			int &n = peopNumb[0][x][y];
//			p[0][x][y][++n] = s;
//			setFite(p[0][x][y][n]);
//			if (!inList[0][x][y])
//			{
//				q.y = x; q.x = y; inList[0][x][y] = 1;
//				head[0].push(q);
//			}
//		}
//		flog = step % 2;
//		GoFite(0);
//		int m[3] = { 0 }, sum[3] = { 0 };
//		while (!head[flog].empty())
//		{
//			q = head[flog].front(); head[flog].pop();
//			x = q.y; y = q.x;
//			int n = peopNumb[flog][x][y];
//			for (; n > 0; n--)
//			{
//				if (p[flog][x][y][n].ID == 'S')m[0]++, sum[0] += p[flog][x][y][n].life;
//				if (p[flog][x][y][n].ID == 'W')m[1]++, sum[1] += p[flog][x][y][n].life;
//				if (p[flog][x][y][n].ID == 'E')m[2]++, sum[2] += p[flog][x][y][n].life;
//			}
//		}
//		printf("%d %d\n%d %d\n%d %d\n", m[0], sum[0], m[1], sum[1], m[2], sum[2]);
//		printf("***\n");
//	}
//}

//2791:矩形覆盖  没看懂
/**
首先的一个感觉就是问题的解决思路不是很直观，推断应该是搜索算法
既然是搜索算法，就要找到问题对应的状态，
应该是这样的，我们的目标就是找到一个合适矩形组合，使得这个组合
既能覆盖所有的点，又能使得面积最小，
状态：所有的点被覆盖的情况，总面积
初始条件：所有的点都还没有被覆盖，总面积为0
目标 ：所有的点都被覆盖，总面积为s
递推规则：如果我们能知到任意一种占用情况对应的尚需最小总面积，那问题顿时就简单了，
问题就解决了，我们需要一个2^15的数组记录状态还需的最小总面积，如果用数组记录状态，对应的
寻址将会变得非常麻烦，如果我们用一个n位的二进制数记录占用状态，用位运算改变状态
这样寻址就变得非常容易。
其实占用顺序很关键，要遍历所有可能
**/
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#define MAX_LEN 15
//int min_area[1 << MAX_LEN];
//int occupion/**这个整数的位用来记录点的覆盖情况，1表示未被覆盖，0表示已被覆盖**/;
//int point[15][2]/**每个点的信息**/, num/**点的个数**/;
//int area(int i, int j)//特殊的函数，这个函数对于同一直线上的两点，返回的面积是距离差，这样在计算最小面积时会自动舍去重复占用的方案
//{
//	if (point[i][0] == point[j][0]) return abs(point[i][1] - point[j][1]);
//	if (point[i][1] == point[j][1]) return abs(point[i][0] - point[j][0]);
//	return abs(point[i][1] - point[j][1])*abs(point[i][0] - point[j][0]);
//}
//int search(int n)/**搜索函数，传入值为正在处理的占用情况,输出值为对应占用情况尚需的最小面积**/
//{
//	int i, j, k;
//	if (min_area[n] >= 0)//如果这种状态对应的问题已经解决
//		return min_area[n];
//	if (n == 0)
//		return min_area[n] = 0;
//	min_area[n] = 40000000;
//	for (i = 0; i<num; i++)
//	{
//		if (n&(1 << i))//如果第i+1个点尚未被占用
//		{
//			for (j = 0; j<num; j++)
//			{
//				if (i != j)
//				{
//					int tmp, s;
//					tmp = n & (~((1 << i) | (1 << j)));
//					for (k = 0; k<num; k++)
//						if ((point[i][0] == point[k][0] && point[j][1] == point[k][1]) || (point[i][1] == point[k][1] && point[j][0] == point[k][0]))
//							tmp &= (~(1 << k));
//					s = area(i, j) + search(tmp);
//					if (s<min_area[n])
//						min_area[n] = s;
//				}
//			}
//		}
//	}
//	return min_area[n];
//}
//int main()
//{
//	int i;
//	scanf("%d", &num);
//	while (num)
//	{
//		for (i = 0; i<num; i++)
//			scanf("%d%d", &point[i][0], &point[i][1]);
//		memset(min_area, -1, sizeof(min_area));
//		occupion = (1 << num) - 1;//覆盖状态初始化，所有的点对应的位都是1
//		printf("%d\n", search(occupion));
//		scanf("%d", &num);
//	}
//	return 0;
//}

//2791:矩形覆盖
//#include<cstdio>
//#include<cstring>
//
//const int NS = 15;
//const int INF = 1 << 30;
//
//int n, lx, rx, uy, dy, lim;
//int g[NS][NS], ar[NS][NS];
//int x[NS], y[NS], dp[1 << NS];
//
//int Max(int xa, int xb) {
//	return xa>xb ? xa : xb;
//}
//
//int Min(int xa, int xb) {
//	return xa<xb ? xa : xb;
//}
//
//int main()
//{
//	while (~scanf("%d", &n) && n)
//	{
//		for (int i = 0; i<n; i++)
//			scanf("%d%d", &x[i], &y[i]);
//		for (int i = 0; i<n; i++)
//			for (int j = 0; j<i; j++)
//			{
//				g[i][j] = 0;
//				lx = Min(x[i], x[j]), rx = Max(x[i], x[j]);
//				dy = Min(y[i], y[j]), uy = Max(y[i], y[j]);
//				for (int k = 0; k<n; k++)
//					if (lx <= x[k] && x[k] <= rx && dy <= y[k] && y[k] <= uy)
//						g[i][j] |= 1 << k;
//				rx = rx - lx ? rx - lx : 1; uy = uy - dy ? uy - dy : 1;
//				ar[i][j] = ar[j][i] = rx * uy;
//			}
//
//		lim = 1 << n, dp[0] = 0;
//		for (int i = 1; i<lim; i++)
//			dp[i] = INF;
//		for (int i = 0; i<lim; i++)
//			for (int j = 0; j<n; j++)
//				for (int k = 0; k<j; k++)
//				{
//					lx = i | g[j][k];
//					dp[lx] = Min(dp[lx], dp[i] + ar[j][k]);
//				}
//		printf("%d\n", dp[lim - 1]);
//	}
//	return 0;
//}

//2797:最短前缀
//#include <iostream>
//#include <stdio.h>
//#include <string>
//#include <cstring>
//using namespace std;
//
//char w[1010][45];
//char pre[22];
//int n;
//
//bool in(char *s, int index)
//{
//	if (strcmp(s, w[index]) == 0)//s就是本身
//		return 0;
//	for (int i = 0; i < n; i++) {
//		/*返回值：
//			（1）字符串1 = 字符串2，返回0
//			（2）字符串1>字符串2，返回一个正整数
//			（3）字符串1<字符串2，返回一个负整数。*/
//		if (i == index)
//			continue;
//		//strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。
//		if (strstr(w[i], s) == &w[i][0]) {
//			//cout << " hhh " << s << " " << i << " " << w[i] << endl;
//			return 1;
//		}
//
//	}
//	return 0;
//}
//
//int main()
//{
//	//freopen("1.txt", "r", stdin);
//	n = 0;
//	while (cin >> w[n++]);
//
//	for (int i = 0; i < n; i++) {
//		//cout << endl << endl;
//		for (int j = 0; j < strlen(w[i]); j++) {
//			memset(pre, 0, sizeof(pre));
//			/*extern char *strncpy(char *dest, char *src, int n);
//			把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中。*/
//			strncpy_s(pre, w[i], j + 1);
//			if (!in(pre, i)) {
//				/*将两个char类型连接。
//					char d[20] = "GoldenGlobal"; char *s = "View"; strcat(d, s);
//				结果放在d中*/
//				strcat_s(w[i], " ");
//				strcat_s(w[i], pre);
//				//cout << w[i] << endl;
//				break;
//			}
//		}
//	}
//
//	for (int i = 0; i < n; i++)
//		puts(w[i]);
//
//
//	system("pause");
//	return 0;
//}

//2799:浮点数格式
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//const int maxn = 10010;
//string pre[maxn];
//string post[maxn];
//int main() {
//	int n;
//	cin >> n;
//	string nonsense;
//	getline(cin, nonsense);
//	int mxv = 0;
//	for (int i = 0; i < n; i++) {
//		getline(cin, pre[i], '.');
//		getline(cin, post[i]);
//		//cout << i << " " << pre[i] << " " << post[i] << endl;
//		int len = pre[i].length();
//		mxv = max(len, mxv);
//	}
//	for (int i = 0; i < n; i++) {
//		int len = pre[i].length();
//		for (int j = len; j < mxv; j++) {
//			cout << " ";
//		}
//		cout << pre[i] << "." << post[i] << endl;
//	}
//	system("pause");
//	return 0;
//}


//2801:填词
//#include<stdio.h>
//#include<iostream>
//using namespace std;
//int main()
//{
//	int characters[26];
//	int n, m, p;
//	int i, j;
//	for (i = 0; i<26; i++)
//		characters[i] = 0;
//	cin>>n>>m>>p;
//	for (i = 0; i<n; i++) {
//		char str[11];
//		cin>>str;
//		for (j = 0; str[j] != '\0'; j++)
//			characters[str[j] - 'A']++;
//	}
//	/*for (int i = 0; i < 26; i++) {
//		cout << char(i + 'A') << " " << characters[i] << endl;
//	}*/
//	for (i = 0; i<p; i++) {
//		char str[200];
//		cin>>str;
//		for (j = 0; str[j] != '\0'; j++)
//			characters[str[j] - 'A']--;
//	}
//	/*for (int i = 0; i < 26; i++) {
//		cout << char(i + 'A') << " " << characters[i] << endl;
//	}*/
//	for (i = 0; i<26; i++) {
//		if (characters[i] != 0)
//			for (j = 0; j<characters[i]; j++)
//				printf("%c", i + 'A');
//	}
//	printf("\n");
//	system("pause");
//	return 0;
//}


// 2805:正方形
//#include <iostream>
//#include<map>
//# include <stdio.h>
//# include <string.h>
//#include<algorithm> 
//using namespace std;
////基本步骤就是先给点排序（map里面自动排序） ，然后对枚举两个点，对剩下两个点进行搜索即可 
//struct Point {
//	int x, y;
//	bool operator < (const Point &b) const {
//		return x < b.x || (x == b.x &&y < b.y);
//	}
//};
////struct zb {
////	int x, y;
////	friend bool operator < (zb a, zb b) {
////		return a.x < b.x || (a.x == b.x && a.y < b.y);
////	}
////};
//int n, res;
//Point pnt[1100], p1, p2;
//map<Point, int> mp;//map里面是struct时要有<这个排序方法 
//bool not_equ(Point a, Point b) {
//	if (a.x != b.x || a.y != b.y) {
//		return true;
//	}
//	return false;
//}
//int main(int argc, char *argv[]) {
//	while (cin >> n) {
//		if (n == 0)break;
//		res = 0;
//		mp.clear();//每次都要重新初始化 
//		for (int i = 0; i < n; i++) {
//			cin >> pnt[i].x >> pnt[i].y;
//			mp[pnt[i]]++;//hash每个点对应出现的次数 
//					   //加入map后会自动从小到大排序 
//		}
//		for (int i = 0; i < n; i++) {
//			for (int j = 0; j < n; j++) {
//				if (i == j || !not_equ(pnt[i], pnt[j]))continue;
//				//找对应两个点是否存在 
//				int dx = pnt[i].x - pnt[j].x;
//				int dy = pnt[j].y - pnt[i].y;
//				p1.x = pnt[j].x + dy;
//				p1.y = pnt[j].y + dx;
//				p2.x = pnt[i].x + dy;
//				p2.y = pnt[i].y + dx;
//				cout << pnt[i].x << " " << pnt[i].y << " " << pnt[j].x << " " << pnt[j].y << " " << p1.x << " " << p1.y << " " << p2.x << " " << p2.y << " " << res << endl;
//
//				if (not_equ(p1, pnt[i]) && not_equ(p1, pnt[j]) && not_equ(p2, pnt[i]) && not_equ(p2, pnt[j])) {
//					if (mp.find(p1) != mp.end() && mp.find(p2) != mp.end()) {
//						res = res + 1 ;//* mp[p1] * mp[p2]
//					}
//				}
//			}
//		}
//		cout << res / 4 << endl;
//	}
//	return 0;
//}

//2811:熄灯问题
//#include<cstdio>
//#include<iostream>
//using namespace std;
//
//int n;
//int block[7][8], ans[7][8];
//
////判断当前解是否可行
//bool check_ans()
//{
//	for (int i = 2; i <= 6; i++)
//	{
//		for (int j = 1; j <= 6; j++) {  //第i行第j列的灯的状态唯一确定 
//
//			ans[i][j] = block[i - 1][j] ^ ans[i - 1][j] ^ ans[i - 1][j - 1] ^ ans[i - 1][j + 1] ^ ans[i - 2][j];
//			cout << i << " " << j << " " << ans[i][j] << endl;
//		}
//	}
//	for (int j = 1; j <= 6; j++)    //检查最后一行是否全部关闭 
//		if (ans[6][j] == 1) return false;
//	return true;
//}
//
//void solve()
//{
//	for (int i = 0; i < (1 << 6); i++)   //枚举第一行按钮的状态 
//	{
//		int k = i;      //这行运用了状态压缩的思想，将每一个状态压缩成整型 
//		for (int j = 1; j <= 6; j++)
//		{
//			ans[1][j] = k % 2;    //k二进制表示的每一位表示一个灯的状态 
//			k /= 2;
//			cout << "hhh 1 " << " " << ans[1][j] << " ";
//		}
//		cout << endl;
//		if (check_ans()) break;  //检查该方案是否可以关掉全部的灯 
//	}
//	for (int i = 1; i <= 5; i++)
//	{
//		for (int j = 1; j <= 6; j++)  //输出答案 
//			printf("%d ", ans[i][j]);
//		printf("\n");
//	}
//}
//
//int main()
//{
//	for (int j = 1; j <= 5; j++)
//		for (int k = 1; k <= 6; k++)
//			cin >> block[j][k];  //读入初始状态 
//	solve();
//	system("pause");
//	return 0;
//}

//2812:恼人的青蛙
//#include <iostream>
//#include <vector>
//#include<algorithm>
//using namespace std;
//
//struct point {
//	int r;
//	int l;
//	point(int _r, int _l) :r(_r), l(_l) {}
//};
//
//bool operator < (const point a, const point b) {
//	return a.r == b.r ? a.l<b.l : a.r<b.r;
//}
//
//bool operator == (const point a, const point b) {
//	return a.r == b.r&&a.l == b.l;
//}
//
//int steps(vector<point> point_v, int start, int r, int l, int R, int C) {
//	// starts是开始的点，r,l是横，纵的步长，R和C是田野的边缘的大小
//	int count = 1, t_l, t_r;
//	while (true) {
//		//产生了下一个点
//		t_l = point_v[start].l + l;
//		t_r = point_v[start].r + r;
//		if (binary_search(point_v.begin(), point_v.end(), point(t_r, t_l))) {
//			//如果产生的第三个点在这个点的集合里面，则步数加一
//			count++;
//			vector<point>::iterator it = find(point_v.begin(), point_v.end(), point(t_r, t_l));
//			int dis = distance(point_v.begin(), it);
//			start = dis;
//		}
//		else {
//			if (t_r>R || t_l>C || t_r<1 || t_l<1) {
//				//跳出去了，返回步长，这里注意，有可能是从左上，左下，右上，右下四个方向跳出，所以要加上小于1的情况
//				return count;
//			}
//			else {
//				//跳到一半断了，返回1,不是合法的路线
//				return 0;
//			}
//		}
//	}
//}
//
//int main() {
//	int N, R, C, r, l, t_r, t_l, maxs = 2;
//	vector<point> point_v;
//	cin >> R >> C >> N;
//	while (N--) {
//		int r, l;
//		cin >> r >> l;
//		point_v.push_back(point(r, l));
//	}
//	sort(point_v.begin(), point_v.end());
//	//从左上角向下遍历，枚举每个存在的  点
//	for (int j = 0; j < point_v.size() - 1; ++j) {
//		for (int k = j + 1; k < point_v.size(); ++k) {
//			//用前两个点产生步长
//			r = point_v[k].r - point_v[j].r;
//			l = point_v[k].l - point_v[j].l;
//			//如果第一个点在这两个点产生的步长下，前一个点不在田野里，那么这个点符合规则，否则，这个点不符合规则，步长太小
//			t_l = point_v[j].l - l;
//			t_r = point_v[j].r - r;
//			//注意，下面的三个判断的条件，缺一不可，否则就会超时
//			if (t_l >= 1 && t_l <= C && t_r >= 1 && t_r <= R) {
//				//第二个点取的不合适，换下一个第二个点
//				continue;
//			}
//			if (point_v[j].r + (maxs - 1)*r>R) {
//				//如果在第一个点加当前最大的步长，超过了整个田野的范围，那么，说明第一个点和步长一定的情况下，这个步数一定是小于maxs的
//				//在这种情况下，因为是排序好的，所以，越往后，产生的步长就越大，产生的步数就越小，因此认为这里第一个点取的有问题
//				//换个第一个点
//				break;
//			}
//			if (point_v[j].l + (maxs - 1)*l>C || point_v[j].l + (maxs - 1)*l<1) {
//				//这里和r方向不同，因为r方向是严格递增的，而l方向不是严格递增的，因此，可以换第二个点试一下
//				continue;
//			}
//			//如果都是没问题的，那么就产生一个新的步数，进行比较
//			int exam = steps(point_v, j, r, l, R, C);
//			if (exam > maxs)
//			{
//				maxs = exam;
//
//			}
//		}
//	}
//	if (maxs == 2) maxs = 0;
//	cout << maxs << endl;
//	return 0;
//}


//2814:拨钟问题
//#include <iostream>
//#include <cstring>
//using namespace std;
//bool isOk(int tmp[]) {
//	for (int i = 0; i < 9; ++i) {
//		if (tmp[i] != 0) return false;
//	}
//	return true;
//}
//
//void oj_1_2() {
//	int a[10];
//	for (int i = 0; i < 9; ++i) {
//		cin >> a[i];
//	}
//
//	int tmp[10];
//	memset(tmp, 0, sizeof(tmp));
//	for (int m1 = 0; m1 < 4; ++m1) {//枚举每一个移动的次数
//		for (int m2 = 0; m2 < 4; ++m2) {
//			for (int m3 = 0; m3 < 4; ++m3) {
//				for (int m4 = 0; m4 < 4; ++m4) {
//					for (int m5 = 0; m5 < 4; ++m5) {
//						for (int m6 = 0; m6 < 4; ++m6) {
//							for (int m7 = 0; m7 < 4; ++m7) {
//								for (int m8 = 0; m8 < 4; ++m8) {
//									for (int m9 = 0; m9 < 4; ++m9) {
//										tmp[0] = (a[0] + m1 + m2 + m4) % 4;//A  tmp表示时钟的状态
//										tmp[1] = (a[1] + m1 + m2 + m3 + m5) % 4;//B
//										tmp[2] = (a[2] + m2 + m3 + m6) % 4;//C
//										tmp[3] = (a[3] + m1 + m4 + m5 + m7) % 4;//D
//										tmp[4] = (a[4] + m1 + m3 + m5 + m7 + m9) % 4;//E
//										tmp[5] = (a[5] + m3 + m5 + m6 + m9) % 4;//F
//										tmp[6] = (a[6] + m4 + m7 + m8) % 4;//G
//										tmp[7] = (a[7] + m5 + m7 + m8 + m9) % 4;//H
//										tmp[8] = (a[8] + m6 + m8 + m9) % 4;//I
//										if (isOk(tmp)) {//因为是从小到大枚举,所以最先满足的肯定是最短的移动序列
//											for (int i = 0; i < m1; ++i) cout << "1 ";
//											for (int i = 0; i < m2; ++i) cout << "2 ";
//											for (int i = 0; i < m3; ++i) cout << "3 ";
//											for (int i = 0; i < m4; ++i) cout << "4 ";
//											for (int i = 0; i < m5; ++i) cout << "5 ";
//											for (int i = 0; i < m6; ++i) cout << "6 ";
//											for (int i = 0; i < m7; ++i) cout << "7 ";
//											for (int i = 0; i < m8; ++i) cout << "8 ";
//											for (int i = 0; i < m9; ++i) cout << "9 ";
//											cout << endl;
//											goto END;
//										}
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//END:
//	return;
//
//}
//
//int main() {
//	oj_1_2();
//
//	return 0;
//}

//2818:密码  参见网页
//#include <stdio.h>
//#include <string.h>
//#include<iostream>
//using namespace std;
//#define N_MAX 200 + 10
//int main()
//{
//	int n = 0;
//	int secret[N_MAX];//密钥
//	int k = 0;
//	char orin[N_MAX];
//	char orin_backup[N_MAX];//字符串备份
//	int T[N_MAX];//周期
//	int len = 0;
//	int pos = 0;
//	int i, j;
//
//	while (cin >> n && n != 0)
//	{
//		for (i = 1; i <= n; ++i)
//		{
//			cin >> secret[i];
//		}
//
//		for (i = 1; i <= n; ++i)//计算周期
//		{
//			pos = i;
//			for (j = 1; ; ++j)
//			{
//				pos = secret[pos];
//				if (pos == i)
//				{
//					T[i] = j;
//					break;
//				}
//			}
//		}
//
//		while (cin >> k && k != 0)
//		{
//			getchar();//销掉空格
//			gets_s(orin + 1, n + 2);
//			len = strlen(orin + 1);
//			for (i = len; i < n; ++i)
//			{
//				orin[1 + i] = ' ';
//			}
//			orin[1 + n] = '\0';
//			strcpy_s(orin_backup + 1, len, orin + 1);
//
//			for (i = 1; i <= n; ++i)
//			{
//				pos = i;
//				int nTimes = k % T[i];
//				for (j = 1; j <= nTimes; ++j)
//				{
//					pos = secret[pos];
//				}
//				orin[pos] = orin_backup[i];
//			}
//
//			printf("%s\n", orin + 1);
//		}
//		printf("\n");
//	}
//
//	return 0;
//}


//2819:W的密码
//#include <iostream>
//#include <string.h>
//#include <string>
//#include <stdio.h>
//using namespace std;
//int main()
//{
//	int k1, k2, k3;
//	int s1[10001], s2[10001], s3[10001];
//	string str;
//	char result[10001];
//	cin >> k1 >> k2 >> k3;
//	cin >> str;
//	while ((k1 != 0) || (k2 != 0) || (k3 != 0))
//	{
//		memset(s1, 0, 10001);
//		memset(s2, 0, 10001);
//		memset(s3, 0, 10001);
//		int cnt1 = 0;
//		int cnt2 = 0;
//		int cnt3 = 0;
//
//		for (int i = 0; i<str.length(); i++)   //s1,s2,s3储存位置信息
//		{
//			if (str[i] >= 'a'&&str[i] <= 'i')
//			{
//				s1[cnt1] = i;
//				cnt1++;
//			}
//			if (str[i] >= 'j'&&str[i] <= 'r')
//			{
//				s2[cnt2] = i;
//				cnt2++;
//			}
//			if ((str[i] >= 's'&&str[i] <= 'z') || str[i] == '_')
//			{
//				s3[cnt3] = i;
//				cnt3++;
//			}
//
//		}
//		for (int i = 0; i<cnt1; i++)
//		{
//			result[s1[(i + k1) % cnt1]] = str[s1[i]];
//		}
//		for (int i = 0; i<cnt2; i++)
//		{
//			result[s2[(i + k2) % cnt2]] = str[s2[i]];
//		}
//		for (int i = 0; i<cnt3; i++)
//		{
//			result[s3[(i + k3) % cnt3]] = str[s3[i]];
//		}
//		for (int i = 0; i<str.length(); i++)
//		{
//			cout << result[i];
//		}
//		cout << endl;
//		cin >> k1 >> k2 >> k3;
//		cin >> str;
//	}
//	system("pause");
//	return 0;
//}


//2868:牛顿迭代方法
//# include <math.h>
//# include <stdio.h>
//# include <iomanip>
//# include <string.h>
//# include <iostream>
//# include <algorithm>
//using namespace std;
//
//typedef long long ll;
//typedef long double ld;
//typedef unsigned long long ull;
//const int M = 5e5 + 10;
//const int mod = 1e9 + 7;
//
//# define RG register
//# define ST static
//
//int times;
//double n, x, px;
//
//int main() {
//	while (cin >> n) {
//		px = 1.0; times = 0;
//		while (1) {
//			++times;
//			x = (px + (double)n / px) / 2.0;
//			if (fabs(px - x) <= 1e-6) break;
//			px = x;
//			cout << px << " " << times << endl;
//		}
//		x = fabs(x);
//		cout << times << ' ' << setprecision(2) << setiosflags(ios::fixed) << x << endl;
//	}
//	return 0;
//}


//2871:整数奇偶排序
//#include<iostream>
//#include<algorithm>
//#include<set>
//#include<stack>
//using namespace std;
//multiset<int> ji;
//multiset<int> ou;
//stack<int> st;
//int main() {
//	int a[10];
//	while (cin >> a[0] >> a[1] >> a[2] >> a[3] >> a[4] >> a[5] >> a[6] >> a[7] >> a[8] >> a[9]) {
//		multiset<int> ji;
//		multiset<int> ou;
//		stack<int> st;
//		for (int i = 0; i < 10; i++) {
//			if (a[i] % 2 == 0) {
//				ou.insert(a[i]);
//			}
//			else {
//				ji.insert(a[i]);
//			}
//		}
//		for (auto itr = ji.begin(); itr != ji.end(); itr++) {
//			st.push(*itr);
//		}
//		int cnt = 1;
//		while (!st.empty()) {
//			int tp = st.top();
//			st.pop();
//			/*if (cnt == 10) {
//				cout << tp;
//			}
//			else {*/
//				cout << tp << " ";
//			/*}
//			cnt++;*/
//		}
//		for (auto itr = ou.begin(); itr != ou.end(); itr++) {
//			/*if (cnt == 10) {
//				cout << *itr;
//			}
//			else {*/
//				cout << *itr << " ";
//			/*}
//			cnt++;*/
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//2885:计算反序数
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//int main() {
//	int n;
//	
//	while (cin >> n) {
//		int isnag = 0;
//		if (n < 0) {
//			isnag = 1;
//			n = -n;
//		}
//		
//		stringstream ss;
//		ss << n;
//		
//		string str;
//		ss >> str;
//		//cout << "str " << str << endl;
//		reverse(str.begin(), str.end());
//		//cout << "rev str " << str << endl;
//		int res;
//		stringstream ss2;
//		ss2 << str;
//		ss2 >> res;
//		//cout << "res " << res << endl;
//		if (isnag == 1) {
//			cout << -res << endl;
//		}
//		else {
//			cout << res << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//2910:提取数字
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<vector>
//using namespace std;
//int main() {
//	string str;
//	cin >> str;
//	str += 'a';
//	vector<int> v;
//	for (int i = 0; i < str.length(); i++) {
//		string tp = "";
//		int j = i;
//		if (isdigit(str[j])) {
//			while (isdigit(str[j])) {
//				tp += str[j];
//				j++;
//			}
//			i = j;
//			stringstream ss;
//			int num;
//			ss << tp;
//			//cout << "tp " << tp << endl;
//			ss >> num;
//			v.push_back(num);
//			tp = "";
//		}
//
//
//	}
//	for (auto itr = v.begin(); itr != v.end(); itr++) {
//		cout << *itr << endl;
//	}
//	system("pause");
//	return 0;
//}

//2911 受限完全平方数
//#include<stdio.h>
//#include<iostream>
//using namespace std;
//
//int main()
//{
//	int i, j, k, a = 0;
//
//	scanf_s("%d", &a);
//	for (i = 32; i*i<a; i++)
//		for (j = 32; j*j <= i * i; j++)
//			for (k = 1; k<10; k++)
//				if (i*i - j * j == k * 1111)
//					printf("%d\n", i*i);
//	system("pause");
//	return 0;
//}

//2925:大整数的因子
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int main() {
//	double n;
//	cin >> n;
//	int suc = 0;
//	for (int i = 2; i < 10; i++) {
//		if (fabs(int(n) % i - 0) < 1e-6) {
//			cout << i << " ";
//			suc = 1;
//		}
//	}
//	if (suc == 0) {
//		cout << "none" << endl;
//	}
//	system("pause");
//	return 0;
//}

//2931:期末考试第二题——比较数字个数
//#include <iostream>
//#include <cstring>
//
//using namespace std;
//
//int main()
//{
//	char str1[150], str2[150];
//	int n = 0, j = 0, i = 0, k = 0, l = 0, m = 0, letters[52] = { 0 }, length1 = 0, length2 = 0;
//	bool flag = 0;
//	while (cin.getline(str1, 150))
//	{
//		cin.getline(str2, 150);
//		for (i = 0; i < 52; i++)
//			letters[i] = 0;
//		length1 = strlen(str1);
//		length2 = strlen(str2);
//		flag = 0;
//		for (j = 0; j < length2; j++) // 先扫描第二个串
//		{
//			if (((str2[j] >= 'a') && (str2[j] <= 'z')))
//				letters[str2[j] - 'a']++;
//			else if ((str2[j] >= 'A') && (str2[j] <= 'Z'))
//				letters[str2[j] - 'A' + 26]++;
//		}
//		for (j = 0; j < length1; j++)
//		{
//			if (((str1[j] >= 'a') && (str1[j] <= 'z')))
//			{
//				letters[str1[j] - 'a']--;
//				if (letters[str1[j] - 'a'] < 0)
//				{
//					flag = 1;
//					break;
//				}
//			}
//			else if ((str1[j] >= 'A') && (str1[j] <= 'Z'))
//			{
//				letters[str1[j] - 'A' + 26]--;
//				if (letters[str1[j] - 'A' + 26] < 0)
//				{
//					flag = 1;
//					break;
//				}
//			}
//		}
//		cout << !flag << endl;
//	}
//	system("pause");
//	return 0;
//}


//2936:试剂配制
//#include<iostream>
//#include<cstring>
//using namespace std;
//int m[9];
//int main() {
//	int n;
//	int x;
//	cin >> n;
//	memset(m, 0, sizeof(m));
//	int flag = 1;
//	for (int i = 0; i < n; i++) {
//		cin >> x;
//		m[x] = 1;
//	}
//	if (m[1] == 1 && m[2] == 1) {
//		flag = 0;
//	}
//	if (m[3] == 1 && m[4] == 1) {
//		flag = 0;
//	}
//	if ((m[5] == 1 && m[6] == 0) || (m[5] == 0 && m[6] == 1))
//	{
//		flag = 0;
//	}
//	if (m[7] == 0 && m[8] == 0) {
//		flag = 0;
//	}
//	cout << flag << endl;
//	system("pause");
//	return 0;
//}

//2938:按顺序输出
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int m[3];
//bool cmp(int a, int b) {
//	return a > b;
//}
//int main() {
//	for (int i = 0; i < 3; i++) {
//		cin >> m[i];
//	}
//	sort(m, m + 3,cmp);
//	for (int i = 0; i < 3; i++) {
//		cout << m[i] << " ";
//	}
//	system("pause");
//	return 0;
//}


//2949:平板着色
//#include <cstdio>
//#include <cstring>
//#include <vector>
//#include <stack>
//#include <algorithm>
//#include<iostream>
//using namespace std;
//struct node {
//	int y1, x1, y2, x2, color;
//}p[20];
//vector <int> vec[20];
//int sta[20], k;
//int in[20], min1, n;
//int vis[20];
//int cmp(node a, node b) {
//	return a.y1 < b.y1;
//}
//void dfs(int c, int num, int ans) {
//	if (ans > min1) {
//		return;
//	}
//	if (num == n) {
//		min1 = ans;
//		return;
//	}
//	int i, j, len;
//	for (i = 0; i < n; i++) {
//		//如果这个方块已经被涂过了 或者 这个方块上面还有方块没有涂 则现在不能涂
//		if (vis[i] || in[i]) continue;
//		if (p[i].color == c) {
//			vis[i] = 1;
//			len = vec[i].size();
//			for (j = 0; j < len; j++)
//				in[vec[i][j]]--;
//			//sta[k++] = i;
//			dfs(c, num + 1, ans);
//			//k--;
//			vis[i] = 0;//回溯
//			for (j = 0; j < len; j++)
//				in[vec[i][j]]++;
//		}
//		else {
//			vis[i] = 1;
//			len = vec[i].size();
//			for (j = 0; j < len; j++)
//				in[vec[i][j]]--;
//			//sta[k++] = i;
//			dfs(p[i].color, num + 1, ans + 1);
//			//k--;
//			vis[i] = 0;
//			for (j = 0; j < len; j++)
//				in[vec[i][j]]++;
//		}
//	}
//}
//int main() {
//	int t, i, j;
//	cin >> t;
//	while (t--) {
//		cin >> n;
//		memset(in, 0, sizeof(in));
//		memset(vis, 0, sizeof(vis));
//		for (i = 0; i < n; i++) vec[i].clear();
//		for (i = 0; i < n; i++) {
//			cin >> p[i].y1 >> p[i].x1 >> p[i].y2 >> p[i].x2 >> p[i].color;
//		}
//		sort(p, p + n, cmp);//从上到下排序
//		for (i = 0; i < n; i++) {
//		//	cout << p[i].x1 << " " << p[i].y1 << " " << p[i].x2 << " " << p[i].y2 << endl;
//			for (j = i + 1; j < n; j++) {
//				if (p[i].y2 == p[j].y1 && !(p[j].x2 <= p[i].x1 || p[j].x1 >= p[i].x2)) {
//					vec[i].push_back(j);
//					in[j]++;//表示j号方块上方的方块数量
//				}
//			}
//		}
//		min1 = 100;
//		for (i = 0; i < n; i++) {
//			if (p[i].y1) break;
//			dfs(p[i].color, 0, 0);
//		}
//		printf("%d\n", min1 + 1);
//	}
//	system("pause");
//	return 0;
//}


//2973:Skew数
//#include <stdio.h>
//#include <string.h>
//#include<iostream>
//#include <math.h>
//using namespace std;
//int main()
//{
//	int base[31];
//	int i, sum;
//	char skew[32];
//	base[0] = 1;
//	//用一个整型数组base[31]，依次存储skew数最末位、倒数第2 位、…..、第31 位的基数值
//	for (i = 1; i <31; i++)
//	{
//		base[i] = 2 * base[i - 1] + 1;
//		//cout << i << " " << base[i] << endl;
//	}
//	while (1) {
//		cin>>skew;
//		sum = 0;
//		if (strcmp(skew, "0") == 0)
//			break;
//		int len = strlen(skew);
//		for (i = 0; i < len; ++i)
//		{
//			sum += (skew[i] - '0')*base[len - i - 1];
//		}
//		printf("%d\n", sum);
//
//	}
//	return 0;
//}


//2977:生理周期  wa 不知道为啥
//#include<iostream>
//using namespace std;
//int main() {
//	int p, e, i, d;
//	int j;
//	while (cin >> p >> e >> i >> d) {
//		if (p == -1) {
//			break;
//		}
//		
//		for (j = d + 1; j <= 21252; j++) {
//			if ((j - p) % 23 == 0 && (j - e) % 28 == 0 && (j - i) % 33 == 0) {
//
//				break;
//			}
//		}
//		cout << j - d << endl;
//	}
//
//	system("pause");
//	return 0;
//}





//2987:二项式系数
//#include<iostream>
//using namespace std;
//int main()
//{
//	int n, k;
//	while (cin >> n >> k)
//	{
//		cout << n << " " << k << " " << (n & k) << endl;
//		if ((n&k) == k)
//			cout << 1 << endl;
//		else
//			cout << 0 << endl;
//	}
//	system("pause");
//	return 0;
//}

//2994:拼装模型
//#include<iostream>
//#include<queue>
//using namespace std;
//struct Node
//{
//	int v;
//	bool operator<(const Node&a)const {
//		return v > a.v;
//	}
//};
//int main() {
//	priority_queue<Node> q;
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		Node nd;
//		cin >> nd.v;
//		q.push(nd);
//	}
//	int ans = 0;
//	int tp = 0;
//	while (!q.empty()) {
//		Node first = q.top();
//		q.pop();
//		
//		if (!q.empty()) {
//			Node second = q.top();
//			q.pop();
//			//cout << first.v<<" "<<second.v << endl;
//			ans += first.v + second.v;
//			tp = first.v + second.v;
//			Node next;
//			next.v = tp;
//			q.push(next);
//		}
//		else {
//			cout << ans << endl;
//			break;
//		}
//	}
//	system("pause");
//	return 0;
//}


//2996:选课
//#include <algorithm>
//#include <iostream>
//using namespace std;
//int main() {
//	int n, m;
//	cin >> n >> m;
//	int a[10001];
//	for (int j = 1; j <= n; j++) { cin >> a[j]; }
//	for (int k = m; k >= 1; k--) {
//		
//		if (!next_permutation(a + 1, a + n + 1)) {//没有下一个全排列了  回到最初的有序状态
//			
//			sort(a + 1, a + n + 1);
//		}
//		/*cout << k << endl;
//		for (int j = 1; j <= n; j++) {
//			cout << a[j] << ' ';
//		}
//		cout << endl << endl;*/
//	}
//	for (int j = 1; j <= n; j++) {
//		cout << a[j] << ' ';
//	}
//	system("pause");
//	return 0;
//}


//3148:付费道路
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//using namespace std;
//#define INF 0x3f3f3f3f
//const int maxn = 10 + 10;
//int vis[maxn];
//int min_cost, fee;
//int n, m;
//struct node
//{
//	int a, b, c, p, r;
//}road[maxn];
//void dfs(int x, int fee)
//{
//	if (x == n && min_cost > fee)
//	{
//		min_cost = fee;
//		return;
//	}
//	if (x == n)
//		return;
//	for (int i = 1; i <= m; i++)
//	{
//		//cout << road[i].a << " " << road[i].b << " " << vis[road[i].b] << " " << fee << endl;
//		if (road[i].a == x && vis[road[i].b] < 11)//3怎么算出来的参见网页 我自己改成8 也可以
//		{
//			vis[road[i].b]++;
//			if (vis[road[i].c])
//				dfs(road[i].b, fee + road[i].p);
//			else
//				dfs(road[i].b, fee + road[i].r);
//			vis[road[i].b]--;
//		}
//	}
//}
//
//int main()
//{
//	while (cin >> n >> m)
//	{
//		memset(vis, 0, sizeof(vis));
//		min_cost = INF;
//		for (int i = 1; i <= m; i++)
//		{
//			scanf_s("%d%d%d%d%d", &road[i].a, &road[i].b, &road[i].c, &road[i].p, &road[i].r);
//		}
//		vis[1] = 1;
//		dfs(1, 0);
//		if (min_cost != INF)
//			printf("%d\n", min_cost);
//		else
//			printf("impossible\n");
//	}
//	return 0;
//}

//3175:验证极限
//#include <algorithm>
//#include <iomanip>
//#include <cmath>
//#include <string>
//#include <iostream>
//using namespace std;
//int main() {
//	double x, a, e; int n = 0;
//	cin >> x >> a >> e;
//	if (x == 0) { cout << 0 << endl; }
//	else {
//		double res = abs(x / e);
//		while (abs(pow(a, n)) <= res) {
//			n++;
//		}
//		cout << n - 1 << endl;
//	}
//	return 0;
//}

//3224:转义字符显示
//#include <cstdlib>
//#include <iostream>
//#include <iomanip>
//#include <vector>
//#include <algorithm>
//#include <cstring>
//#include <cmath>
//#include <stdio.h>
//using namespace std;
//
//int main(int argc, char *argv[])
//{
//	char a[30];
//	int i, n;
//	cin.getline(a, 30);
//	n = strlen(a);
//	cout << a << endl;
//	for (i = 0; i<n; i++)
//	{
//		if (a[i] == ' ' || a[i] == '\t')
//		{
//			cout << "\\t";
//			while (a[i] == ' ' || a[i] == '\t')//有多个空格或者制表符 只显示一个制表符
//				i++;
//			i--;
//		}
//		else cout << a[i];
//	}
//	cout << endl;
//	system("PAUSE");
//	return EXIT_SUCCESS;
//}

//3238:生日相同 网上答案 不太懂
//#include <iostream>
//#include <string> 
//using namespace std;
//typedef class Student {
//public: string name;
//		int month;
//		int day;
//}Student;
////global variables
//const int N = 100;
//Student stu[N];
//int stu_n;
////functions
//void bubblesort();
//void print();
////sort 
//void bubblesort() {
//	int i, j, flag;
//	Student temp;
//	for (i = 0; i < stu_n; i++) {
//		flag = 1;
//		for (j = 0; j < stu_n - i - 1; j++) {
//			if (stu[j].month > stu[j + 1].month) {
//				temp = stu[j];
//				stu[j] = stu[j + 1];
//				stu[j + 1] = temp;
//				flag = 0;
//			}
//			else if (stu[j].month == stu[j + 1].month && stu[j].day > stu[j + 1].day) {
//				temp = stu[j];
//				stu[j] = stu[j + 1];
//				stu[j + 1] = temp; flag = 0;
//			}
//		}
//		if (flag) {
//			break;
//		}
//	}
//}
////print 
//void print() {
//	int i, flag;
//	flag = 0;
//	for (i = 1; i < stu_n; i++) {
//		if (stu[i].month == stu[i - 1].month && stu[i].day == stu[i - 1].day) {
//			if (flag == 0) {
//				std::cout << stu[i].month << " " << stu[i].day << " " << stu[i - 1].name << " " << stu[i].name; flag = 1;
//			}
//			else {
//				std::cout << " " << stu[i].name;
//			}
//		}
//		else {
//			if (flag) {
//				std::cout << std::endl;
//			} flag = 0;
//		}
//	}
//}
//int main() {
//	int i;
//	std::cin >> stu_n;
//	for (i = 0; i < stu_n; i++) {
//		std::cin >> stu[i].name >> stu[i].month >> stu[i].day;
//	}
//	//sort
//	bubblesort();
//	//print
//	print();
//	return 0;
//}

//3238:生日相同
//#include<iostream>
//#include<string>
//#include<algorithm>
//#include<vector>
//using namespace std;
//struct Node
//{
//	string id;
//	int m, d;
//
//};
//Node per[100];
//bool cp(const Node &a, const Node &b) {
//	if (a.m == b.m) {
//		return a.d < b.d;
//	}
//	else {
//		return a.m < b.m;
//	}
//
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> per[i].id >> per[i].m >> per[i].d;
//	}
//	stable_sort(per, per + n, cp);
//	/*for (int i = 0; i < n; i++) {
//		cout << per[i].id << " " << per[i].m << " " << per[i].d << endl;;
//	}*/
//	per[n].id = "00000000";
//	per[n].m = 13;
//	per[n].d = 13;
//	for (int i = 0; i < n; i++) {
//		vector<Node> v;
//		v.push_back(per[i]);
//		while (per[i].m == per[i + 1].m&&per[i].d == per[i + 1].d) {
//			v.push_back(per[i + 1]);
//			i++;
//		}
//		if (v.size() != 1) {
//			cout << per[i].m << " " << per[i].d ;
//			for (auto itr = v.begin(); itr != v.end(); itr++) {
//				cout << " " << itr->id ;
//			}
//			cout << endl;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}


//3245:空调排名
//#include<iostream>
//using namespace std;
//int main() {
//	cout << 5 << " " << 2 << " " << 1 << " " << 3 << " " << 4 << endl;
//	system("pause");
//	return 0;
//}

//3246:展览会
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 2020;
//struct period
//{
//	int s, e;
//};
//period p[maxn];
//int m[maxn];
//int main() {
//	int n;
//	cin >> n;
//	memset(m, 0, sizeof(m));
//	for (int i = 0; i < n; i++) {
//		cin >> p[i].s ;
//	}
//	for (int i = 0; i < n; i++) {
//		cin>> p[i].e;
//	}
//	for (int i = 0; i < n; i++) {
//		for (int j = p[i].s; j < p[i].e; j++) {
//			m[j]++;
//		}
//	}
//	int mx = 0;
//	for (int i = 0; i < 2001; i++) {
//		//cout << i << " " << m[i] << endl;
//		mx = max(mx, m[i]);
//	}
//	cout << mx << endl;
//	system("pause");
//	return 0;
//}


//3251:最少费用
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int inf = 0x7fffffff;
//int main()
//{
//	int n;
//	int map[110][110];
//	int visit[110][110];
//	cin >> n;
//	for (int i = 0; i <= n + 1; i++)
//		for (int j = 0; j <= n + 1; j++)
//			map[i][j] = inf;
//	for (int i = 1; i <= n; i++)
//		for (int j = 1; j <= n; j++)
//			cin >> map[i][j];
//	for (int i = 0; i <= n + 1; i++)
//		for (int j = 0; j <= n; j++)
//			visit[i][j] = 1;
//	for (int i = 1; i <= n; i++)
//		for (int j = 1; j <= n; j++)
//			visit[i][j] = 0;
//	visit[1][1] = 1;
//	while (!visit[n][n])
//	{
//		for (int i = 1; i <= n; i++)
//			for (int j = 1; j <= n; j++)
//				if (visit[i - 1][j] == 1 && visit[i][j - 1] == 1 && !visit[i][j])
//				{
//					map[i][j] += min(map[i - 1][j], map[i][j - 1]);
//					visit[i][j] = 1;
//				}
//	}
//	cout << map[n][n] << endl;
//	return 0;
//}

//3252:最大正向匹配
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//int main() {
//	string start, end;
//	cin >> start >> end;
//	int lenstart = start.length();
//	int lenend = end.length();
//	int n;
//	cin >> n;
//	reverse(end.begin(), end.end());//这句话放外面 不然每次都要翻转一次 不对的
//	for (int cnt = 0; cnt < n; cnt++) {
//		string str;
//		cin >> str;
//		int ans_start = str.find(start);
//		string strbackup = str;
//		reverse(str.begin(), str.end());
//		
//		int tp_end = str.find(end);
//		for (int i = ans_start; i < strbackup.length() - tp_end; i++) {
//			cout << strbackup[i];
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}

//3259:求具有abcd=(ab+cd)<sup>2</sup>,abcdef=(abc+def)<sup>2</sup>性质的四位数或六位数
//#include<stdio.h>
//int main()
//{
//	int n;
//	scanf("%d", &n);
//	if (n == 4)//注意
//	{
//		printf("2025 3025 9801");
//	}
//	if (n == 6)
//	{
//		printf("494209 998001");
//	}
//	return 0;
//}

//3260:赛手查询
//#include<iostream>
//#include<map>
//#include<vector>
//#include<algorithm>
//using namespace std;
//const int maxn = 260;
//struct Person
//{
//	int id;
//	int score;
//};
//Person p[maxn];
//bool mycmp(Person a, Person b) {
//	return a.score > b.score;
//}
//int main() {
//	int n;
//	while (cin >> n) {
//		if (!n) {
//			break;
//		}
//		for (int i = 1; i <= n; i++) {
//			cin >> p[i].score;
//			p[i].id = i;
//		}
//		p[n + 1].id = n + 1;
//		p[n + 1].score = -1;
//		stable_sort(p + 1, p + n + 2, mycmp);//要保证排序的稳定性
//		/*for (int i = 1; i <= n + 1; i++) {
//			cout << p[i].id << " " << p[i].score << endl;
//		}*/
//		int r = 1;
//		map<int, vector<Person>> m;
//		for (int i = 1; i <= n; i++) {
//			int temp_score = p[i].score;
//			vector<Person> v;
//			v.push_back(p[i]);
//			int j = 1;
//			while (temp_score == p[i + j].score) {
//				v.push_back(p[i + j]);
//				j++;
//			}
//			m.insert(pair<int, vector<Person>>(r, v));
//			r = r + j;
//			i = i + j - 1;
//		}
//		/*for (auto itr = m.begin(); itr != m.end(); itr++) {
//			cout << itr->first << ":  ";
//			for (auto itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++) {
//				cout << itr2->id << " ";
//			}
//			cout << endl;
//		}*/
//
//		int tar;
//		cin >> tar;
//		if (m.find(tar) != m.end()) {
//			for (auto itr = m[tar].begin(); itr != m[tar].end(); itr++) {
//				cout << itr->id << " ";
//			}
//		}
//		else {
//			cout << 0;
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}



//3262:新数字三角形
//#include<iostream>
//#include<cmath>
//#include<algorithm>
//using namespace std;
//int main()
//{
//	int n, p, q;
//	int a[110][110];
//	while (true)
//	{
//		cin >> n;
//		if (n == 0)
//			break;
//		for (int i = 1; i <= n; i++)
//			for (int j = 1; j <= i; j++)
//				cin >> a[i][j];
//		cin >> p >> q;
//
//		for (int i = n - 1; i >= 1; i--)
//			for (int j = 1; j <= i; j++)
//			{
//				a[i][j] = max(a[i][j], a[i + 1][j]);
//				a[i][j] = max(a[i][j], a[i + 1][j + 1]);
//			}
//		cout << a[p][q] << endl;
//	}
//	return 0;
//}


//3437:沙漠国王
//#include <set>
//#include <map>
//#include <queue>
//#include <stack>
//#include <cmath>
//#include <bitset>
//#include <cstdio>
//#include <string>
//#include <vector>
//#include <cstdlib>
//#include <cstring>
//#include <iostream>
//#include <algorithm>
//using namespace std;
//
//typedef long long ll;
//typedef pair<ll, ll> pll;
//typedef pair<ll, int> pli;
//typedef pair<int, ll> pil;;
//typedef pair<int, int> pii;
//typedef unsigned long long ull;
//
//#define lson i<<1
//#define rson i<<1|1
//#define bug printf("*********\n");
//#define FIN freopen("D://code//in.txt", "r", stdin);
//#define debug(x) cout<<"["<<x<<"]" <<endl;
//#define IO ios::sync_with_stdio(false),cin.tie(0);
//
//const double eps = 1e-8;
//const int mod = 10007;
//const int maxn = 1000 + 7;
//const double pi = acos(-1);
//const int inf = 0x3f3f3f3f;
//const ll INF = 0x3f3f3f3f3f3f3f;
//
//int n, x, y, z;
//double ans;
//int vis[maxn];
//double mp[maxn][maxn], dis[maxn];
//
//struct node {
//	int x, y, z;
//}p[maxn];
//
//double dist(node& a, node& b) {
//	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
//}
//
//bool prime(double x) {
//	for (int i = 1; i <= n; i++) {
//		dis[i] = inf;
//		vis[i] = 0;
//	}
//	ans = 0;
//	dis[1] = 0;
//	for (int i = 1; ; i++) {
//		double mx = inf;
//		int t = -1;
//		for (int j = 1; j <= n; j++) {
//			if (!vis[j] & mx > dis[j]) {
//				mx = dis[j];
//				t = j;
//			}
//		}
//		if (t == -1) break;
//		ans += mx;
//		vis[t] = 1;
//		for (int j = 1; j <= n; j++) {
//			if (!vis[j] && dis[j] > fabs(p[t].z - p[j].z) - mp[t][j] * x) {
//				dis[j] = fabs(p[t].z - p[j].z) - mp[t][j] * x;
//			}
//		}
//	}
//	return ans >= 0;
//}
//
//int main() {
//	//FIN;
//	while (~scanf("%d", &n) && n) {
//		for (int i = 1; i <= n; i++) {
//			scanf("%d%d%d", &p[i].x, &p[i].y, &p[i].z);
//		}
//		for (int i = 1; i <= n; i++) {
//			for (int j = 1; j <= n; j++) {
//				mp[i][j] = dist(p[i], p[j]);
//			}
//		}
//		double ub = 100, lb = 0, mid;
//		while (ub - lb > eps) {
//			mid = (ub + lb) / 2;
//			if (prime(mid)) lb = mid;
//			else ub = mid;
//		}
//		printf("%.3f\n", lb);
//	}
//	return 0;
//}


//3453:雷涛的小猫
//#include<iostream>
//#include<cstring>
//#include<stdio.h> 
//using namespace std;
//
//int tree[2010][2010];
//int maxNum[2010];	//记录某高度所能得到的最大值 
//int N, H, delta;
//
//int main()
//{
//	memset(tree, 0, sizeof(tree));
//	memset(maxNum, 0, sizeof(maxNum));
//
//	scanf("%d%d%d", &N, &H, &delta);
//	for (int i = 1; i <= N; i++)
//	{
//		int m, l;
//		scanf("%d", &m);
//		for (int j = 1; j <= m; j++)
//		{
//			scanf("%d", &l);
//			tree[i][l]++;
//		}
//	}
//
//	for (int j = H; j >= 1; j--)
//	{
//		for (int i = 1; i <= N; i++)
//		{
//			int preNum = tree[i][j + 1];
//			if (j + delta <= H && maxNum[j + delta]>preNum)
//				preNum = maxNum[j + delta];
//
//			tree[i][j] += preNum;
//
//			if (tree[i][j]>maxNum[j])	//更新高度为j时的最大值
//				maxNum[j] = tree[i][j];
//		}
//	}
//
//	int ans = 0;
//	for (int i = 1; i <= N; i++)
//		if (tree[i][1]>ans)
//			ans = tree[i][1];
//
//	printf("%d\n", ans);
//	return 0;
//}

//3454:秦腾与教学评估
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//#include<cstdlib>
//#include<algorithm>
//#include<cmath>
//#define ll long long
//using namespace std;
//inline int read()
//{
//	int x = 0, f = 1; char ch = getchar();
//	while (ch<'0' || ch>'9') { if (ch == '-')f = -1; ch = getchar(); }
//	while (ch >= '0'&&ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
//	return x * f;
//}
//int T, n;
//int s[100005], e[100005], d[100005];
//int cal(int x)
//{
//	int sum = 0;
//	for (int i = 1; i <= n; i++) {
//		if (s[i] <= x) {
//			sum += (min(e[i], x) - s[i]) / d[i] + 1;
//			cout << x << " " << i << " " << sum << " " << (sum & 1) << endl;
//		}
//	}
//
//
//	return sum;
//}
//int main()
//{
//	T = read();
//	while (T--)
//	{
//		n = read();
//		for (int i = 1; i <= n; i++)
//		{
//			s[i] = read(); e[i] = read(); d[i] = read();
//		}
//		int ans = 0;
//		ll l = 0, r = 2147483647;
//		while (l <= r)
//		{
//			ll mid = (l + r) >> 1;
//			if (cal(mid) & 1)r = mid - 1, ans = mid;//前缀和为奇数  缩小范围  前缀和为偶数 扩大范围
//			else l = mid + 1;
//		}
//		if (!ans)puts("Poor QIN Teng:(");
//		else
//		{
//			printf("%d %d\n", ans, cal(ans) - cal(ans - 1));
//		}
//	}
//	system("pause");
//	return 0;
//}


//3470:整理扑克牌
//#include<iostream>
//#include<cstdio>
//#include<cmath>
//#include<cstdlib>
//#include<cstring>
//#include<string>
//#include<vector>
//#include<stack>
//#include<queue>
//#include<set>
//#include<map>
//#include<algorithm>
//using namespace std;
//typedef long long  ll;
//const int maxm = 1010;
//int b, num[55];
//bool ok(int x) {
//	int s = 0;
//	for (int i = 0; i < 54; ++i) {
//		cout << x << " " << i << " " 
//			<< num[i] << " " << s << " " << b << endl;
//		if (num[i] < s) return 0;//s表示还差几张特殊牌
//		s += max(0, x - num[i]);
//		if (s > b) return 0;
//	}
//	return 1;
//}
//int main() {
//	while (scanf_s("%d", &b) == 1) {
//		for (int i = 0; i < 54; ++i) scanf_s("%d", &num[i]);
//		sort(num, num + 54);
//		int  l = 0, r = 1000000000;
//		while (r - l > 1) {
//			int m = (r + l) >> 1;
//			if (ok(m)) l = m;
//			else r = m;
//		}
//		printf("%d\n", l);
//	}
//	system("pause");
//	return 0;
//}

//3471:子串计算
//#include <iostream>
//#include <string>
//#include <algorithm>
//#include<set>
//using namespace std;
//int main() {
//	string str;
//	cin >> str;
//	int len = (int)str.size();
//	multiset<string> ms;
//	set<string> s;
//	for (int i = 1; i <= len; i++) {
//		for (int q = 0; q <= len - i; q++) {
//			ms.insert(str.substr(q, i));
//			s.insert(str.substr(q, i));
//		}
//	}//记录下所有字串。
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		string temp = *itr;
//		int cnt = ms.count(temp);
//		if (cnt > 1) {
//			cout << *itr << " " << cnt << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}


//3472:基因串
//#include <iostream>
//
//using namespace std;
//
//int dp[100][100][26];
//int ans[100][100];//从i到j的子串至少由几个S推导得出
//char target[100];
//char str[50][3];
//
//int main()
//{
//	int n;
//	cin >> n;
//
//	for (int i = 0; i < n; ++i)
//	{
//		cin >> str[i][0] >> str[i][1] >> str[i][2];
//	}
//
//	int len = 0;
//	cin >> target;
//	len = strlen(target);
//
//	int i, j, k, r, ns, ss;
//	for (i = 0; i < len; i++)
//	{
//		for (ss = 0; ss < 26; ss++)
//		{
//			if (target[i] == 'A' + ss)
//			{
//				dp[i][i][ss] = 1;
//			}
//			else
//			{
//				dp[i][i][ss] = 0;
//			}
//			//cout << i << " " << m[i][i][ss] << endl;
//		}
//		if (target[i] == 'S') ans[i][i] = 1;
//		else ans[i][i] = 0;
//	}
//
//	for (r = 1; r <= len; ++r)
//	{
//		for (i = 0; i < len - r; ++i)
//		{
//			j = i + r;
//			for (ss = 0; ss < 26; ss++) {
//				dp[i][j][ss] = 0;
//				//cout << i << ' ' << j << " " << ss << " " << dp[i][j][ss] << endl;
//			}
//			for (k = i; k < j; k++)
//			{
//				for (ss = 0; ss < 26; ss++)
//				{
//					for (ns = 0; ns < n; ++ns)
//					{
//						cout << "hhh " << i << " " << k << ' ' << j << " "
//							<< ss << " " << ns << " " << str[ns][0] << endl;
//						if (str[ns][0] == 'A' + ss)
//						{
//							int left = str[ns][1] - 'A';
//							int right = str[ns][2] - 'A';
//							int temp = dp[i][k][left] & dp[k + 1][j][right];
//							dp[i][j][ss] = dp[i][j][ss] > temp ? dp[i][j][ss] : temp;
//							cout << "xxx " << i << " " << k << ' ' << j << " " << ss << " "
//								<< ns << " " << str[ns][0] << " "
//								<< left << " " << right << " " << temp
//								<< " " << dp[i][j][ss] << endl;
//						}
//
//					}
//				}
//			}
//
//			ans[i][j] = 0;
//			if (dp[i][j][18]) ans[i][j] = 1;
//			else
//			{
//				int temp = 101;
//				for (k = i; k < j; ++k)
//				{
//					if (ans[i][k] && ans[k + 1][j])
//					{
//						int tt = ans[i][k] + ans[k + 1][j];
//						temp = temp < tt ? temp : tt;
//					}
//				}
//				if (temp != 101) ans[i][j] = temp;
//			}
//		}
//	}
//
//	if (ans[0][len - 1] == 0)
//		cout << -1;
//	else
//		cout << ans[0][len - 1];
//	system("pause");
//	return 0;
//}

//3703:寻找平面上的极大点
//#include<iostream>
//#include<algorithm>
//#include<stack>
//using namespace std;
//typedef struct Node
//{
//	int x, y;
//}Node;
//Node point[105];
//stack<Node> s;
//int cmp(Node a, Node b)//先安x值由大到小顺序排序，再按照y值从大到小排序
//{
//	if (a.x > b.x) { return 1; }
//	else if (a.x == b.x)
//	{
//		if (a.y > b.y) { return 1; }
//		else { return 0; }
//	}
//	else { return 0; }
//}
//int n;
//int main()
//{
//	cin >> n;
//	for (int i = 0; i < n; i++)
//	{
//		cin >> point[i].x >> point[i].y;
//	}
//	sort(point, point + n, cmp);
//	for (int i = 0; i < n; i++)
//	{
//		int FLAG = 0;//没有能覆盖它的点，这个值为0
//		int a = point[i].x;
//		int b = point[i].y;
//		for (int j = 0; j < i; j++)//从以前的点中，寻找可能覆盖point[i]的点
//		{
//			if (point[j].x >= a && point[j].y >= b)
//			{
//				FLAG = 1;//找到了能覆盖point[i]的点
//				break;//退出寻找过程
//			}
//		}
//		if (FLAG == 1) { continue; }//找到了覆盖point[i]的点，跳出循环
//		else//真主说：point[i]确实是极大值点了 
//		{
//			s.push(point[i]);//加入栈顶
//		}
//	}
//	if (s.size() == 1)
//	{
//		cout << "(" << s.top().x << "," << s.top().y << ")";
//	}
//	else
//	{
//		cout << "(" << s.top().x << "," << s.top().y << ")";
//		s.pop();
//		while (!s.empty())
//		{
//
//			cout << "," << "(" << s.top().x << "," << s.top().y << ")";
//			s.pop();
//		}
//	}
//
//	system("pause");
//	return 0;
//}


//3704:扩号匹配问题
//#include<iostream>
//#include<stack>
//#include<string>
//#include<cstring>
//using namespace std;
//char a[101];
//int main()
//{
//	stack<int>s;
//	string str;
//	while (cin >> str) {
//		memset(a, ' ', 100);
//		for (int i = 0; i < str.size(); ++i)
//		{
//			if (str[i] == '(')s.push(i);
//			if (str[i] == ')')
//			{
//				if (s.empty())
//				{
//					a[i] = '?';
//				}
//				else
//				{
//					s.pop();
//				}
//			}
//		}
//		while (!s.empty())
//		{
//			a[s.top()] = '$';
//			s.pop();
//		}
//		cout << str << endl;
//		cout << a << endl;
//	}
//	return 0;
//}

//3714:点菜问题
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//int cost[110];
//int value[110];
//int dp[110][1010];
//int main() {
//	int tot;
//	int n;
//	while(cin >> tot >> n) {
//		memset(cost, 0, sizeof(cost));
//		memset(value, 0, sizeof(value));
//		memset(dp, 0, sizeof(dp));
//		for (int i = 1; i <= n; i++) {
//			cin >> cost[i] >> value[i];
//		}
//		for (int i = 1; i <= n; i++) {
//			for (int j = tot; j >= 0; j--) {
//				if (j >= cost[i]) {
//					dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i]] + value[i]);
//				}
//				else {
//					dp[i][j] = dp[i - 1][j];
//				}
//				//cout << i << " " << j << " " << dp[i][j] << endl;
//			}
//		}
//		cout << dp[n][tot] << endl;
//	}
//	
//	system("pause");
//	return 0;
//}


//3715:计算工作天数
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<string>
//using namespace std;
//const int mon_d[13][2] = {
//	0,0,
//	31,31,
//	28,29,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31,
//	31,31,
//	30,30,
//	31,31,
//	30,30,
//	31,31
//};
//int isRun(int x) {
//	if ((x % 4 == 0 && x % 100 != 0) || (x % 400 == 0)) {
//		return 1;
//	}
//	return 0;
//}
//
//struct Node
//{
//	string name;
//	int p;
//};
//Node person[100000];
//bool mycmp(Node a, Node b) {
//	return a.p > b.p;
//}
//int main() {
//	int n;
//	cin >> n;
//	int y2, y1, m2, m1, d2, d1;
//	for (int i = 0; i < n; i++) {
//		cin >> person[i].name >> y1 >> m1 >> d1 >> y2 >> m2 >> d2;
//		int cnt = 0;
//		while (y1 < y2 || m1 < m2 || d1 < d2) {
//			d1++;
//			//cout << y1 << " " << m1 << " " << d1 << " " << mon_d[m1][isRun(y1)] << " " << cnt << endl;
//
//			if (d1 > mon_d[m1][isRun(y1)]) {
//				d1 = 1;
//				m1++;
//			}
//			if (m1 > 12) {
//				m1 = 1;
//				y1++;
//			}
//			cnt++;
//		}
//		person[i].p = cnt + 1;
//	}
//	stable_sort(person, person + n, mycmp);
//	for (int i = 0; i < n; i++) {
//		cout << person[i].name << " " << person[i].p << endl;
//	}
//	system("pause");
//	return 0;
//}


//3722:因子问题
//#include <iostream>
//using namespace std;
//int main() {
//
//	int x, y; cin >> x >> y;
//	bool suc = 0;
//	int sum = 0;
//	for (int a = 1; a <= y; a++) {
//		if (x%a == 0 && x % (y - a) == 0) {
//			suc = 1;
//			sum = a;
//			break;
//		}
//	}
//	if (suc) cout << sum << endl;
//	else cout << "-1" << endl;
//
//	return 0;
//}

//3725:集合问题  网上答案1  没看懂
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//#include<queue>
//#include<cmath>
//using namespace std;
//struct Node
//{
//	int x;
//	bool operator<(const Node & a)const
//	{
//		return a.x < x;
//	}
//};
//priority_queue<Node> data_inorder;//大根堆 维护元素集合
//priority_queue<int> suma;//小根堆 维护sum(A);
//int n, i, j, k, maxn, num = 2100000000, num1;
//int a[1100];
//int main()
//{
//	scanf("%d", &n);
//	for (i = 1; i <= n; i++)
//	{
//		scanf("%d", &a[i]);
//	}
//	for (i = 1; i <= n; i++)
//	{
//		for (j = 1; j <= n; j++)
//			suma.push(a[j]);
//		maxn = suma.top();
//		for (j = 1; j <= i; j++)
//		{
//			int x1 = suma.top();
//			suma.pop();
//			Node m;
//			m.x = x1;
//			data_inorder.push(m);
//		}
//		for (j = i + 1; j <= n; j++)
//		{
//			Node x1 = data_inorder.top();
//			data_inorder.pop();
//			Node y1;
//			y1.x = x1.x + suma.top();
//			suma.pop();
//			data_inorder.push(y1);
//		}
//		int ans = 0;
//		for (j = 1; j <= i; j++)
//		{
//			Node m = data_inorder.top();
//			ans += abs(m.x - maxn);
//			data_inorder.pop();
//		}
//		if (ans < num)
//		{
//			num = ans;
//			num1 = i;
//		}
//	}
//	cout << num1;
//}
////用一个大根堆维护元素集合，用一个小根堆维护sum(A);

//3725:集合问题  不懂
//#include<cstdio>
//#include<algorithm>
//#include<queue>
//#include<iostream>
//#include<cmath>
//using namespace std;
//int n, a[1010], minn = 0X7fffffff, ans = 0;
//bool flag;
//priority_queue <int, vector<int>, greater<int> > q;
//inline int comp(int x, int y)
//{
//	return x > y;
//}
//int main()
//{
//	cin >> n;
//	for (int i = 1; i <= n; i++)
//		cin >> a[i];
//	sort(a + 1, a + n + 1, comp);
//	for (int i = 1; i <= n; i++)//遍历集合的个数
//	{
//		int total = 0;
//		for (int j = 1; j <= i; j++)//控制前i-1个元素不取  因为分成了i个集合 要确保每个集合都有一个数
//			q.push(0);
//
//		for (int j = 1; j <= n; j++)//得到所有元素的总和 此时q队列里面只有总和
//		{
//			int k = q.top();
//			q.pop();
//			cout <<"hhh "<< i << " " << j << " " << k << " " << k + a[j] << endl;
//			q.push(k + a[j]);
//		}
//		cout << q.top() << endl;
//		/*while (!q.empty()) {
//			int tp = q.top();
//			q.pop();
//			cout << tp << endl;
//		}*/
//		for (int j = 1; j <= i; j++) {
//			total += abs(a[1] - q.top());
//			cout << i << " " << j << " " << q.top() << " "
//				<< abs(a[1] - q.top()) << " "
//				<< total << endl;
//			q.pop();
//		}
//			
//		if (minn >= total)
//			ans = i, minn = total;
//		else if (!flag)
//			flag = 1;
//		else break;//一步小优化，不加也能过，加了能快一些，自己感受一下
//	}
//	system("pause");
//	printf("%d", ans);
//}


//3753:反转诗句
//#include<iostream>
//#include<sstream>
//#include<string>
//#include<stack>
//using namespace std;
//int main() {
//	string str;
//	while (getline(cin, str)) {
//		stack<string> st;
//		stringstream ss(str);
//		string tp;
//		while (ss >> tp) {
//			st.push(tp);
//		}
//		while (!st.empty()) {
//			cout << st.top()<<" ";
//			st.pop();
//		}
//		cout << endl;
//	}
//}


//4006:小兔子捡金币
//#include<cstdio>
//#include<cstring>
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int u[4] = { 0,1,0,-1 };
//int v[4] = { 1,0,-1,0 };
//int c[10100];//记录每一层的起点 
//int main()
//{
//	int k, n;
//	scanf_s("%d%d", &k, &n);
//	c[1] = 1;
//	for (int j = 1, i = 1; i <= n / 2; j += 2, i++)
//	{
//		c[i + 1] = c[i] + 4 * (n - j);//按照规律预处理每一层的起点 
//		cout << "hhh " << i << " " << c[i] << endl;							  //  printf("%d",c[i+1]);
//	}
//	//  printf("\n");
//	for (int i = 1; i <= k; i++)
//	{
//		int a, b, aa, bb;
//		scanf_s("%d%d", &a, &b);
//		aa = a, bb = b;
//		if (aa > n / 2) aa = n - aa + 1;
//		if (bb > n / 2) bb = n - bb + 1;
//		cout << aa << " " << bb << endl;
//		int q = min(aa, bb);//找坐标值较小的是它所在的层数 
//		int x = q, y = q, start = c[q], fx = 0;
//		while (start < c[q + 1])//从这一层找到下一层 
//		{
//			if (x == a && y == b) break;//找到坐标就退出 
//			int xx = x + u[fx];
//			int yy = y + v[fx];//向右模拟 
//			if (xx >= q && yy >= q && xx <= n - q + 1 && yy <= n - q + 1)
//			{
//				x = xx, y = yy;
//				start++;//能走就走 
//			}
//			else//转一下弯继续走 
//			{
//				fx++;
//				if (fx >= 4) fx = 0;
//			}
//		}
//		printf("%d\n", start);//输出序号 
//	}
//	system("pause");
//	return 0;
//}

//4015:邮箱验证
//#include<iostream>
//#include<string>
//using namespace std;
//int main() {
//	string str;
//	while (cin >> str) {
//		int suc = 1;
//		int len = str.length();
//		if (str[0] == '@' || str[0] == '.' || str[len - 1] == '@' || str[len - 1] == '.') {
//			suc = 0;
//		}
//		int cnt_at = 0;
//		int cnt_dot = 0;
//		for (int i = 1; i < len - 1; i++) {
//			if (str[i] == '@') {
//				cnt_at++;
//				if (str[i - 1] == '.' || str[i + 1] == '.') {
//					suc = 0;
//				}
//				for (int j = i + 1; j < len; j++) {
//					if (str[j] == '.') {
//						cnt_dot++;
//					}
//				}
//			}
//			
//		}
//		if (cnt_at != 1) {
//			suc = 0;
//		}
//		if (cnt_dot == 0) {
//			suc = 0;
//		}
//		if (suc == 1) {
//			cout << "YES" << endl;
//		}
//		else {
//			cout << "NO" << endl;
//		}
//	}
//	system("pause");
//	return 0;
//}

//4019:黑色星期五
//#include<iostream>
//using namespace std;
//int month[13] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 };
//int main() {
//	int w;
//	cin >> w;
//	for (int i = 1; i <= 12; i++) {
//		int now = (w - 1 + 13) % 7;
//		if (now == 5) {
//			cout << i << endl;
//		}
//		w = (w + month[i]) % 7;//这里w不用-1
//	}
//	system("pause");
//	return 0;
//}


//4020:缺少的扑克牌
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//#include<memory>
//#include<cmath>
//#include <cstdlib>
//using namespace std;
//
//char a[54][20] = { "ClubQueen","Club2","ClubAce","SpadeAce","Club10","Heart2","HeartJack","Heart6","Heart4","Spade6","Diamond6","Spade7","Heart7","Spade10","DiamondJack","SpadeKing","Heart10","Spade2","Spade9","Diamond5","Club9",
//"Spade8","DiamondAce","Heart9","Heart5","Club8","Club7","ClubKing","Club6","Club5","Club3","SpadeQueen","Spade3","HeartAce","SpadeJack","Joker","DiamondQueen","Club4","Spade4","Diamond4","HeartQueen",
//"HeartKing","Diamond2","Diamond10","DiamondKing","Diamond3","Heart3","Diamond7","Diamond8","Spade5","ClubJack","Heart8","Diamond9","joker" };
//
//int c[54];
//
//char b[53][20];
//
//int main()
//{
//	int n;
//	cin >> n;
//	for (int l = 0; l<n; l++)
//	{
//		memset(c, 0, sizeof(c));
//		for (int i = 0; i<53; i++)
//		{
//			cin >> b[i];
//			for (int j = 0; j<54; j++)
//				if (strcmp(a[j], b[i]) == 0)
//				{
//					c[j] = 1;
//					break;
//				}
//		}
//		for (int k = 0; k<54; k++)
//			if (c[k] == 0)
//				cout << a[k] << endl;
//	}
//	//fclose(fp);
//	return 0;
//}



//4021:最大乘积
//#include <iostream>
//#include <algorithm>
//using namespace std;
//int main() {
//	int o; cin >> o; while (o--) {
//		int n; cin >> n;
//		int p[100], q[100];
//		for (int i = 0; i < n; i++) {
//			cin >> q[i];
//		}
//		for (int i = 0; i < n; i++) {
//			p[i] = q[i];
//		}
//		int negtive = 0; int zero = 0;
//		sort(p, p + n);
//		for (int i = 0; i < n; i++) {
//			if (p[i] < 0) negtive++;
//			if (p[i] == 0) zero++;
//		}
//		//先考虑积是正数的情况，1.全是正的 2.有正有负 3.全是负数；
//
//		//全是正数的情况；
//		if (negtive == 0 && zero == 0)
//			cout << p[0] << endl;
//		//有正有负 找正数里最小的；
//		else if (zero == 0 && negtive % 2 == 0 && negtive != n) {
//			for (int j = 0; j < n; j++) {
//				if (p[j] > 0) {
//					cout << p[j] << endl;
//					break;
//				}
//			}
//		}
//		//全是负数
//		else if (negtive == n && n % 2 == 0) {
//			cout << p[0] << endl;
//		}
//		//在考虑积是负数的情况，只需要去掉绝对值最小的负数；
//		else if (zero == 0 && negtive % 2 == 1) {
//			int max = -10000000;
//			for (int j = 0; j < n; j++) {
//				if (p[j]<0 && p[j]>max)
//					max = p[j];
//			}
//			cout << max << endl;
//		}
//		//考虑若积为零，且不仅仅有一个0，只需输出第一个元素；
//		else if (zero > 1) cout << q[0] << endl;
//		//若积为0，且只有1个0，1.除去0积是正数，那么除去0；
//		else if (zero == 1 && negtive % 2 == 0) cout << '0' << endl;
//		//2.除去0积是负数，除去第一个不是0的数；
//		else if (zero == 1 && negtive % 2 == 1) {
//			if (q[0] == 0) cout << q[1] << endl;
//			else cout << q[0] << endl;
//		}
//	}
//	return 0;
//}


//4029:数字反转
//#include<iostream>
//#include<string>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//int main() {
//	int x;
//	cin >> x;
//	int nag = 0;
//	if (x < 0) {
//		x = -x;
//		nag = 1;
//	}
//	stringstream ss;
//	string str;
//	ss << x;
//	ss >> str;
//	reverse(str.begin(), str.end());
//	stringstream ss2;
//	int res;
//	ss2 << str;
//	ss2 >> res;
//	if (nag) {
//		cout << "-";
//	}
//	cout << res << endl;
//	system("pause");
//	return 0;
//}


//4031:瑞士轮
//#include<stdio.h>
//#include<stdlib.h>
//#include<iostream>
//using namespace std;
//struct person
//{
//	int ID, score, ability;//选手编号、分值、实力值 
//};
//int cmp(const void *a, const void *b)
//{
//	struct person *x, *y;
//	x = (struct person*)a;
//	y = (struct person*)b;
//	if (x->score > y->score) return -1;
//	else if (x->score < y->score) return 1;
//	else
//	{
//		if (x->ID > y->ID) return 1;
//		else return 0;
//	}
//}
//int main()
//{
//	int N, R, Q;
//	struct person *a = NULL, *suc = NULL, *unsuc = NULL;
//	int i, j, NN, cnt_suc, cnt_unsuc, itr_suc, itr_unsuc;
//
//	scanf_s("%d%d%d", &N, &R, &Q);
//	NN = 2 * N;
//	a = (struct person *)malloc(sizeof(struct person)*NN);
//	suc = (struct person *)malloc(sizeof(struct person)*NN);
//	unsuc = (struct person *)malloc(sizeof(struct person)*NN);
//
//	for (i = 0; i < NN; i++)
//	{
//		a[i].ID = i + 1;
//		scanf_s("%d", &a[i].score);
//	}
//	for (i = 0; i < NN; i++)
//		scanf_s("%d", &a[i].ability);
//	qsort(a, NN, sizeof(a[0]), cmp);
//
//	for (i = 0; i < R; i++)
//	{
//		cnt_suc = cnt_unsuc = 0;
//		for (j = 0; j < NN; j = j + 2)//模拟一轮比赛 
//		{
//			if (a[j].ability > a[j + 1].ability) {
//				a[j].score++;
//				suc[cnt_suc++] = a[j];
//				unsuc[cnt_unsuc++] = a[j + 1];
//			}
//			else if (a[j].ability < a[j + 1].ability) {
//				a[j + 1].score++;
//				suc[cnt_suc++] = a[j + 1];
//				unsuc[cnt_unsuc++] = a[j];
//			}
//			else {
//				unsuc[cnt_unsuc++] = a[j];
//				unsuc[cnt_unsuc++] = a[j + 1];
//			}
//		}
//		cout << cnt_suc << " " << cnt_unsuc << endl;
//		itr_suc = itr_unsuc = 0;
//		for (j = 0; itr_suc < cnt_suc || itr_unsuc < cnt_unsuc; j++)//一轮比赛完成以后，做一次归并操作使得a[]按积分降序排序 
//		{
//			if (itr_unsuc >= cnt_unsuc ||
//				(itr_suc < cnt_suc&&suc[itr_suc].score > unsuc[itr_unsuc].score) ||
//				(itr_suc < cnt_suc&&suc[itr_suc].score == unsuc[itr_unsuc].score && suc[itr_suc].ID < unsuc[itr_unsuc].ID))
//			{
//				a[j] = suc[itr_suc++];
//			}
//			else a[j] = unsuc[itr_unsuc++];
//		}
//	}
//	printf("%d\n", a[Q - 1].ID);
//	free(a);
//	system("pause");
//	return 0;
//}



//4035:Mayan 游戏
//#include<stdio.h>
//#include<cstdlib>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int n, Num[15], m[6][8], Ans[6][3];
//bool Remove(int mp[6][8]) //清除。
//{
//	bool Flag(0), tp[6][8] = { 0 };
//	for (int a = 1; a <= 5; a++)
//		for (int b = 1; b <= 7; b++)
//			if (mp[a][b])
//			{
//				if (a <= 3 && mp[a][b] == mp[a + 1][b] && mp[a + 1][b] == mp[a + 2][b])
//					tp[a][b] = tp[a + 1][b] = tp[a + 2][b] = true;
//				if (b <= 5 && mp[a][b] == mp[a][b + 1] && mp[a][b + 1] == mp[a][b + 2])
//					tp[a][b] = tp[a][b + 1] = tp[a][b + 2] = true;
//			}
//	for (int a = 1; a <= 5; a++)
//		for (int b = 1; b <= 7; b++)
//			if (tp[a][b]) //值得学习，本次清除过格子。
//			{
//				mp[a][b] = 0;
//				Flag = true;
//			}
//	return Flag;
//}
//void Falldown(int i[6][8]) //下落。
//{
//	for (int a = 1; a <= 5; a++) //直接类似于重建图，进行填补。
//	{
//		int t(0);
//		for (int b = 1; b <= 7; b++)
//		{
//			int T = i[a][b];
//			i[a][b] = 0;
//			if (T)
//				i[a][++t] = T;
//		}
//	}
//}
//bool Check(int i[6][8]) //检验。
//{
//	for (int a = 1; a <= 5; a++)
//		for (int b = 1; b <= 7; b++)
//			if (i[a][b])
//				return false;
//	return true;
//}
//void DFS(int step, int mp[6][8]) //深搜。
//{
//	if (step > n) //步数超过限制。
//	{
//		if (Check(mp))
//		{
//			for (int a = 1; a <= n; a++)
//				if (Ans[a][2]) //判断左移右移。
//					printf("%d %d -1\n", Ans[a][0], Ans[a][1] - 1);
//				else
//					printf("%d %d 1\n", Ans[a][0] - 1, Ans[a][1] - 1);
//			exit(0);
//		}
//		return;
//	}
//	memset(Num, 0, sizeof(Num)); //存储某种颜色格子现存数。
//	for (int a = 1; a <= 5; a++)
//		for (int b = 1; b <= 7; b++)
//			if (mp[a][b])
//				Num[mp[a][b]]++;
//	for (int a = 1; a <= 10; a++)
//		if (Num[a] == 1 || Num[a] == 2) //注意，当等于0时并不需要返回。
//			return;
//	int tp[6][8] = { 0 }; //小白鼠数组。
//	for (int a = 1; a < 5; a++)
//		for (int b = 1; b <= 7; b++)
//			if (mp[a][b] != mp[a + 1][b]) //颜色不一样，交换才有价值，注意是比较的左列，但依然能实现左右移动。
//			{
//				memcpy(tp, mp, sizeof(tp));
//				Ans[step][0] = a;//x坐标
//				Ans[step][1] = b;//y坐标
//				Ans[step][2] = !mp[a][b]; //若为空，即是true，左移，若为有，即是false。
//				swap(tp[a][b], tp[a + 1][b]); //交换。
//				Falldown(tp);
//				while (Remove(tp)) //不断消除。
//					Falldown(tp);
//				DFS(step + 1, tp);
//			}
//}
//int main() //赤裸裸的深搜，考验编程能力。
//{
//	scanf("%d", &n);
//	for (int a = 1; a <= 5; a++)
//		for (int b = 1;; b++)
//		{
//			scanf("%d", &m[a][b]); //注意i代表第几列，j代表第几行。
//			if (!m[a][b]) //存储颜色。
//				break;
//		}
//	DFS(1, m);
//	printf("-1");
//	return 0;
//}



//4041:矩阵运算
//#include <iostream>
//#include <iomanip>
//using namespace std;
//int main() {
//	int m1, n1, m2, n2;
//	int a[200][200]; int b[200][200];
//	cin >> m1 >> n1;
//	for (int j = 1; j <= m1; j++) {
//		for (int i = 1; i <= n1; i++) {
//			cin >> a[j][i];
//		}
//	}
//	cin >> m2 >> n2;
//	for (int j = 1; j <= m2; j++) {
//		for (int i = 1; i <= n2; i++) {
//			cin >> b[j][i];
//		}
//	}
//	int c[200][200];
//	if (n1 == m2) {
//		for (int j = 1; j <= m1; j++) {
//			for (int i = 1; i <= n2; i++) {
//				c[i][j] = 0;
//			}
//		}
//		int d[200][200];
//		for (int i = 1; i <= m1; i++) {
//			for (int j = 1; j <= n2; j++) {
//				for (int k = 1; k <= n1; k++) {
//					c[i][j] += a[i][k] * b[k][j];
//				}
//			}
//		}
//		for (int i = 1; i <= n2; i++) {
//			for (int j = 1; j <= m1; j++) {
//				d[i][j] = c[j][i];
//			}
//		}
//		for (int i = 1; i <= n2; i++) {
//			for (int j = 1; j <= m1; j++) {
//				cout << setw(5) << d[i][j];
//			}cout << endl;
//		}
//	}
//	else {
//		int c[200][200];
//		for (int i = 1; i <= n1; i++) {
//			for (int j = 1; j <= m1; j++) {
//				c[i][j] = a[j][i];
//			}
//		}
//		for (int i = 1; i <= n1; i++) {
//			for (int j = 1; j <= m1; j++) {
//				cout << setw(5) << c[i][j];
//			}cout << endl;
//		}
//	}
//	return 0;
//}

//4042:Rabin-Karp字符串匹配
//#include<stdio.h>
//#include<iostream>
//#include<string>
//using namespace std;
//#define N 100
//int main()
//{
//	int count, tar_len, tar, str_len;
//	int i, j, sum;
//	int k = 0;
//	char str[N];
//	int flag[N];
//	cin >> count;
//	while (count > 0)
//	{
//		cin >> str;
//		cin >> tar_len;
//		cin >> tar;
//		str_len = strlen(str);
//		sum = 0;
//		k = 0;
//		for (i = 0; i < str_len; i++)
//		{
//			for (j = i; j < i + tar_len; j++) {
//				sum = sum + (int)str[j] - 96;
//			}
//			if (sum == tar) {
//				flag[k] = i;
//				k++;
//			}
//			sum = 0;
//		}
//		printf("%d\n", k);
//		for (i = 0; i < k; i++)
//		{
//			for (j = flag[i]; j < flag[i] + tar_len; j++)
//				printf("%c", str[j]);
//			printf("\n");
//		}
//		count--;
//	}
//	system("pause");
//	return 0;
//}

//4043:GPA排名系统
//#include <iostream>
//#include <string>
//#include <memory.h>
//using namespace std;
//const int MAX_STU = 20;
//const int MAX_SUB = 10;
//int main()
//{
//	int m, n;
//	int grade[MAX_STU][MAX_SUB];
//	int allaverage[MAX_SUB], subaverage[MAX_SUB];
//	int studentnum[MAX_SUB];
//	string subject[MAX_SUB];
//	memset(subaverage, 0, sizeof(subaverage));
//	memset(allaverage, 0, sizeof(allaverage));
//	memset(studentnum, 0, sizeof(studentnum));
//	cin >> m >> n;
//	for (int i = 0; i != n; ++i)
//	{
//		cin >> subject[i];
//	}
//	for (int i = 0; i != m; ++i)
//	{
//		for (int j = 0; j != n; ++j)
//		{
//			cin >> grade[i][j];
//			if (grade[i][j] != 0)
//			{
//				studentnum[j]++;
//				subaverage[j] += grade[i][j];
//			}
//		}
//	}
//	for (int i = 0; i != n; ++i)
//	{
//		subaverage[i] /= studentnum[i];
//		studentnum[i] = 0;
//		for (int j = 0; j != m; ++j)
//		{
//			if (grade[j][i] != 0)
//			{
//				for (int k = 0; k != n; ++k)
//				{
//					if (grade[j][k] != 0)
//					{
//						allaverage[i] += grade[j][k];
//						studentnum[i]++;
//					}
//				}
//			}
//		}
//		allaverage[i] /= studentnum[i];//未调整前选该课的所有学生所有课的平均分
//	}
//	for (int i = 0; i != n; ++i)
//	{
//		cout << subject[i] << " ";
//		cout << allaverage[i] - subaverage[i];
//		cout << endl;
//	}
//	return 0;
//}


//4072:判断多个点是否在同一直线
//#include<iostream>
//#include<stdio.h>
//using namespace std;
//const int maxn = 110;
//int True[maxn];
//double a[maxn][1000];
//double b[maxn][1000];
//int c[maxn];
//
//int main()
//{
//	int T = 0;
//	cin >> T;
//	for (int i = 0; i < T; i++)
//	{
//		cin >> c[i];
//		for (int j = 0; j < c[i]; j++)
//		{
//			cin >> a[i][j] >> b[i][j];
//		}
//	}
//
//	for (int i = 0; i < T; i++)
//	{
//		True[i] = 1;
//		for (int h = 1; h < c[i]; h++)
//		{
//			if (c[i] > 2 && (b[i][1] - b[i][0])*(a[i][h] - a[i][0]) != (b[i][h] - b[i][0])*(a[i][1] - a[i][0])) {
//				True[i] = 0;
//				//	cout<<a[i][0]*b[i][h]<<"and"<<a[i][h]*b[i][0]<<endl;
//				break;
//			}
//		}
//
//		if (True[i] == 1)
//		{
//			cout << "True" << endl;
//		}
//		else
//		{
//			cout << "False" << endl;
//		}
//	}
//
//
//
//
//
//	return 0;
//}


//4074:积水量
//#include<iostream>
//#include<algorithm>
//#include<stdlib.h>
//using namespace std;
//#define MAXN 20005
//int A[MAXN];
//int getS(int left, int right, int len) {
//	int sum = 0;
//	for (int i = left + 1; i<right; i++) {
//		if (A[i]<len)
//			sum++;
//	}
//	return sum;
//}
//int main() {
//	int m, n;
//	cin>>m;
//	while (m--) {
//		cin >> n;
//		int max_L = 0, sum = 0;
//		for (int i = 0; i<n; i++) {
//			cin >> A[i];
//			max_L = max(max_L, A[i]);
//		}
//		for (int i = 1; i <= max_L; i++) {
//			int left, right;
//			for (int j = 0; j<n; j++) {
//				if (A[j] >= i) {
//					left = j;
//					break;
//				}
//			}
//			for (int j = n - 1; j >= 0; j--) {
//				if (A[j] >= i) {
//					right = j;
//					break;
//				}
//			}
//			sum += getS(left, right, i);
//			//cout << i << " " << left << " " << right <<" "<<sum<< endl;
//
//		}
//		printf("%d\n", sum);
//	}
//	system("pause");
//	return 0;
//}


//4080:Huffman编码树
//#include<iostream>
//#include<stdio.h>
//#include<queue>
//using namespace std;
//int n, t;
//int main() {
//	cin >> n;
//	priority_queue<int, vector<int>, greater<int> >Q;
//	for (int i = 0; i<n; i++) {
//		cin >> t;
//		Q.push(t);
//	}
//	int ans = 0;
//	int a, b;
//	while (Q.size()>1) {
//		a = Q.top();
//		Q.pop();
//		b = Q.top();
//		Q.pop();
//		ans = ans + a + b;
//		Q.push(a + b);
//	}
//	cout << ans << endl;
//
//}


//4083:我爱北大  Floyd
//#include<iostream>
//#include<vector>
//#include<string>
//#include<map>
//#define INT_MAX 100000000
//
//using namespace std;
//map<int, string> num_lable;
//map<string, int> lable_num;
//
//string showpath(int a, int b, vector<vector<int>> path, vector<vector<int>> graph)
//{
//	string rt = "";
//	vector<int> temppath = path[a];
//	vector<string> result;
//	result.push_back(num_lable[b]);
//	int cur = b;
//	while (temppath[cur] != -1)
//	{
//		int t = temppath[cur];
//		int dis = graph[cur][t];
//		result.push_back("(" + to_string(dis) + ")");
//		result.push_back(num_lable[t]);
//		cur = t;
//	}
//
//	for (int i = result.size() - 1; i >= 0; i--)
//	{
//		if (i != 0)
//			rt += result[i] + "->";
//		else
//			rt += result[i];
//	}
//
//	return rt;
//
//}
//
//
//int main()
//{
//	int p;
//	cin >> p;
//
//	for (int i = 0; i < p; i++)
//	{
//		string tems;
//		cin >> tems;
//		num_lable.insert(pair<int, string>(i, tems));
//		lable_num.insert(pair<string, int>(tems, i));
//	}
//
//	vector<vector<int>> grah(p, vector<int>(p, INT_MAX));
//	for (int i = 0; i < p; i++)
//	{
//		grah[i][i] = 0;
//	}
//
//	int q;
//	cin >> q;
//	for (int i = 0; i < q; i++)
//	{
//		string a, b;
//		int l;
//		cin >> a >> b >> l;
//		int numa = lable_num[a];
//		int numb = lable_num[b];
//		if (l<grah[numa][numb])
//		{
//			grah[numa][numb] = l;
//			grah[numb][numa] = l;
//		}
//
//	}
//
//	vector<vector<int>> dis(p, vector<int>(p, 0));//定义距离
//	vector<vector<int>> path(p, vector<int>(p, -1));//定义路径
//
//	for (int i = 0; i < p; i++)
//	{
//		for (int j = 0; j < p; j++)
//		{
//			dis[i][j] = grah[i][j];
//			if (i != j && grah[i][j]<INT_MAX)
//				path[i][j] = i;
//		}
//	}
//
//	for (int node = 0; node < p; node++)
//	{
//		for (int i = 0; i < p; i++)
//		{
//			for (int j = 0; j < p; j++)
//			{
//				if (dis[i][j]>(dis[i][node] + dis[node][j]))
//				{
//					dis[i][j] = dis[i][node] + dis[node][j];
//					path[i][j] = path[node][j];
//				}
//			}
//		}
//		//	displayPath(path);
//	}
//
//
//	vector<string> result;
//	int r;
//	cin >> r;
//	for (int i = 0; i < r; i++)
//	{
//		string a, b;
//		cin >> a >> b;
//		if (a == b)
//			result.push_back(a);
//		else {
//			int numa = lable_num[a];
//			int numb = lable_num[b];
//			result.push_back(showpath(numa, numb, path, grah));
//		}
//	}
//	for (int i = 0; i < result.size(); i++)
//	{
//		cout << result[i] << endl;
//	}
//
//
//
//	system("pause");
//}


//4085:数组去重排序
//#include<iostream>
//#include<set>
//#include<stdio.h>	
//using namespace std;
//int main() {
//	int n,tp;
//	//scanf_s("%d", n);
//	cin >> n;
//	set<int> st;
//	for (int i = 0; i < n; i++) {
//		//scanf_s("%d", tp);
//		cin >> tp;
//		st.insert(tp);
//	}
//	for (auto itr = st.begin(); itr != st.end(); itr++) {
//		printf("%d ", *itr);
//	}
//	system("pause");
//	return 0;
//}


//4092:牛仔裤  网上答案
//# include <stdio.h>
//# include <string.h>
//# include <iostream>
//# include <algorithm>
//using namespace std;
//typedef long long ll;
//typedef long double ld;
//typedef unsigned long long ull;
//const int M = 5e5 + 10;
//const int mod = 1e9 + 7;
//
//# define RG register
//# define ST static
//
//int n;
//char s[11][66];
//
//char ans[66], t[66];
//
//inline bool ok(char *t, char *s, int l) {
//	for (int i = 0; i<l; ++i)
//		if (t[i] < s[i]) return 1;
//		else if (t[i] > s[i]) return 0;
//		return 0;
//}
//
//int main() {
//	int T; cin >> T;
//	while (T--) {
//		bool have = 0;
//		cin >> n;
//		for (int i = 1; i <= n; ++i) 
//			cin>>s[i];
//		for (int len = 60; len >= 3; len--) {//遍历公共子序列的长度
//			bool oo = 0;
//			for (int j = 0; j <= 60 - len; ++j) {//遍历第一个序列的起始位置
//				bool gg2 = 0;
//				for (int nx = 2; nx <= n; ++nx) {//遍历第二个序列开始的每个序列
//					bool suc = 0;
//					for (int nb = 0; nb <= 60 - len; ++nb) {//遍历第二个序列开始的每个序列的起始位置
//						bool gg = 0;
//						for (int o = 0; o<len; ++o)//判断子串是否相等
//							if (s[1][j + o] != s[nx][nb + o]) {
//								gg = 1;
//								break;
//							}
//						if (!gg) {
//							suc = 1;
//							break;
//						}
//					}
//					if (!suc) {
//						gg2 = 1;
//						break;
//					}
//				}
//				if (gg2) continue;
//				for (int k = 0; k<len; ++k) t[k] = s[1][j + k]; t[len] = 0;
//				if (!oo || ok(t, ans, len)) {
//					for (int k = 0; k<len; ++k) ans[k] = t[k];
//					ans[len] = 0;
//					oo = 1;
//				}
//			}
//			if (!oo) continue;
//			have = 1;
//			printf("%s\n", ans);
//			break;
//		}
//		if (!have) puts("no significant commonalities");
//	}
//	system("pause");
//	return 0;
//}

//4092:牛仔裤 自己写
//#include<iostream>
//#include<algorithm>
//#include<string>
//#include<vector>
//using namespace std;
//const int maxn = 15;
//string ans[65];
//bool cmp(string a, string b) {
//	return a < b;
//}
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 0; cnt < t; cnt++) {
//		int n;
//		cin >> n;
//		string str[maxn];
//		for (int i = 0; i < n; i++) {
//			cin >> str[i];
//		}
//		int tot = 0;
//		int SUC = 0;
//		for (int len = 60; len >= 3; len--) {
//			int suc = 0;//对于len这个长度 成功了就不用再找了
//			for (int pos1 = 0; pos1 <= 60 - len; pos1++) {
//
//				int suc_all = 1;//必须所有句子都找到相同的部分
//				for (int i = 1; i < n; i++) {
//					int suc_sentense = 0;//只要有一个posnext使这个句子匹配就可以了
//					for (int posnext = 0; posnext <= 60 - len; posnext++) {
//						/*if (len == 6&&pos1 == 1) {
//							cout << pos1 << " " << i << " " << posnext << " " << str[0].substr(pos1, len) << " " << str[i].substr(posnext, len) << endl;
//							system("pause");
//						}*/
//						if (str[0].substr(pos1, len) == str[i].substr(posnext, len)) {
//							suc_sentense = 1;
//							break;
//						}
//					}
//					if (!suc_sentense) {
//						suc_all = 0;
//						break;
//					}
//				}
//				if (suc_all) {//找到答案 如果没找到继续找 不用break
//					ans[tot] = str[0].substr(pos1, len);
//
//					//cout << tot << " " << ans[tot] << " " << pos1 << " " << len << endl;
//					tot++;
//					suc = 1;
//				}
//				
//			}
//			if (suc) {
//				SUC = 1;
//				break;
//			}
//		}
//		if (SUC) {
//			sort(ans, ans + tot , cmp);
//			//cout << "hhh" << endl;
//			cout << ans[0] << endl;
//		}
//		else {
//			cout << "no significant commonalities" << endl;
//		}
//		//cout << "hhh " << cnt << endl;
//
//
//	}
//	system("pause");
//	return 0;
//}


//4094 秘密会谈
//#include <iostream>
//#include <string>
//#include <algorithm>
//using namespace std;
//int main() {
//	int n; int k;
//	cin >> n >> k;
//	int time[10001];
//	for (int j = 1; j <= n; j++) {
//		int p, q;
//		cin >> p >> q;
//		time[j] = k / q + p;
//	}
//	sort(time + 1, time + n + 1);
//	cout << time[n];
//	return 0;
//}



//4109:公共朋友-Common Friends
//#include<iostream>
//using namespace std;
//const int maxn = 110;
//int con[maxn + 1][maxn + 1];
//int main()
//{
//	int c, n, m, k, t = 1;
//	cin >> c;
//	while (c--)
//	{
//		cin >> n >> m >> k;
//		memset(con, 0, sizeof(con));
//		int i, j, a, b;
//		
//		for (i = 0; i<m; i++)
//		{
//			cin >> a >> b;
//			con[a][b] = con[b][a] = 1;//有联系为1没联系为0
//		}
//		int x, y, sum;
//		cout << "case " << t << ":" << endl;
//		t++;
//		while (k--)
//		{
//			cin >> x >> y;
//			sum = 0;
//			for (i = 1; i<n + 1; i++)
//			{
//				if (con[x][i] == 1 && con[y][i] == 1)//x,y都与i有关系，i是它们的朋友
//					sum++;
//			}
//			cout << sum << endl;
//		}
//	}
//	return 0;
//}



//4111:判断游戏胜者-Who Is the Winner
//#include <iostream>
//#include <string>
//using namespace std;
//int fun(string h) {
//	string tp = "0";//最开始加一个0方便统计
//	for (int i = 0; i<h.size(); i++) {
//		//cout << i - 1 << " " << tp << endl;
//		switch (h[i]) {
//		case '0':tp += "0000"; break;
//		case '1':tp += "0001"; break;
//		case '2':tp += "0010"; break;
//		case '3':tp += "0011"; break;
//		case '4':tp += "0100"; break;
//		case '5':tp += "0101"; break;
//		case '6':tp += "0110"; break;
//		case '7':tp += "0111"; break;
//		case '8':tp += "1000"; break;
//		case '9':tp += "1001"; break;
//		case 'a':tp += "1010"; break;
//		case 'b':tp += "1011"; break;
//		case 'c':tp += "1100"; break;
//		case 'd':tp += "1101"; break;
//		case 'e':tp += "1110"; break;
//		case 'f':tp += "1111"; break;
//		}
//
//	}
//	int sum = 0; bool q = 0;
//	for (int m = 0; m<tp.size(); m++) {
//		if (tp[m] == '1'&&q == 0) sum++, q = 1;
//		else if (tp[m] == '0') q = 0;
//	}
//	return sum;
//}
//int main() {
//	int n; cin >> n;
//	while (n--) {
//		string p, q;
//		cin >> p >> q;
//		string a = p.substr(2, (p.size() - 2)); 
//		string b = q.substr(2, (q.size() - 2));
//		if (fun(a)>fun(b)) { cout << "Alice" << endl; }
//		else if (fun(a)<fun(b)) { cout << "Bob" << endl; }
//		else { cout << "Tie" << endl; }
//	}
//	return 0;
//}
//


//4112:情报破译-Cryptanalysis
//#include <iostream>
//#include<string.h>
//#include<cstdio>
//using namespace std;
//#define N 65536
//int main()
//{
//	//freopen("1.txt","r",stdin);
//	char ciphertext[N], temp[N];
//	int i;
//	char trans;
//	long num, cir, tem, oppo;
//	while (gets(ciphertext))
//	{
//		tem = 0;
//		i = 1;
//		num = strlen(ciphertext);
//		for (cir = 0; cir < num; cir++)
//		{
//			if (isalpha(ciphertext[cir]))
//				break;
//			else cout << ciphertext[cir];
//		}
//		for (; cir < num; cir++)
//		{
//			if (ciphertext[cir] >= 'A'&&ciphertext[cir] <= 'Z')
//			{
//				//下面这一步很关键
//				trans = (ciphertext[cir] - 'A' - (i) % 26) % 26;
//				if (trans >= 0) temp[tem] = trans + 'A';
//				else temp[tem] = trans + 26 + 'A';
//				tem++;
//				if (cir + 1 == num)
//				{
//					for (oppo = tem - 1; oppo >= 0; oppo--)
//					{
//						cout << temp[oppo];
//					}
//				}
//			}
//			else if (ciphertext[cir] >= 'a'&&ciphertext[cir] <= 'z')
//			{
//				trans = (ciphertext[cir] - 'a' - (i) % 26) % 26;
//				if (trans >= 0) temp[tem] = trans + 'a';
//				else temp[tem] = trans + 26 + 'a';
//				tem++;
//				if (cir + 1 == num)
//				{
//					for (oppo = tem - 1; oppo >= 0; oppo--)
//					{
//						cout << temp[oppo];
//					}
//				}
//			}
//			else
//			{
//				for (oppo = tem - 1; oppo >= 0; oppo--)
//				{
//					cout << temp[oppo];
//				}
//				tem = 0;
//				if (isalpha(ciphertext[cir + 1]))
//					i++;
//				cout << ciphertext[cir];
//			}
//		}
//		cout << endl;
//		//cout<<ciphertext<<endl;
//	}
//
//	return 0;
//}


//4113:北京地铁票价-BeiJing Subway  不是很懂
//#include <iostream>
//#include <string>
//#include <cmath>
//using namespace std;
//int price(int distance) {
//	if (distance <= 6000) return 3;
//	else if (distance <= 12000) return 4;
//	else if (distance <= 22000) return 5;
//	else if (distance <= 32000) return 6;
//	else {
//		distance -= 32000;
//		return 6 + ceil(distance / 20000.0);
//	};
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 1; i <= n; i++) {
//		int line;
//		cin >> line;
//		if (line == 1) {
//			int question;
//			cin >> question;
//			int station_cnt;
//			cin >> station_cnt;
//			string station[100];
//			int distance[100];//station 单数储存，distance 双数储存。
//			for (int i = 0; i <= 99; i++) {
//				distance[i] = 0;
//			}
//			for (int i = 1; i <= 2 * station_cnt - 1; i++) {
//				if (i % 2 == 1) cin >> station[i];
//				else cin >> distance[i];
//			}
//			cout << "Case " << i << ":" << endl;
//			while (question--) {
//				string start_starion, end_station;
//				cin >> start_starion >> end_station;
//				int distan = 0; int begin = 0, end = 0;
//				for (int i = 1; i < 2 * station_cnt; i += 2) {
//					if (station[i] == start_starion) begin = i;
//					if (station[i] == end_station) end = i;
//				}
//				if (end < begin) {
//					int y = begin;
//					begin = end;
//					end = y;
//				}
//				for (int i = begin; i <= end; i++) {
//					distan += distance[i];
//				}
//				cout << price(distan) << endl;
//			}
//		}
//		if (line == 2) {
//			int question;
//			cin >> question;
//			int station_cnt_1; string s1[100]; int d1[100];
//			int station_cnt_2; string s2[100]; int d2[100];
//			for (int i = 0; i <= 99; i++) {
//				d1[i] = 0; d2[i] = 0;
//			}
//			cin >> station_cnt_1;
//			for (int i = 1; i <= 2 * station_cnt_1 - 1; i++) {
//				if (i % 2 == 1) cin >> s1[i];
//				else cin >> d1[i];
//			}
//			cin >> station_cnt_2;
//			for (int i = 1; i <= 2 * station_cnt_2 - 1; i++) {
//				if (i % 2 == 1) cin >> s2[i];
//				else cin >> d2[i];
//			}
//			cout << "Case " << i << ":" << endl;
//			int stransfer_pos_1 = 0, transfer_pos_2 = 0; string transfer_station;//find the transfer station.
//			for (int i = 1; i <= 2 * station_cnt_1 - 1; i += 2) {
//				for (int j = 1; j <= 2 * station_cnt_2 - 1; j += 2) {
//					if (s1[i] == s2[j])
//						stransfer_pos_1 = i, transfer_pos_2 = j, transfer_station = s1[i];//tOf1 is the number of transfer station.
//				}
//			}
//			while (question--) {
//				int tof1 = stransfer_pos_1, tof2 = transfer_pos_2;
//				string start_starion, end_staion;
//				cin >> start_starion >> end_staion;
//				int begin = 0, end = 0, L1 = 0, L2 = 0;
//				if (start_starion == transfer_station) L1 = 3;
//				if (end_staion == transfer_station) L2 = 3;
//				for (int i = 1; i <= station_cnt_1 * 2; i++) {
//					if (start_starion != transfer_station && start_starion == s1[i])
//						begin = i, L1 = 1;
//					if (end_staion != transfer_station && end_staion == s1[i])
//						end = i, L2 = 1;
//				}
//				for (int i = 1; i <= station_cnt_2 * 2 + 2; i++) {
//					if (start_starion != transfer_station && start_starion == s2[i])
//						begin = i, L1 = 2;
//					if (end_staion != transfer_station && end_staion == s2[i])
//						end = i, L2 = 2;
//				}//begin，end记录在线路上的位置，L1，L2代表在哪条线上
//				if (start_starion == transfer_station || end_staion == transfer_station) {
//					if (end_staion == transfer_station) {
//						string p = start_starion;
//						start_starion = end_staion;
//						end_staion = p;
//						end = begin;
//						L2 = L1;
//					}//e1 is transfer station.
//					if (L2 == 1) {
//						if (tof1 > end) {
//							int y = tof1;
//							tof1 = end;
//							end = y;
//						}
//						int distance = 0;
//						for (int i = tof1; i <= end; i++) {
//							distance += d1[i];
//						}
//						cout << price(distance) << endl;
//					}
//					else {
//						if (tof2 > end) { int y = tof2; tof2 = end; end = y; }
//						int distance = 0;
//						for (int i = tof2; i <= end; i++) {
//							distance += d2[i];
//						}
//						cout << price(distance) << endl;
//					}
//				}
//				else if (L1 == L2) {
//					int distance = 0;
//					if (L1 == 1) {
//						distance = 0;
//						if (begin > end) { int y = begin; begin = end; end = y; }
//						for (int i = begin; i <= end; i++) {
//							distance += d1[i];
//						}
//						cout << price(distance) << endl;
//					}
//					else {
//						distance = 0;
//						if (begin > end) { int y = begin; begin = end; end = y; }
//						for (int i = begin; i <= end; i++) {
//							distance += d2[i];
//						}
//						cout << price(distance) << endl;
//					}
//				}
//				else {
//					int distance = 0;
//					if (L1 == 1) {
//						distance = 0;//第一站是在L1上。
//						if (begin > tof1) { int y = begin; begin = tof1; tof1 = y; }
//						for (int i = begin; i <= tof1; i++) {
//							distance += d1[i];
//						}
//						if (tof2 > end) { int y = tof2; tof2 = end; end = y; }
//						for (int i = tof2; i <= end; i++) {
//							distance += d2[i];
//						}
//						cout << price(distance) << endl;
//					}
//					else {
//						distance = 0;//第一站在L2上
//						if (tof2 > begin) { int y = tof2; tof2 = begin; begin = y; }
//						for (int i = tof2; i <= begin; i++) {
//							distance += d2[i];
//						}
//						if (tof1 > end) { int y = tof1; tof1 = end; end = y; }
//						for (int i = tof1; i <= end; i++) {
//							distance += d1[i];
//						}
//						cout << price(distance) << endl;
//					}
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}




//4117:简单的整数划分问题
//#include<cstdio>
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int MAX = 55 + 5;
//long long dp[MAX][MAX];
//long long ans[MAX];
//int main()
//{
//	int n;
//	while (cin >> n) {
//		for (int i = 1; i <= n; i++)
//			dp[0][i] = 1;
//		for (int i = 1; i <= n; i++) {//遍历总和
//			for (int j = 1; j <= n; j++) {//遍历最大数
//				if (i < j) dp[i][j] = dp[i][j - 1];//这里思路比较像01背包 注意 这里也可以等于 dp[i][j] = dp[i][i]
//				else dp[i][j] = dp[i - j][j] + dp[i][j - 1];
//			//	cout << i << " " << j << " " << dp[i][j] << endl;
//			}
//		}
//		cout << dp[n][n] << endl;
//	}
//	
//	system("pause");
//	return 0;
//}



//4119:复杂的整数划分问题
//#include<cstdio>
//#include<cmath>
//#include<iostream>
//#include<cstring>
//#include<cstdlib>
//#include<algorithm>
//#include<vector>
//#include<sstream>
//#include<map>
//#include<stack>
//#include<queue>
//#include<set>
//using namespace std;
//int N, K, dp[51][51];
//void Work_1() {//类似于分苹果的思想   fun(m,n-1)+fun(m-n,n);  //有空盘子的情况 +　没有空盘子的情况
//	memset(dp, 0, sizeof(dp)); //dp[i][j]把i划分成j个数的种类数
//	dp[0][0] = 1;
//	for (int i = 1; i <= N; i++) {
//		for (int j = 1; j <= K; j++) {
//			if (i >= j) dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1];
//			//dp[i-j][j]表示这j个数中没有1（即每个数都大于1），则每个数减1的种类数
//			//dp[i-1][j-1]表示这j个数中有1，则分离出一个1
//			//cout << i << " " << j << " " << dp[i][j] << endl;
//		}
//	}
//	printf("%d\n", dp[N][K]);
//}
//void Work_2() {
//	memset(dp, 0, sizeof(dp)); //d[i][j]把i划分成最大数为j的种类数。
//	for (int i = 0; i <= N; i++)
//		dp[0][i] = 1;
//	for (int i = 1; i <= N; i++) {
//		for (int j = 1; j <= N; j++) {
//			if (j > i) dp[i][j] = dp[i][i];//dp[i][j] = dp[i][j-1]也可以
//			else dp[i][j] = dp[i - j][j - 1] + dp[i][j - 1];
//			//dp[i-j][j-1] 如果i里包括j，则转化为把(i-j)划分为 最大数为 j-1 的种类数
//			//dp[i][j-1] 如果i里不包括j，则转化为把 i 划分为 最大数为 j-1 的种类数
//			//cout << i << " " << j << " " << dp[i][j] << endl;
//
//		}
//	}
//	printf("%d\n", dp[N][N]);
//}
//void Work_3() {
//	memset(dp, 0, sizeof(dp)); //d[i][j]把i划分成最大数为j的种类数。
//	for (int i = 1; i <= N; i++) {//初始化
//		dp[i][1] = 1;
//		dp[0][i] = 1;
//	}
//	for (int i = 1; i <= N; i++) {
//		for (int j = 1; j <= N; j++) {
//			if (j & 1) {//如果j为奇数
//				if (j > i) dp[i][j] = dp[i][i];
//				else dp[i][j] = dp[i - j][j] + dp[i][j - 1];//这里不能改成j-2  因为最开始是1  如果减2就越界了
//				//dp[i-j][j] 如果i里包括j，则转化为把(i-j)划分为 最大数为 j 的种类数
//				//dp[i][j-1] 如果i里不包括j，则转化为把 i 划分为 最大数为 j-1 的种类数
//			}
//			else dp[i][j] = dp[i][j - 1];
//		}
//	}
//
//	printf("%d\n", dp[N][N]);
//}
//int main() {
//	while (cin >> N >> K) {
//		Work_1();
//		Work_2();
//		Work_3();
//	}
//	return 0;
//}



//4120:硬币
//#include<iostream>
//#include<stdio.h>
//#include<cstring>
//using namespace std;
//int dp[1000005];//表示形成i钱数的方案
//int ans[1000005];//表示没有j时形成i钱数的方案数
//int a[220];//存放钱的种类
//int b[220];//存放必须有的种类
//int main()
//{
//	int n, m;
//	int count, k;
//	while (cin >> n >> m)
//	{
//		for (int i = 1; i <= n; i++)
//			cin >> a[i];
//		memset(dp, 0, sizeof(dp));
//		dp[0] = 1;
//		for (int i = 1; i <= n; i++)
//		{
//			for (int j = m; j >= a[i]; j--)
//			{
//				dp[j] = dp[j] + dp[j - a[i]];
//				//j是由a[i]和j-a[i]的和，a[i]的方案为1，
//				//j-a[i]的方案数为dp[h-a[i]],即为dp[j-a[i]]；
//				//cout << i << " " << j << " " << dp[j] << endl;
//			}
//
//		}
//		count = 0;
//		for (int i = 1; i <= n; i++)
//		{
//			for (int j = 0; j <= m; j++)
//			{	
//				//cout << j << " " << dp[j] << endl;
//				if (j < a[i])
//					ans[j] = dp[j];
//				else
//					ans[j] = dp[j] - ans[j - a[i]];
//				cout << i << " " << j << " " << ans[j] << endl;
//			}
//			if (ans[m] == 0)//缺了j就不行了，那么j是必需的
//			{
//				b[count++] = a[i];
//			}
//		}
//		printf("%d\n", count);
//		if (count == 0)
//			printf("\n\n");
//		else
//		{
//			for (int i = 0; i < count; i++)
//			{
//				if (i != count - 1)
//					printf("%d ", b[i]);
//				else
//					printf("%d\n", b[i]);
//			}
//		}
//
//	}
//	system("pause");
//	return 0;
//}


//4121:股票买卖
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//#include<algorithm>
//#include<stdio.h>
//using namespace std;
//const int N = 100005;//n^2算法肯定超时
//int m[N], p[N], q[N];
//int main()
//{
//	int t, n;
//	cin >> t;
//	while (t--)
//	{
//		cin >> n;
//		memset(p, 0, sizeof(p));//记得输入后就清零，以免忘记
//		memset(q, 0, sizeof(q));
//		for (int i = 1; i <= n; i++)
//			//cin >> m[i];
//			scanf("%d", &m[i]);
//		int minn = m[1];
//		p[1] = 0;//前i个数中所有数对之差的最大值。
//		for (int i = 2; i <= n; i++)
//		{
//			minn = min(m[i], minn);
//			p[i] = max(p[i - 1], m[i] - minn);
//			//cout << i << " " << p[i] << endl;
//		}
//		int maxn = m[n];
//		q[n] = 0;
//		for (int i = n - 1; i >= 1; i--)//下标从i~n中所有数对之差的最大值
//		{
//			maxn = max(m[i], maxn);
//			q[i] = max(q[i + 1], maxn - m[i]);
//			//cout << i << " " << q[i] << endl;
//		}
//		int money = 0;
//		for (int i = 1; i <= n; i++) {
//			money = max(p[i - 1] + q[i], money);
//			//cout << i << ' ' << p[i - 1] << " " << q[i] << endl;
//		}
//		money = max(money, 0);//如果最后小于0，就选择入手就卖的方法
//		printf("%d\n", money);
//	}
//	system("pause");
//	return 0;
//}


//4124:海贼王之伟大航路
//#include <ctime>
//#include <cmath>
//#include <queue>
//#include <vector>
//#include <cstdio>
//#include <string>
//#include <cstring>
//#include <iomanip>
//#include <iostream>
//#include <algorithm>
//using namespace std;
//
//const int INF = 0x3f3f3f3f;
//const int MAXN = 16 + 5;
//
//int N;
//int G[MAXN][MAXN];
//int dp[MAXN][(1 << 16) + 5];
//int finish;
//
//int main() {
//
//	while (~scanf("%d", &N)) {
//		for (int i = 1; i <= N; i++) {
//			for (int j = 1; j <= N; j++) {
//				scanf("%d", &G[i][j]);
//			}
//		}
//		finish = (1 << N) - 1;
//		memset(dp, INF, sizeof(dp));
//
//		dp[1][1] = 0;
//		for (int k = 1; k <= finish; k++) {//枚举状态
//			for (int i = 1, fi = 1; i <= N; i++, fi <<= 1) {
//				if (!(k & fi)) continue;
//				for (int j = 1, fj = 1; j <= N; j++, fj <<= 1) {
//					if (i == j || !(k & fj)) continue;
//					dp[i][k] = min(dp[i][k], dp[j][k ^ fi] + G[j][i]);
//				}
//			}
//		}
//		printf("%d\n", dp[N][finish]);
//	}
//	//    end = clock();
//	//    printf ("time=%f\n", (double) (end - start) / CLK_TCK);
//	return 0;
//}


//4128:单词序列
//#include <iostream>
//#include <string.h>
//#include <algorithm>
//#include <cstdio>
//#include <stdlib.h>
//#include <string>
//#include <memory>
//#include <queue>
//using namespace std;
//struct word {
//	char words[7];
//	int step;
//	word() { step = 0; }
//};
//word diction[31];
//word start, endw;
//int num = 1;
//bool visited[31];
//queue<word>q;
//int cmp(word&a, word&b) {
//	int count = 0;
//	int l = strlen(a.words);
//	for (int i = 0; i < l; i++)
//		if (a.words[i] != b.words[i])
//			count++;
//	return count;
//}
//void bfs() {
//	bool flag = false;
//	while (!q.empty()) {
//		word now = q.front();
//		q.pop();
//		for (int i = 1; i <= num; i++) {
//			if (visited[i] != 1 && cmp(now, diction[i]) == 1) {
//				visited[i] = 1;
//				diction[i].step = now.step + 1;
//				if (cmp(diction[i], endw) == 1) {
//					flag = true;
//					printf("%d\n", diction[i].step + 2);
//					return;
//				}
//				q.push(diction[i]);
//			}
//		}
//	}
//	if (flag == false)
//		printf("0\n");
//}
//int main()
//{
//	cin >> start.words >> endw.words;
//	while (cin >> diction[num].words)
//		num++;
//	if (cmp(start, endw) == 1)
//	{
//		printf("2\n");
//		return 0;
//	}
//	q.push(start);
//	bfs();
//	return 0;
//}


//4133:垃圾炸弹
//Garbage bomb
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//using namespace std;
//
//#define MAX 1025
//
//int map[MAX][MAX];    //枚举地图各点可清除垃圾数
//
//					  /*垃圾点*/
//struct Point {
//	int x, y;    //坐标
//	int m;    //垃圾数
//}p[21];
//
//int main()
//{
//	memset(map, 0, sizeof(map));
//	int d, n;
//	scanf("%d%d", &d, &n);
//	for (int i = 0; i < n; i++)
//		scanf("%d%d%d", &p[i].x, &p[i].y, &p[i].m);
//
//	int ans = 0, cnt = 0;
//	for (int i = 0; i < n; i++)//枚举每一枚炸弹
//	{
//		for (int row = p[i].x - d; row <= p[i].x + d; row++)//枚举这枚炸弹周围的横坐标
//			if (row >= 0 && row < MAX) {
//				for (int col = p[i].y - d; col <= p[i].y + d; col++)//枚举这枚炸弹周围的纵坐标
//				{
//					if (col >= 0 && col < MAX)
//					{
//						map[row][col] += p[i].m;
//						/*refresh*/
//						if (ans < map[row][col])
//						{
//							ans = map[row][col];
//							cnt = 1;
//						}
//						else if (ans == map[row][col]) cnt++;
//					}
//				}
//			}
//	}
//	printf("%d %d\n", cnt, ans);
//	return 0;
//}


//4134:查找最接近的元素
//#include<iostream>
//#include<set>
//#include<algorithm>
//using namespace std;
//const int maxn = 100010;
//int main() {
//	int n;
//	while (cin >> n) {
//		int m[maxn];
//		int tmp;
//		for (int i = 0; i < n; i++) {
//			scanf_s("%d", &m[i]);
//		}
//		int t;
//		cin >> t;
//		for (int i = 0; i < t; i++) {
//			int tar;
//			cin >> tar;
//			int l = lower_bound(m, m + n, tar) - m;
//			int u = upper_bound(m, m + n, tar) - m;
//			//cout << l << " " << u << endl;
//			if (l == n) {
//				cout << m[n - 1] << endl;
//			}
//			else {
//				if (tar == m[l]) {//即l!=u
//					cout << tar << endl;
//				}
//				else {//l==u
//					/*if (abs(tar - m[l-1]) > abs(tar - m[u])) {
//						cout << m[u] << endl;
//					}
//					else {
//						cout << m[u-1] << endl;
//					}*/
//					if (l == 0) {//一定要加这个判断！！！否则l-1可能越界
//						cout << m[0] << endl;
//					}
//					else {
//						if (abs(tar - m[l - 1]) > abs(tar - m[l])) {
//							cout << m[l] << endl;
//						}
//						else {
//							cout << m[l - 1] << endl;
//						}
//					}
//				}
//				
//
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//4144:畜栏保留问题
//#include<iostream>
//#include <queue>
//using namespace std;
//#define NUM 50005
//struct cow {
//	int start;
//	int ed;//挤奶区间起终点
//	int id;//编号
//	bool operator<(const struct cow  &t) const {
//		return this->start < t.start;
//	}
//}Cow[NUM];
//int result[NUM];//表示编号为i的奶牛去的畜栏编号
//struct Fence
//{
//	int bgin;//开始
//	int finish;//结束
//	int id_fense;//栅栏编号;
//	bool operator<(const Fence &t)const {
//		return this->finish > t.finish;//先用时间结束早的；
//	}
//	Fence() {};
//	Fence(int x, int y, int n) :bgin(x), finish(y), id_fense(n) {}
//};
//int main()
//{
//	int N;
//	cin >> N;
//	for (int i = 0; i < N; i++)
//	{
//		cin >> Cow[i].start >> Cow[i].ed;
//		Cow[i].id = i;
//	}
//
//	//    for(int i = 0;i<N;i++)
//	//        {cout <<Cow[i].f<<" "<<Cow[i].e<<" "<< Cow[i].NO<<endl;}
//	sort(Cow, Cow + N);
//
//	//    for(int i = 0;i<N;i++)
//	//        {cout <<Cow[i].f<<" "<<Cow[i].e<<" "<< Cow[i].NO<<endl;}
//
//
//
//	int tot = 0;
//	priority_queue<Fence > q;
//	for (int i = 0; i < N; i++) {
//		if (q.empty()) {
//			tot++;
//			q.push(Fence(Cow[i].start, Cow[i].ed, tot));
//			result[Cow[i].id] = tot;
//		}
//		else {
//			Fence now_fence = q.top();
//			if (now_fence.finish < Cow[i].start) {//可以加入原来的畜栏
//				q.pop();
//				result[Cow[i].id] = now_fence.id_fense;
//				q.push(Fence(Cow[i].start, Cow[i].ed, now_fence.id_fense));
//			}
//			else {
//				tot++;
//				q.push(Fence(Cow[i].start, Cow[i].ed, tot));
//				result[Cow[i].id] = tot;
//			}
//		}
//
//
//	}
//	cout << tot << endl;
//	for (int i = 0; i < N; ++i)
//		cout << result[i] << endl;
//
//
//
//
//	return 0;
//}

//4145:放弃考试
//#include <iostream>
//#include <memory.h>
//#include <math.h>
//#include <stdio.h>
//#include <unordered_map>
//#include <string>
//#include <map>
//#include <algorithm>
//#include <cmath>
//using namespace std;
//int pass[1005], question[1005];
//double temp[1005];
//int n, k;
//bool check(double rate)
//{
//	for (int i = 0; i < n; i++) {
//		temp[i] = pass[i] - rate * question[i];
//		cout << i << " " << rate << " " << pass[i] << " " << question[i] << " " << temp[i] << endl;
//	}
//	sort(temp, temp + n);//这个数组是什么意思
//	double sum = 0.0;
//	for (int i = k; i < n; i++)
//		sum += temp[i];
//	if (sum >= 0)
//		return true;
//	else
//		return false;
//}
//int main()
//{
//	while (cin >> n >> k, n != 0)
//	{
//		for (int i = 0; i < n; i++)
//			cin >> pass[i];
//		for (int i = 0; i < n; i++)
//			cin >> question[i];
//		double left = 0, right = 1;
//		while ((right - left) > 1e-6)
//		{
//			double mid = left + (right - left) / 2.0;
//			if (check(mid))
//			{
//				left = mid;
//			}
//			else
//				right = mid;
//		}
//		printf("%.0f\n", 100 * left);
//	}
//	system("pause");
//	return 0;
//}


//4149:课程大作业
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<algorithm>
//#include<vector>
//using namespace std;
//int t, n;
////记录课程的结束时间，需要花费的时间
//struct Homework {
//	string name;
//	int deadline, cost;
//}homework[20];
//
////记录路径，最小扣分以及最后结束的天数，用于dp
//struct node {
//	int pre;
//	int minscore;
//	int last;
//	int finishday;
//}dp[(1 << 16) + 20];
//
////返回路径
//vector<int> getpath(int status) {
//	vector<int> path;
//	while (status) {
//		path.push_back(dp[status].last);
//		status = dp[status].pre;
//	}
//	reverse(path.begin(), path.end());
//	return path;
//}
//
//int main() {
//	cin >> t;
//	while (t--) {
//		cin >> n;
//		char name[60];
//		int d, c;
//		for (int i = 0; i < n; i++)
//			cin >> homework[i].name >> homework[i].deadline >> homework[i].cost;
//		dp[0].finishday = 0;
//		dp[0].minscore = 0;
//		dp[0].pre = -1;
//		int m = 1 << n;
//
//		for (int i = 1; i < m; ++i) {
//			dp[i].minscore = 1 << 30;
//			for (int j = 0; j < n; ++j) {
//				if (i&(1 << j)) {  //枚举最后一个做的课程是什么
//					int pre = i - (1 << j); // 上一个课程
//					int finishday = dp[pre].finishday + homework[j].cost;
//					int tmpscore = finishday - homework[j].deadline;
//					if (tmpscore < 0)tmpscore = 0;
//					if (dp[i].minscore > dp[pre].minscore + tmpscore) {
//						dp[i].minscore = dp[pre].minscore + tmpscore;
//						dp[i].pre = pre;
//						dp[i].finishday = finishday;
//						dp[i].last = j;
//					}
//					if (dp[i].minscore == dp[pre].minscore + tmpscore) {
//						vector<int> p1 = getpath(dp[i].pre);
//						vector<int> p2 = getpath(pre);
//						if (p2 < p1) {
//							dp[i].pre = pre;
//							dp[i].finishday = finishday;
//							dp[i].last = j;
//						}
//					}
//				}
//			}
//		}
//		cout << dp[m - 1].minscore << endl;
//		int status = m - 1;
//		vector<int> path = getpath(status);
//		for (int i = 0; i < path.size(); i++)cout << homework[path[i]].name << endl;
//	}
//	return 0;
//}

//4150:上机
//#include<iostream>
//#include<cmath>
//#include<cstring>
//#include<algorithm>
//#include<iomanip>
//#include<queue>
//#include<stack>
//#include<vector>
//#include<set>
//#include<map>
//using namespace std;
//int dp[10005][4];
//int a[10005];
//int b[10005];
//int c[10005];
//int main()
//{
//	int n;
//	scanf_s("%d", &n);
//	for (int i = 1; i <= n; ++i)
//	{
//		scanf_s("%d", &a[i]);
//	}
//	for (int i = 1; i <= n; ++i)
//	{
//		scanf_s("%d", &b[i]);
//	}
//	for (int i = 1; i <= n; ++i)
//	{
//		scanf_s("%d", &c[i]);
//	}
//	dp[1][0] = a[1];//左右无人
//	dp[1][1] = b[1];//右边有人
//	dp[1][2] = -0x7fffffff / 2;//左边有人
//	dp[1][3] = -0x7fffffff / 2;//两边都有人
//	//cout << endl << 1 << " " << dp[1][0] << " " << dp[1][1] << " " << dp[1][2] << " " << dp[1][3] << endl;
//	for (int i = 2; i <= n; ++i)
//	{
//		//逻辑关系：dp[i][0]表示左右无人 所以i-1和i+1是后来坐的  对于i-1是右边有人所以从dp[i - 1][3]和dp[i - 1][1]转移过来
//		dp[i][0] = max(dp[i - 1][3], dp[i - 1][1]) + a[i];
//		dp[i][1] = max(dp[i - 1][3], dp[i - 1][1]) + b[i];
//		dp[i][2] = max(dp[i - 1][2], dp[i - 1][0]) + b[i];
//		dp[i][3] = max(dp[i - 1][2], dp[i - 1][0]) + c[i];
//		//cout << i << " " << dp[i][0] << " " << dp[i][1] << " " << dp[i][2] << " " << dp[i][3] << endl;
//	}
//	cout << max(dp[n][0], dp[n][2]) << endl;
//	system("pause");
//	return 0;
//}


//特殊密码锁  http://noi.openjudge.cn/ch0406/8469/
//#include <iostream>
//#include <string>
//#include <algorithm>
//#include<stdio.h>
//#include<climits>
//using namespace std;
//const int maxn = 35;
//int m[maxn];
//int ans[maxn];
//string tmpst, tmped;
//int st[maxn], ed[maxn];
//int cnt = 0;
//int len;
//int suc = 0;
//bool check() {
//	//cout << len << endl;
//	if (ans[1]) {
//		cnt++;
//	}
//	for (int i = 2; i <= len + 1; i++) {
//	
//			ans[i] = st[i - 1] ^ ans[i - 1] ^ ans[i - 2] ^ ed[i - 1];
//		
//		if (ans[i] == 1 && i != len + 1) {
//			cnt++;
//		}
//		//cout << i << " " << ans[i] << " " << cnt << endl;
//	}
//	if (ans[len + 1]) {//在按下第len+1个按钮之后 前了了len个已经和目标对齐  但实际上没有第了len+1个按钮 所以ans[len+1]必须为0才对
//		return false;
//	}
//	else {
//		suc = 1;
//		return true;
//	}
//}
//int main() {
//
//	cin >> tmpst >> tmped;
//	len = tmpst.length();
//	for (int i = 1; i <= len; i++) {
//		st[i] = tmpst[i - 1] - '0';
//		ed[i] = tmped[i - 1] - '0';
//	}
//	int res = INT_MAX;
//	for (int op = 0; op < 2; op++) {
//		cnt = 0;
//		ans[1] = op;
//
//		if (check()) {
//			//cout << cnt << endl;
//			res = min(res, cnt);
//		}
//	}
//	if (suc) {
//		cout << res << endl;
//	}
//	else {
//		cout << "impossible" << endl;
//	}
//	system("pause");
//	return 0;
//}


//The Sierpinski Fractal
//#include<cstdio>
//#include<cstring>
//#include<iostream>
//using namespace std;
//
//int n, tot;
//char a[2050][2050];
//
//void cal(int u, int x, int y)
//{
//	if (u == 1)
//	{
//		a[x][y] = ' ';
//		a[x][y + 1] = '/';
//		a[x][y + 2] = '\\';
//		a[x][y + 3] = ' ';
//
//		a[x + 1][y] = '/';
//		a[x + 1][y + 1] = '_';
//		a[x + 1][y + 2] = '_';
//		a[x + 1][y + 3] = '\\';
//		return;
//	}
//	for (int i = x; i < x + (1 << (u - 1)); i++) {
//		for (int j = y; j < y + (1 << (u - 1)); j++) {
//			a[i][j] = ' ';
//			cout << i << " " << j << endl;
//		}
//	}
//		
//	cout << "hhh" << endl;
//	for (int i = x; i < x + (1 << (u - 1)); i++) {
//		for (int j = y + (1 << (u + 1)) - 1; (1 << (u + 1)) - j <=  y + 1 << (u - 1); j--) {
//			a[i][j] = ' ';
//			cout << i << " " << j << endl;
//		}
//
//	}
//		
//	cal(u - 1, x + (1 << (u - 1)), y);
//	cal(u - 1, x, y + (1 << (u - 1)));
//	cal(u - 1, x + (1 << (u - 1)), y + (1 << u));
//}
//
//int main()
//{
//	while (cin>>n && n)
//	{
//		memset(a, 0, sizeof(a));
//		tot = 1 << n;
//		cal(n, 1, 1);
//		for (int i = 1; i <= tot; i++)
//		{
//			printf("%s", a[i] + 1); 
//			puts("");
//		}
//		puts("");
//	}
//	return 0;
//}


//UNIMODAL PALINDROMIC DECOMPOSITIONS
//# include<stdio.h>
//# include<string.h>
//#include<iostream>
//using namespace std;
//const int maxn = 6;
//long long  d[maxn][maxn];
//int main() {
//	memset(d, 0, sizeof(d));
//	int i, j;
//	//初始化
//	for (i = 1; i<maxn; i++)
//	{
//		d[i][i] = 1;
//		if (i % 2 == 0) d[i][i / 2] = 1;  //如果i是偶数，则可分解成i/2i/2这种形式
//	}
//	d[2][1] = 1;
//	d[3][1] = 1;
//	d[4][1] = 2;
//	d[4][2] = 1;
//	
//	for (i = 5; i<maxn; i++)//相当于输入的n
//	{
//		for (j = 1; j<maxn; j++)//遍历最小值
//		{
//			if (i - 2 * j >= j)//满足回文并且还是先上升再下降
//			{
//				for (int m = j; m <= i - 2 * j; m++) {//拆分成更小的子问题
//					d[i][j] += d[i - 2 * j][m];
//					//cout << i << " " << j << ' ' << i - 2 * j << " " << m<<" " << d[i - 2 * j][m] << endl;
//				}
//					
//			}
//			else
//				break;
//		}
//	}
//	int n;
//	while (cin>>n && n)
//	{
//		long long  ans = 0;
//		for (i = 1; i <= n; i++) {
//			ans += d[n][i];
//			cout << i << " " << d[n][i] << " " << ans << endl;
//		}
//		printf("%d %lld\n", n, ans);
//	}
//	return 0;
//}

//课程大作业
//#include <iostream>
//#include <cstdio>
//#include <cmath>
//#include <algorithm>
//#include <string>
//#include <string.h>
//using namespace std;
//const int MAX = 1 << 16;//状态压缩
//int dp[MAX];//表示把每一个状态中课程全部完成的最少用时
//int t[20];//表示每一门课程的完成时间
//int d[20];//表示每一门课程的ddl
//int sum[MAX];//表示某一状态的完成时间总和
//string name[20];
//string ans[MAX];
//int calc(int a, int b) {
//	return max(0, a - b);
//}
//int main()
//{
//	int T; cin >> T;
//	while (T--) {
//		int n; cin >> n;
//		for (int i = 0; i < n; ++i) {
//			cin >> name[i] >> d[i] >> t[i];
//			sum[1 << i] = t[i];//表示某一状态的完成时间总和
//			cout << ( i) << " " << t[i] << endl;
//		}
//		for (int i = 1; i < (1 << n); ++i) {
//			for (int j = 0; j < n; ++j) {
//				if (i&(1 << j)) {
//					sum[i] = sum[i ^ (1 << j)] + t[j];
//					cout << i << " " << j << " " << sum[i] << endl;
//				}
//			}
//		}
//		dp[0] = 0;
//		for (int i = 0; i < (1 << n); ++i)ans[i] = "";//初始化
//		for (int i = 1; i < (1 << n); ++i) {
//			for (int j = 0; j < n; ++j) {
//				if (i&(1 << j) && (dp[i ^ (1 << j)] + calc(sum[i], d[j]) <= dp[i] || ans[i] == "")) {
//					if (dp[i ^ (1 << j)] + calc(sum[i], d[j]) < dp[i] || ans[i ^ (1 << j)] + name[j] + "\n" < ans[i] || ans[i] == "") {
//						ans[i] = ans[i ^ (1 << j)] + name[j] + "\n";
//					}
//					dp[i] = dp[i ^ (1 << j)] + calc(sum[i], d[j]);
//				}
//			}
//		}
//		cout << dp[(1 << n) - 1] << endl;
//		cout << ans[(1 << n) - 1];
//	}
//	return 0;
//}

//Professor John
//#include <stdio.h>
//#include <memory.h>
//
//using namespace std;
//
//int main(void)
//{
//	// ifstream cin("data.txt");
//	int t;
//	int n;
//	int map[30][30];
//	int mark[30][30];
//	int lhs, rhs;
//	char oprat;
//	char str[5];
//
//	scanf("%d", &t);
//
//	for (int cnt = 1; cnt <= t; ++cnt)
//	{
//		int flag= 1;
//
//		memset(map, 0, sizeof(map));
//
//		scanf("%d", &n);
//		for (int i = 0; i<n; ++i)
//		{
//			// cin>>lhs>>oprat>>rhs;
//			scanf("%s", &str);
//			lhs = str[0] - 'A';
//			rhs = str[2] - 'A';
//			oprat = str[1];
//			if (oprat == '<')
//			{
//				map[lhs][rhs] = 1;
//			}
//			else
//
//			{
//				map[rhs][lhs] = 1;
//			}
//		}
//
//		memcpy(mark, map, sizeof(map));
//		//floyd
//		for (int k = 0; k<30; ++k)
//		{
//			for (int i = 0; i<30; ++i)
//			{
//				for (int j = 0; j<30; ++j)
//				{
//					map[i][j] = map[i][j] || map[i][k] && map[k][j];
//				}
//
//			}
//		}
//
//		printf("Case %d:\n", cnt);
//		for (int i = 0; i<30; ++i)
//		{
//			for (int j = 0; j<30; ++j)
//			{
//
//				if ((map[i][j]) && !mark[i][j])
//				{
//					printf("%c<%c\n", i + 'A', j + 'A');
//					flag = 0;
//				}
//			}
//		}
//		if (flag)
//			printf("NONE\n");
//
//	}
//
//
//	return 0;
//}


/*
POJ 1077 Eight
正向广度搜索
把“x"当初0

*/

//#include<stdio.h>
//#include<queue>
//#include<string.h>
//#include<string>
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int MAXN = 1000000;
//int fac[] = { 1,1,2,6,24,120,720,5040,40320,362880 };//康拖展开判重
////            0!1!2!3! 4! 5!  6!  7!   8!    9!
//bool vis[MAXN];//标记
//
//int cantor(int s[])//康拖展开求该序列的hash值
//{
//
//	int sum = 0;
//	for (int i = 0; i < 9; i++)
//	{
//		int num = 0;
//		for (int j = i + 1; j < 9; j++)
//			if (s[j] < s[i]) {
//				num++;// // 在 i 之后，比 i 还小的有几个
//			}
//		sum += (num*fac[9 - i - 1]);
//		/*for (int j = 0; j < 9; j++) {
//			cout << s[j];
//		}
//		cout << " " << i << " " << sum << endl;*/
//	}
//	return sum + 1;
//}
//struct Node
//{
//	int s[9];
//	int loc;//“0”的位置,把“x"当0
//	int status;//康拖展开的hash值
//	string path;//路径
//};
//string path;
//int aim = 46234;//123456780对应的康拖展开的hash值
//const int dir[4][2] = { { -1,0 },{ 1,0 },{ 0,-1 },{ 0,1 } };//u,d,l,r
//char indexs[5] = "udlr";//正向搜索
//Node start;
//bool bfs()
//{
//	memset(vis, false, sizeof(vis));
//	Node cur, next;
//	queue<Node>q;
//	q.push(start);
//	while (!q.empty())
//	{
//		cur = q.front();
//		q.pop();
//		if (cur.status == aim)
//		{
//			path = cur.path;
//			return true;
//		}
//		int x = cur.loc / 3;//行 0~2
//		int y = cur.loc % 3;//列 0~2
//		for (int i = 0; i < 4; i++)//遍历4个方向
//		{
//			int tx = x + dir[i][0];
//			int ty = y + dir[i][1];
//			if (tx < 0 || tx>2 || ty < 0 || ty>2)continue;//越界
//			next = cur;
//			next.loc = tx * 3 + ty;
//			next.s[cur.loc] = next.s[next.loc];
//			next.s[next.loc] = 0;
//			next.status = cantor(next.s);
//			if (!vis[next.status])
//			{
//				vis[next.status] = true;
//				next.path = next.path + indexs[i];
//
//				if (next.status == aim)
//				{
//					path = next.path;
//					return true;
//				}
//
//				q.push(next);
//			}
//		}
//	}
//	return false;
//}
//int main()
//{
//	char ch;
//	while (cin >> ch)
//	{
//		if (ch == 'x') {
//			start.s[0] = 0; start.loc = 0;
//		}
//		else start.s[0] = ch - '0';
//		for (int i = 1; i < 9; i++)
//		{
//			cin >> ch;
//			if (ch == 'x')
//			{
//				start.s[i] = 0;
//				start.loc = i;
//			}
//			else start.s[i] = ch - '0';
//		}
//		start.status = cantor(start.s);
//		if (bfs())
//		{
//			cout << path << endl;
//		}
//		else cout << "unsolvable" << endl;
//	}
//	system("pause");
//	return 0;
//}


//1018:Communication System
//#include <iostream>
//#include <algorithm>
//using namespace std;
//#define N 105
//int main()
//{
//	int band[N][N], price[N][N], tot[N];//bandwidths、prices 、输入计数 
//	int t, n;
//	scanf("%d", &t);
//	while (t--)
//	{
//		double ans = 0;
//		int MAX = 0, MIN = 0xffff;//最大最小 bandwidths
//		scanf("%d", &n);
//		for (int i = 1; i <= n; i++)
//		{
//			scanf("%d", &tot[i]);
//			for (int j = 1; j <= tot[i]; j++)
//			{
//				scanf("%d%d", &band[i][j], &price[i][j]);
//				MAX = max(MAX, band[i][j]);
//				MIN = min(MIN, band[i][j]);
//			}
//		}
//		for (int key = MIN; key <= MAX; key++)//枚举最小宽带
//		{
//			int sum = 0;
//			for (int i = 1; i <= n; i++)//遍历n个设备
//			{
//				int M = 0xffff;
//				for (int j = 1; j <= tot[i]; j++)//遍历每个设备的制造商
//					if (band[i][j] >= key && M > price[i][j]) {
//						M = price[i][j];
//						///cout << key << " " << i << " " << j << ' ' << band[i][j] << endl;
//					}
//				sum += M;
//			}
//			if (1.0*key / sum > ans) ans = 1.0*key / sum;
//		}
//		printf("%.3lf\n", ans);
//	} return 0;
//}

//苹果消消乐
//#include<iostream>
//#include<vector>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//int n, magic;
//vector<int> v;
//vector<int> select;
//int ans = 0;
//const int maxn = 110;
//int m[maxn];
//void dfs(int cnt, int pos) {//使用第cnt个魔法道具  第cnt个魔法道具所使用的位置
//	if (cnt > magic) {
//		int mv = 0;
//		for (int i = 1; i <= 101; i++) {
//			if (m[i] == 0) {
//				mv++;
//			}
//			else {
//				ans = max(ans, mv);
//				mv = 0;
//			}
//			//cout << i << " " << m[i] << " " << mv << " " << ans << endl;
//		}
//	//	cout << "hhh " << ans << endl;
//		return ;
//	}
//	for (int i = pos; i <= n; i++) {
//		m[v[i]] = 0;
//		//cout << i << endl;
//		dfs(cnt + 1, i + 1);
//		m[v[i]] = 1;
//	}
//}
//int main() {
//	int t;
//	cin >> t;
//	for (int cnt = 0; cnt < t; cnt++) {
//		memset(m, 0, sizeof(m));
//		ans = 0;
//		v.clear();
//		cin >> n >> magic;
//		if (magic > n) {
//			magic = n;
//		}
//		v.push_back(0);
//		int tmp;
//		for (int i = 0; i < n; i++) {
//			cin >> tmp;
//			m[tmp] = 1;
//			v.push_back(tmp);//用来记录香蕉的位置 1开始计数
//		}
//		v.push_back(101);
//		m[101] = 1;
//		/*for (int i = 0; i <= 6; i++) {
//			cout << i << " " << v[i] << endl;
//		}*/
//		dfs(1, 1);
//		cout << ans << endl;
//
//	}
//	system("pause");
//	return 0;
//}

//Find them, Catch them 网上答案 没太看懂relation的变化
//#include <iostream>
//#include <cstdio>
//using namespace std;
//
//char cmd;
//int T, N, M, num1, num2, fx, fy;
//int father[100100];
//int relation[100100];// relation[i] 表示 i 这个节点和他父节点的关系，0表示同一个犯罪组织，1表示不同。
//
//int Find_father(int x)
//{
//	int temp = 0;
//	if (x == father[x])
//		return x;
//	else//路径压缩
//	{
//		temp = Find_father(father[x]);//找到父节点的父节点--即祖先节点
//		relation[x] = (relation[father[x]] + relation[x]) % 2;//修改关系
//		father[x] = temp;
//	}
//	return father[x];
//}
//
//void Union(int x, int y)//x和y是两个不同的犯罪团伙
//{
//	fx = Find_father(x);
//	fy = Find_father(y);
//	father[fx] = fy;//将x那一支归并到y的祖先节点下
//
//	if (relation[y] == 0)//y和fy相同  0表示同一个犯罪组织，1表示不同。
//		relation[fx] = 1 - relation[x];
//	else
//		relation[fx] = relation[x];
//	cout << x << " " << relation[x] << " " << fx << " " << relation[fx] << " " << y << " " << relation[y] << " " << fy << " " << relation[fy] << endl;
//
//}
//
//int main()
//{
//	cin >> T;
//	while (T--)
//	{
//		cin >> N >> M;//N个案件，M条信息
//		for (int i = 1; i <= N; i++)
//		{
//			father[i] = i;//将父节点初始化为本身
//			relation[i] = 0;
//		}
//		while (M--)
//		{
//			//	getchar();//debug时发现如果不加这个读回车，cmd就变成了回车。
//
//			cin >> cmd >> num1 >> num2;
//
//			if (cmd == 'D')
//				Union(num1, num2);
//			else if (cmd == 'A')
//			{
//				fx = Find_father(num1);
//				fy = Find_father(num2);
//				cout << "hhh " << num1 << " " << relation[num1] << " " << num2 << " " << relation[num2] << endl;
//				if (fx != fy)//不在并查集中  如果在并查集中也有如下两种不同的情况
//					printf("Not sure yet.\n");
//				else if (relation[num1] == relation[num2])//与祖先节点关系相同
//					printf("In the same gang.\n");
//				else
//					printf("In different gangs.\n");
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//Find them, Catch them  网上答案2
//#include<iostream>
//#include<cstdio>
//#include<cstring>
//using namespace std;
//
//int pre[200004];
//
//int f(int x) {
//	if (x == pre[x])return x;
//	pre[x] = f(pre[x]);
//	return pre[x];
//}
//
//void link(int a, int b) {
//	int root1 = f(a), root2 = f(b);
//	if (root1 != root2) {
//		pre[root1] = root2;
//	}
//}
//
//int main() {
//	int t, n, m, a, b;
//	char s[5];
//	cin>>t;
//	while (t--) {
//		cin>>n>>m;
//		for (int i = 1; i <= 2 * n; i++) {
//			pre[i] = i;
//		}
//		while (m--) {
//			cin>>s>>a>>b;
//			if (s[0] == 'D') {
//				link(a, b + n);
//				link(b, a + n);
//			}
//
//			else {
//				int root1 = f(a), root2 = f(b);
//				if (root1 == root2)printf("In the same gang.\n");
//				else if (root1 == f(b + n))printf("In different gangs.\n");
//				else printf("Not sure yet.\n");
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//开始敲模板题啦
//1007:DNA排序
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<algorithm>
//using namespace std;
//struct DNA {
//	string str;
//	int tot;
//};
//DNA dna[110];
//bool mycmp(DNA a, DNA b) {
//	return a.tot < b.tot;
//}
//int main() {
//	int n, m;
//	cin >> n >> m;
//	string tmp;
//	int cnt = 0;
//	for (int t = 0; t < m; t++) {
//		cin >> tmp;
//		int cnta = 0;
//		int cntc = 0;
//		int cntg = 0;
//		int cntt = 0;
//		int ans = 0;
//		for (int i = n - 1; i >= 0; i--) {
//			switch (tmp[i])
//			{
//			case 'A':cnta++;break;
//			case 'C':cntc++; ans += cnta; break;
//			case 'G':cntg++; ans += cnta + cntc; break;
//			case 'T': ans += cnta + cntc + cntg; break;
//			default:	break;
//			}
//		}
//		dna[cnt].str = tmp;
//		dna[cnt].tot = ans;
//		cnt++;
//	}
//	stable_sort(dna,dna + m,mycmp);
//	for (int i = 0; i < m; i++) {
//		cout << dna[i].str << endl;
//	}
//	system("pause");
//	return 0;
//}

//1035:拼写检查
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<set>
//#include<vector>
//#include<algorithm>
//using namespace std;
//int main() {
//	string tmp;
//	vector<string> v;
//	while (cin >> tmp) {
//		if (tmp == "#") {
//			break;
//		}
//		v.push_back(tmp);
//	}
//	while (cin >> tmp) {
//		if (tmp == "#") {
//			break;
//
//		}
//		int len = tmp.size();
//		if (find(v.begin(), v.end(), tmp) != v.end()) {
//			cout << tmp << " is correct" << endl;
//		}
//		else {
//			cout << tmp << ": ";
//			for (auto itr = v.begin(); itr != v.end(); itr++) {
//				//cout << "now " << *itr << endl;
//				if ((*itr).size() == len) {
//					int cnt = 0;
//					for (int i = 0; i < len; i++) {
//						if ((*itr)[i] != tmp[i]) {
//							cnt++;
//						}
//					}
//					if (cnt == 1) {
//						cout << *itr << " ";
//					}
//				}
//				else if ((*itr).size() == len - 1) {
//					int cnt = 0;
//					string cp = *itr;
//					cp[len-1] = '0';
//					for (int i = 0, j = 0; j < len&&i < len ; j++, i++) {
//						if (cp[i] != tmp[j]) {
//							cnt++;
//							i--;
//						}
//					}
//					if (cnt == 1) {
//						cout << *itr << " ";
//					}
//				}
//				else if ((*itr).size() == len + 1) {
//					int cnt = 0;
//					string cp = tmp;
//					cp[len] = '0';
//					for (int i = 0, j = 0; (j <= len) && (i < len + 1); j++, i++) {
//						if ((*itr)[i] != cp[j]) {
//							cnt++;
//							j--;
//						}
//					}
//					//cout << *itr << ' ' << cnt << endl;
//
//					if (cnt == 1) {
//						cout << *itr << " ";
//					}
//				}
//			}
//			cout << endl;
//		}
//
//	}
//	system("pause");
//	return 0;
//}

//1088:滑雪
//#include<iostream>
//#include<climits>
//#include<algorithm>
//using namespace std;
//int r, c;
//const int maxn = 110;
//int m[maxn][maxn];
//int dp[maxn][maxn];
//int fun(int x, int y) {
//	if (dp[x][y] != 0) {
//		return dp[x][y];
//	}
//	if (x - 1 >= 1 && m[x - 1][y] < m[x][y]) {
//		dp[x][y] = max(dp[x][y], fun(x - 1, y) + 1);
//	}
//	if (y - 1 >= 1 && m[x][y - 1] < m[x][y]) {
//		dp[x][y] = max(dp[x][y], fun(x, y - 1) + 1);
//	}
//	if (x + 1 <= r && m[x + 1][y] < m[x][y]) {
//		dp[x][y] = max(dp[x][y], fun(x + 1, y) + 1);
//	}
//	if (y + 1 <= c && m[x][y + 1] < m[x][y]) {
//		dp[x][y] = max(dp[x][y], fun(x, y + 1) + 1);
//	}
//	return dp[x][y];
//}
//int main() {
//
//	cin >> r >> c;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cin >> m[i][j];
//		}
//	}
//	int ans = 0;
//	for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			int tmp = fun(i, j);
//			ans = max(ans, tmp);
//		}
//	}
//	/*for (int i = 1; i <= r; i++) {
//		for (int j = 1; j <= c; j++) {
//			cout << dp[i][j] << " ";
//
//		}
//		cout << endl;
//	}*/
//	cout << ans + 1 << endl;
//	system("pause");
//	return 0;
//}


//硬币 https://www.jianshu.com/p/9e0375e7ace1
//#include<cstdio>
//#include<algorithm>
//#include<cstring>
//#include<iostream>
//using namespace std;
//
//const int maxn = 201;
//int a[maxn];
//int f[10001];
//int g[10001];
//int n, x, t = 0;
//int b[maxn];
//
//int main() {
//	cin >> n >> x;
//	memset(b, 0, sizeof(b));
//	for (int i = 0; i < n; ++i)cin >> a[i];
//	f[0] = 1;//统计达到j个金额有多少种方法
//	for (int i = 0; i < n; ++i) {
//		for (int j = x; j >= a[i]; --j) {
//			f[j] += f[j - a[i]];
//		}
//		//cout << i << endl;
//	}
//	/*for (int j = 0; j <= 18; j++) {
//		cout << j << " " << f[j] << endl;
//	}*/
//
//	for (int i = 0; i < n; i++) {
//		memset(g, 0, sizeof(g));//除了第i枚硬币，其他都可以用的情况下 能组成j元的方案数
//		for (int j = 0; j <= x; j++) {
//			if (j - a[i] >= 0) {
//				//f[j]由两部分组成  一部分有第i枚硬币 一部分没有第i枚硬币
//				g[j] = f[j] - g[j - a[i]];//g[j - a[i]]表示用了第i枚硬币的情况下，能达到j元的方案数
//			}
//			else g[j] = f[j];
//			
//		}
//		cout << i << endl;
//		for (int k = 0; k <= 18; k++) {
//			cout << k << " " << g[k] << endl;
//		}
//		if (g[x] == 0) {
//			b[i] = 1;
//			t++;
//		}
//	}
//	printf("%d\n", t);
//	t = 0;
//	for (int i = 0; i < n; i++) {
//		if (b[i] == 1) {
//			if (t) {
//				printf(" ");
//			}
//			printf("%d", a[i]);
//			t++;
//		}
//	}
//	printf("\n");
//	system("pause");
//	return 0;
//}


//1184:聪明的打字员
//#include<iostream>	
//#include<cstring>
//#include<string>
//#include<algorithm>
//#include<queue>
//#include<sstream>
//using namespace std;
//string start, ed;
//const int maxn = 1000000;
//int vis[maxn][10];
//struct Node {
//	string str;
//	int step;
//	int pos;
//	bool operator<(const Node & a) const {
//		return step > a.step;
//	}
//};
//int  bfs() {
//	priority_queue<Node> q;
//	Node first;
//	first.str = start;
//	first.step = 0;
//	first.pos = 0;
//	q.push(first);
//	while (!q.empty()) {
//		Node now = q.top();
//		q.pop();
//		//cout << now.str << " " << now.pos << "	" << now.step << endl;
//		if (now.str == ed) {
//			return now.step;
//		}
//		stringstream ss;
//		int status;
//		ss << now.str;
//		ss >> status;
//		if (vis[status][now.pos]) {
//			continue;
//		}
//		vis[status][now.pos] = 1;
//
//		//与下标0交换
//		Node next1 = now;
//		char tmp = next1.str[next1.pos];
//		next1.str[next1.pos] = next1.str[0];
//		next1.str[0] = tmp;
//		next1.step++;
//		q.push(next1);
//		//与下标5交换
//		Node next2 = now;
//		char tmp2 = next2.str[next2.pos];
//		next2.str[next2.pos] = next2.str[5];
//		next2.str[5] = tmp2;
//		next2.step++;
//		q.push(next2);
//		//加1
//		Node next3 = now;
//		if (next3.str[next3.pos] != '9') {
//			next3.str[next3.pos]++;
//		}
//		next3.step++;
//		q.push(next3);
//		//减1
//		Node next4 = now;
//		if (next4.str[next4.pos] != '0') {
//			next4.str[next4.pos]--;
//		}
//		next4.step++;
//		q.push(next4);
//		//左移
//		Node next5 = now;
//		//cout << "hhh " << next5.pos << endl;
//		if (next5.pos > 0 && next5.pos < 5 ) {
//			//cout << "hhh5" << endl;
//
//			if (next5.str[next5.pos] == ed[next5.pos]) {
//				next5.pos--;
//				next5.step++;
//				q.push(next5);
//			}
//		}
//		else if (next5.pos == 0 || next5.pos == 5) {
//			//cout << "hhh5" << endl;
//			if (next5.pos == 5) {
//				next5.pos--;
//			}
//			next5.step++;
//			q.push(next5);
//		}
//		//右移
//		Node next6 = now;
//		if (next6.pos > 0 && next6.pos < 5 && next6.str[next6.pos] == ed[next6.pos]) {
//			//cout << "hhh " << endl;
//			next6.pos++;
//			next6.step++;
//			q.push(next6);
//		}
//		else if (next6.pos == 0 || next6.pos == 5) {
//			//cout <<"hhh "<< next6.str << " " << next6.pos << " " << next6.step << endl;
//			if (next6.pos == 0) {
//				next6.pos++;
//			}
//			next6.step++;
//			q.push(next6);
//		}
//	}
//
//
//
//}
//int main() {
//	cin >> start >> ed;
//	int ans = bfs();
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//1251:丛林中的路  正解 最开始数组开小了 只有100  开到1000000就ac了
//#include<iostream>
//#include<string>
//#include<cstring>
//#include<queue>
//#include<algorithm>
//using namespace std;
//const int maxn = 1000000;
//int dis[maxn];
//int vis[maxn];
//int ans = 0;
//struct Edge
//{
//	int v, w, next;
//};
//Edge edge[1000000];
//int head[1000000];
//int cnt = 0;
//void add_edge(int u, int v, int w) {
//	edge[cnt].v = v;
//	edge[cnt].w = w;
//	edge[cnt].next = head[u];
//	head[u] = cnt++;
//}
//struct Node {
//	int id;
//	int d;
//	Node() {};
//	Node(int _id, int _d) :id(_id), d(_d) {};
//	bool operator<(const Node &a)const {
//		return d > a.d;
//	}
//};
//void prime() {
//	priority_queue<Node> q;
//	dis[0] = 0;
//	q.push(Node(0, dis[0]));
//	while (!q.empty()) {
//		int u = q.top().id;
//		q.pop();
//		if (vis[u]) {
//			continue;
//		}
//		ans += dis[u];
//		//cout << "hhh " << char(u + 'A') << " " << dis[u] << endl;
//
//		vis[u] = 1;
//		for (int i = head[u]; i != -1; i = edge[i].next) {
//
//
//			int v = edge[i].v;
//			int w = edge[i].w;
//			//cout << char(v + 'A') << " " << w << endl;
//			if (vis[v] == 0 && w < dis[v]) {
//				dis[v] = w;
//				//cout << "suc " << char(v + 'A') << " " << w << " " << dis[v] << endl;
//				q.push(Node(v, dis[v]));
//			}
//		}
//	}
//}
//int main() {
//	int n;
//	while (cin >> n) {
//		if (n == 0) {
//			break;
//		}
//		ans = 0;
//		cnt = 0;
//		memset(dis, 0x3f, sizeof(dis));
//		memset(vis, 0, sizeof(vis));
//		memset(head, -1, sizeof(head));
//		for (int i = 0; i < n - 1; i++) {
//			char tmp;
//			cin >> tmp;
//			int cnt;
//			cin >> cnt;
//			char city;
//			int weight;
//			for (int j = 0; j < cnt; j++) {
//				cin >> city >> weight;
//				//cout << tmp - 'A' << " " << city - 'A' << " " << weight << endl;
//				//要建无向边啊！！！！
//				add_edge(tmp - 'A', city - 'A', weight);
//				add_edge(city - 'A', tmp - 'A', weight);
//			}
//		}
//		/*for (int i = head[7]; i != -1; i = edge[i].next) {
//			int v = edge[i].v;
//			int w = edge[i].w;
//			cout << v << " " << w << endl;
//		}*/
//		prime();
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//1321:棋盘问题  自己的思路
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<queue>
//using namespace std;
//int n, k;
//const int maxn = 10;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int ans = 0;
//int r[maxn];
//int c[maxn];
//void dfs(int row, int cnt) {//在第row行 放或者不放第cnt枚棋子
//	if (row > n) {
//		if (cnt == k + 1) {
//			ans++;
//		}
//		return;
//	}
//	if (cnt > k) {
//		ans++;
//		return;
//	}
//	//在row处不放旗子
//	dfs(row + 1, cnt);
//
//
//	for (int i = 1; i <= n; i++) {
//		//cout << row << " " << i << " " << cnt << " " << ans << endl;
//		if (m[row][i] == 0 && vis[row][i] == 0 && r[row] == 0 && c[i] == 0) {
//			//在row，i处放旗子
//
//			vis[row][i] = 1;
//			r[row] = 1;
//			c[i] = 1;
//			dfs(row + 1, cnt + 1);
//			vis[row][i] = 0;
//			r[row] = 0;
//			c[i] = 0;
//
//			
//		}
//		
//	}
//}
//int main() {
//	while (cin >> n >> k) {
//		if (n == -1 && k == -1) {
//			break;
//		}
//		ans = 0;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		memset(r, 0, sizeof(r));
//		memset(c, 0, sizeof(c));
//		char tmp;
//		for (int i = 1; i <= n; i++) {
//			for (int j = 1; j <= n; j++) {
//				cin >> tmp;
//				if (tmp == '#') {
//					m[i][j] = 0;
//				}
//				else {
//					m[i][j] = 1;
//				}
//			}
//		}
//		dfs(1, 1);
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//1321:棋盘问题
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//#include<queue>
//using namespace std;
//int n, k;
//const int maxn = 10;
//int m[maxn][maxn];
//int vis[maxn][maxn];
//int ans = 0;
//int r[maxn];
//int c[maxn];
//void dfs(int row, int cnt) {//表示在row行一定能放一个棋子 cnt本次放第cnt个棋子  如果第row行没发放 则进不到for循环中的if语句 返回的ans相当于没有变
//
//	for (int i = 1; i <= n; i++) {
//		if (m[row][i] == 0 && vis[row][i] == 0 && r[row] == 0 && c[i] == 0) {
//			//在row，i处放旗子
//			cout << row << " " << i << " " << cnt << " " << ans << endl;
//
//			if (cnt == k) {//因为一定会在第row行放第cnt个棋子 所以只要cnt==k就可以了
//				ans++;
//			}
//			else {
//				vis[row][i] = 1;
//				r[row] = 1;
//				c[i] = 1;
//				for (int j = row + 1; j <= n - k + cnt + 1; j++) {
//					dfs(j, cnt + 1);
//				}
//
//				vis[row][i] = 0;
//				r[row] = 0;
//				c[i] = 0;
//			}
//
//		}
//	}
//}
//int main() {
//	while (cin >> n >> k) {
//		if (n == -1 && k == -1) {
//			break;
//		}
//		ans = 0;
//		memset(m, 0, sizeof(m));
//		memset(vis, 0, sizeof(vis));
//		memset(r, 0, sizeof(r));
//		memset(c, 0, sizeof(c));
//		char tmp;
//		for (int i = 1; i <= n; i++) {
//			for (int j = 1; j <= n; j++) {
//				cin >> tmp;
//				if (tmp == '#') {
//					m[i][j] = 0;
//				}
//				else {
//					m[i][j] = 1;
//				}
//			}
//		}
//		for (int i = 1; i <= n - k + 1; i++) {
//			dfs(i, 1);
//			cout << i << " " << ans << endl;
//		}
//
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}


//1664:放苹果
//#include<iostream>
//#include<algorithm>
//using namespace std;
//int apple, plate;
//int slv(int apple, int plate) {
//	//这里加不加apple == 0 都能过
//	if (apple == 0 || plate == 0 || apple == 1 || plate == 1) {
//		return 1;
//	}
//	if (apple < plate) {
//		return slv(apple, apple);//这里一定要加return
//	}
//	else {
//		return slv(apple - plate, plate) + slv(apple, plate - 1);
//	}
//}
//int main() {
//	int t;
//	cin >> t;
//	for (int i = 0; i < t; i++) {
//		cin >> apple >> plate;
//		int ans = slv(apple, plate);
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}

//1833:排列
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int maxn = 1050;
//int m[maxn];
//int main() {
//	int t;
//	cin >> t;
//	for (int i = 0; i < t; i++) {
//		int n, k;
//		cin >> n >> k;
//		for (int j = 0; j < n; j++) {
//			cin >> m[j];
//		}
//		while (k) {
//			next_permutation(m, m + n);
//			k--;
//		}
//		for (int j = 0; j < n; j++) {
//			cout << m[j] << " ";
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//1961:前缀中的周期 自己写
//#include<iostream>
//#include<string>
//#include<cstring>
//using namespace std;
//string str;
//int len;
//const int maxn = 1000010;
//int Next[maxn];
//void getnext() {
//	memset(Next, 0, sizeof(Next));
//	int k = -1;
//	int j = 0;
//	Next[0] = -1;
//	while (j <= len) {
//		if (k == -1 || str[k] == str[j]) {
//			k++;
//			j++;
//			Next[j] = k;
//		}
//		else {
//			k = Next[k];
//		}
//	}
//}
//int main() {
//	int cnt = 1;
//	while (cin >> len) {
//		if (len == 0) {
//			break;
//		}
//		cin >> str;
//		getnext();//next[i]数组的含义是 在下标为i的字符之前的字符串的最大前缀后缀
//		/*for (int i = 0; i <= len; i++) {
//			cout << i << " " << Next[i] << endl;
//		}*/
//		cout << "Test case #" << cnt << endl;
//		cnt++;
//		for (int i = 2; i <= len; i++) {
//			if (Next[i] != 0 && Next[i] % (i - Next[i]) == 0) {
//				cout << i << " " << (i / (i - Next[i])) << endl;
//			}
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//2678:基因检测 自己写
//#include<iostream>
//#include<cstring>
//#include<sstream>
//#include<algorithm>
//using namespace std;
//
//int main() {
//	int n;
//	cin >> n;
//	string a, b;
//	for (int cnt = 0; cnt < n; cnt++) {
//		cin >> a >> b;
//		int lena = a.length();
//		int lenb = b.length();
//		int len = min(lena, lenb);
//		for (int i = len; i >= 0; i--) {
//			for (int j = 0; j <= lena - i; j++) {
//				for (int k = 0; k <= lenb - i; k++) {
//					//cout << i << " " << j << " " << k << " " << a.substr(j, i) << " " << b.substr(k, i) << endl;
//					if (a.substr(j, i) == b.substr(k, i)) {
//						cout << i << endl;
//						goto END;
//					}
//				}
//			}
//		}
//	END:
//		;
//	}
//	system("pause");
//	return 0;
//}

//2684:求阶乘的和  longlong 可以开到320位
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 20;
//int ans[maxn];
//int main() {
//	int n;
//	cin >> n;
//	long long ans = 1;
//	long long tmp = 1;
//	for (int i = 2; i <= n; i++) {
//		tmp = tmp * i;
//		ans = ans + tmp;
//	}
//	cout << ans << endl;
//	system("pause");
//	return 0;
//}

//2686:打印完数
//#include<iostream>
//#include<vector>
//using namespace std;
//int main() {
//	for (int i = 1; i <= 1000; i++) {
//		vector<int> v; 
//		int sum = 0;
//		for (int j = 1; j * 2 <= i; j++) {
//			if (i%j == 0) {
//				v.push_back(j);
//				sum += j;
//			}
//		}
//		if (sum == i) {
//			cout << i << " its factors are ";
//			int f = 1;
//			for (auto itr = v.begin(); itr != v.end(); itr++) {
//				if (f) {
//					cout << *itr;
//					f = 0;
//				}
//				else {
//					cout << "," << *itr;
//				}
//			}
//			cout << endl;
//		}
//		
//	}
//	system("pause");
//	return 0;
//}


//2698:八皇后问题
//#include<iostream>
//#include<cstring>
//using namespace std;
//int row[9];
//int duijiao[20];
//int ciduijiao[20];
//int trace[10][10];
//int tot = 1;
//void dfs(int y, int cnt) {
//	if (cnt >= 9) {
//		cout << "No. " << tot << endl;
//		tot++;
//		for (int i = 1; i <= 8; i++) {
//			for (int j = 1; j <= 8; j++) {
//				cout << trace[i][j] << " ";
//			}
//			cout << endl;
//		}
//		return;
//	}
//		for (int i = 1; i <= 8; i++) {
//			if (row[i] == 0 && duijiao[i - y + 8] == 0 && ciduijiao[i + y] == 0) {
//				row[i] = 1;
//				duijiao[i - y + 8] = 1;
//				ciduijiao[i + y] = 1;
//				trace[i][y] = 1;
//				dfs(y + 1, cnt + 1);
//				trace[i][y] = 0;
//				row[i] = 0;
//				duijiao[i - y + 8] = 0;
//				ciduijiao[i + y] = 0;
//			}
//		}
//	
//}
//int main() {
//	dfs(1, 1);
//	system("pause");
//	return 0;
//}

//2704:竞赛评分
//#include<iostream>
//#include<string>
//#include<algorithm>
//using namespace std;
//struct Person
//{
//	int id;
//	int score = 0;
//};
//bool mycmp(Person a, Person b) {
//	if (a.score == b.score) {
//		return a.id < b.id;
//	}
//	else {
//		return a.score > b.score;
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	Person p[4];
//	string a, b, c;
//	p[0].id = 1;
//	p[1].id = 2;
//	p[2].id = 3;
//	p[3].id = 4;
//	p[3].score = -10000000;
//	for (int i = 1; i <= n; i++) {
//		cin >> a >> b >> c;
//		if (a[0] == 'r') {
//			p[0].score += 10;
//		}
//		if (b[0] == 'r') {
//			p[1].score += 10;
//		}
//		if (c[0] == 'r') {
//			p[2].score += 10;
//		}
//		if (a[0] == 'w') {
//			p[0].score -= 10;
//		}
//		if (b[0] == 'w') {
//			p[1].score -= 10;
//		}
//		if (c[0] == 'w') {
//			p[2].score -= 10;
//		}
//	}
//	stable_sort(p, p +4, mycmp);
//	for (int i = 0; i < 3; i++) {
//		int tmp = p[i].score;
//		int tmppos = i;
//		//if (i != n)
//		cout << "(" << p[i].id << "," << p[i].score << ")";
//		while (p[tmppos + 1].score == tmp) {
//			if (tmppos + 1 != n) {
//				cout << "(" << p[tmppos + 1].id << "," << p[tmppos + 1].score << ")";
//				tmppos++;
//				i = tmppos;
//			}
//
//		}
//		cout << endl;
//	}
//	system("pause");
//	return 0;
//}


//2710:数制转换
//#include<iostream>
//#include<cstring>
//#include<string>
//#include<sstream>
//using namespace std;
//const int maxn = 100;
//int tran[maxn];
//int tmpans[maxn];
//char ans[maxn];
//int main() {
//	int a, b;
//	string str;
//	cin >> a >> str >> b;
//	if (str == "0") {
//		cout << 0 << endl;
//		system("pause");
//		return 0;
//	}
//	for (int i = 0; i < str.length(); i++) {
//		if (isalpha(str[i])) {
//			str[i] = toupper(str[i]);
//			tran[i] = str[i] - 'A' + 10;
//		}
//		else {
//			tran[i] = str[i] - '0';
//		}
//		//cout << i << " " << tran[i] << endl;
//	}
//	//int line = a;
//	int ten = 0;
//	for (int i = 0; i < str.length(); i++) {
//		ten = ten * a + tran[i];
//	}
//	//cout << ten << endl;
//	int i = 0;
//	while (ten != 0) {
//		tmpans[i] = ten % b;
//		ten = ten / b;
//		i++;
//	}
//	while (tmpans[i] == 0)
//	{
//		i--;
//	}
//	for (; i >= 0; i--) {
//		if (tmpans[i] >= 10) {
//			ans[i] = char(tmpans[i] - 10 + 'A');
//		}
//		else {
//			ans[i] = char(tmpans[i] + '0');
//		}
//		cout << ans[i];
//	}
//	system("pause");
//	return 0;
//}

//2711:合唱队形
//#include<iostream>
//#include<algorithm>
//#include<climits>
//using namespace std;
//const int maxn = 110;
//int m[maxn];
//int dp1[maxn];
//int dp2[maxn];
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		cin >> m[i];
//	}
//	for (int i = 0; i < n; i++) {
//		dp1[i] = 1;
//		for (int j = 0; j < i; j++) {
//			if (m[j] < m[i]) {
//				dp1[i] = max(dp1[i], dp1[j] + 1);
//			}
//		}
//	}
//	for (int i = n-1; i >=0; i--) {
//		dp2[i] = 1;
//		for (int j = n-1; j > i; j--) {
//			if (m[j] < m[i]) {
//				dp2[i] = max(dp2[i], dp2[j] + 1);
//			}
//		}
//	}
//	int ans = 0;
//	for (int i = 0; i < n; i++) {
//		ans = max(ans, dp1[i] + dp2[i]);
//	}
//	cout << n - ans + 1 << endl;
//	system("pause");
//	return 0;
//}

//2723:不吉利日期
//#include<iostream>
//using namespace std;
//int mon_day[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
//int main() {
//	int f;
//	cin >> f;
//	int d = 1, m = 1;
//	int cnt = 0;
//	while (d != 14 || m != 12) {
//		d++;
//		if (d > mon_day[m]) {
//			d = 1;
//			m++;
//		}
//		cnt++;
//		//cout << d << " " << m << " " << cnt << endl;
//
//		if (d == 13) {
//			//cout << m << " " << cnt << endl;
//			if ((cnt + f) % 7 == 5) {
//				cout << m << endl;
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}

//还是采药问题
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//const int maxn = 1010;
//int c[maxn];
//int v[maxn];
//int dp[maxn];
//int main() {
//	memset(dp, 0, sizeof(dp));
//	int tot, t;
//	cin >> tot >> t;
//	for (int i = 0; i < t; i++) {
//		cin >> c[i] >> v[i];
//	}
//	for (int i = 0; i < t; i++) {
//		for (int j = tot; j >= c[i]; j--) {
//			dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
//		}
//	}
//	cout << dp[tot] << endl;
//	system("pause");
//	return 0;
//}


//2731:求10000以内n的阶乘   while超时
//#include<iostream>
//#include<cstring>
//using namespace std;
//const int maxn = 35670;
//int ans[maxn];
//int main() {
//	memset(ans, 0, sizeof(ans));
//	int n;
//	cin >> n;
//	long long tmp, left;
//	ans[0] = 1;
//	for (int i = 1; i <= n; i++) {
//		left = 0;
//		for (int j = 0; j < maxn; j++) {
//			tmp = ans[j] * i + left;
//			ans[j] = tmp % 10;
//			left = tmp / 10;
//			//cout << i << " " << j << " " << ans[j] << " " << left << endl;
//		}
//	}
//	//cout << "hhh" << endl;
//	int pos = maxn;
//	/*while (ans[pos] == 0) {
//		pos--;
//	}*/
//	for (pos = maxn; pos >= 0; pos--) {
//		if (ans[pos] != 0) {
//			break;
//		}
//	}
//	for (; pos >= 0; pos--) {
//		cout << ans[pos];
//	}
//	system("pause");
//	return 0;
//}


//2746:约瑟夫问题
//#include<iostream>
//using namespace std;
//const int maxn = 310;
//int mp[maxn];
//int main() {
//	int n, m;
//	while (cin >> n >> m) {
//		if (n == 0 && m == 0) {
//			break;
//		}
//		for (int i = 0; i < n; i++) {
//			mp[i] = 1;
//		}
//		int index = 0;
//		for (int i = 0; i < n-1; i++) {
//			int cnt = 0;
//
//			while (1)
//			{
//				index =  (index + 1) % n;
//				if (mp[index] == 1) {
//					cnt++;
//					//cout << i << " " << cnt << " " << index << endl;
//
//					if (cnt == m) {
//						mp[index] = 0;
//						//index++;
//						break;
//					}
//				}
//			}
//
//		}
//		for (int i = 0; i < n; i++) {
//			if (mp[i] == 1) {
//				if (i == 0) {
//					cout << n << endl;;
//				}
//				else {
//					cout << i << endl;
//				}
//			}
//		}
//	}
//	system("pause");
//	return 0;
//}


//2748:全排列
//#include<iostream>
//#include<algorithm>
//#include<string>
//#include<set>
//using namespace std;
//const int maxn = 10;
//int m[maxn];
//
//set<int> s;
//int main() {
//	string str;
//	cin >> str;
//
//	int len = str.length();
//	for (int i = 0; i < len; i++) {
//		s.insert(str[i] - 'a');
//	}
//	int i = 0;
//	for (auto itr = s.begin(); itr != s.end(); itr++) {
//		m[i] = *itr;
//		i++;
//	}
//	do {
//		for (int i = 0; i < len; i++) {
//			cout << char(m[i] + 'a');
//		}
//		cout << endl;
//	} while (next_permutation(m, m + len));
//	system("pause");
//	return 0;
//}

//2749:分解因数
//#include<iostream>
//using namespace std;
//int fun(int a,int  b) {
//	if (a == 1) {
//		return 1;
//	}
//	if (b == 1) {
//		return 0;
//	}
//	if (a%b == 0) {
//		return fun(a/b, b) + fun(a, b - 1);
//	}
//	else {
//		return fun(a, b - 1);
//	}
//}
//int main() {
//	int n;
//	cin >> n;
//	int a;
//	for (int i = 0; i < n; i++) {
//		cin >> a;
//		int ans = fun(a, a);
//		cout << ans << endl;
//	}
//	system("pause");
//	return 0;
//}
